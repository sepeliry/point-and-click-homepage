{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,A,W,iB,C,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,gB,I,G,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,SE4BA,IAAM,EAAsB,IACrB,EAAA,aAAA,CACH,EAAA,WAAA,CACA,EAAA,kBAAA,CACA,EAAA,eAAA,CACA,EAAA,cAAA,CACA,EAAA,eAAA,CACA,EAAA,oBAAA,CACA,EAAA,gBAAA,CACA,EAAA,oBAAA,CACA,EAAA,cAAA,CACA,EAAA,eAAA,CACA,EAAA,aAAA,CACA,EAAA,eAAA,CACA,EAAA,iBAAA,CACJ,CACM,EAAoB,IAAI,EAAA,iBAAA,CAAiB,CACzC,EAAuB,CAAC,EAAA,cAAA,CAAgB,EAAA,aAAA,CAAe,EAAA,iBAAA,CAAiB,CAGxE,EAAwD,EAAC,CACzD,EAA0D,EAAC,CAC3D,EAAqD,EAAC,CAE5D,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,iBAAA,CAAkB,AAAA,EAAA,aAAA,CAAc,WAAA,CAAa,GACxD,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,iBAAA,CAAkB,AAAA,EAAA,aAAA,CAAc,UAAA,CAAY,GACvD,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,iBAAA,CAAkB,AAAA,EAAA,aAAA,CAAc,iBAAA,CAAmB,GAG9D,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,GAAA,IAAO,KAAwB,KAAsB,EA6FzD,OAAM,UACD,EAAA,gBAAA,CAKR,aACA,CASI,KAAA,CARqB,CACjB,KAAM,QACN,KAAM,AAAA,EAAA,YAAA,CAAa,KAAA,CACnB,QAAA,EACA,YAAA,EACA,mBAAA,CAAA,EAGc,CAE1B,C,G,E,Q,S,C,C,C,E,E,E,O,C,oB,I,G,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,QElJO,OAAM,EAYF,MACP,CAC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","sources":["<anon>","node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs","node_modules/pixi.js/src/rendering/renderers/gl/WebGLRenderer.ts","node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs","node_modules/pixi.js/src/scene/graphics/gl/GlGraphicsAdaptor.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/batchSamplersUniformGroup.ts","node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs","node_modules/pixi.js/src/scene/mesh/gl/GlMeshAdaptor.ts","node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs","node_modules/pixi.js/src/rendering/batcher/gl/GlBatchAdaptor.ts","node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gl/buffer/GlBufferSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs","node_modules/pixi.js/src/rendering/renderers/gl/buffer/const.ts","node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs","node_modules/pixi.js/src/rendering/renderers/gl/buffer/GlBuffer.ts","node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gl/context/GlContextSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs","node_modules/pixi.js/src/rendering/renderers/gl/geometry/GlGeometrySystem.ts","node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs","node_modules/pixi.js/src/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.ts","node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs","node_modules/pixi.js/src/rendering/renderers/gl/texture/const.ts","node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gl/GlBackBufferSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gl/GlColorMaskSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gl/GlEncoderSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gl/GlStencilSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gl/GlUboSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/createUboElementsSTD40.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/createUboSyncSTD40.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.ts","node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs","node_modules/pixi.js/src/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.ts","node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs","node_modules/pixi.js/src/rendering/renderers/gl/GlRenderTarget.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/GlShaderSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/GenerateShaderSyncCode.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/generateProgram.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/GlProgramData.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/compileShader.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/defaultValue.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/mapType.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getUboData.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getUniformData.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/logProgramError.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/GlUniformGroupSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/generateUniformsSync.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.ts","node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gl/state/GlStateSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs","node_modules/pixi.js/src/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.ts","node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gl/texture/GlTextureSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs","node_modules/pixi.js/src/rendering/renderers/gl/texture/GlTexture.ts","node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs","node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.ts","node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs","node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.ts","node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs","node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadImageResource.ts","node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs","node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.ts","node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs","node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/applyStyleParams.ts","node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs","node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/pixiToGlMaps.ts","node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs","node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.ts","node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs","node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.ts","node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs","node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/mapFormatToGlType.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire0da3\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"kpxDv\", function(module, exports) {\n\n$parcel$export(module.exports, \"WebGLRenderer\", () => $08c34e1ba95c0965$export$f6cc00ef28d7cf97);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $cptWh = parcelRequire(\"cptWh\");\n\nvar $9S3KH = parcelRequire(\"9S3KH\");\n\nvar $8ml9k = parcelRequire(\"8ml9k\");\n\nvar $3UUq4 = parcelRequire(\"3UUq4\");\n\nvar $4deGe = parcelRequire(\"4deGe\");\n\nvar $2bK9z = parcelRequire(\"2bK9z\");\n\nvar $aJW6I = parcelRequire(\"aJW6I\");\n\nvar $8D8uA = parcelRequire(\"8D8uA\");\n\nvar $7aRIR = parcelRequire(\"7aRIR\");\n\nvar $1a3Lw = parcelRequire(\"1a3Lw\");\n\nvar $4xaOd = parcelRequire(\"4xaOd\");\n\nvar $94DBT = parcelRequire(\"94DBT\");\n\nvar $cozHw = parcelRequire(\"cozHw\");\n\nvar $jvNyo = parcelRequire(\"jvNyo\");\n\nvar $fA05m = parcelRequire(\"fA05m\");\n\nvar $2Z5qq = parcelRequire(\"2Z5qq\");\n\nvar $jS5sk = parcelRequire(\"jS5sk\");\n\nvar $39wDe = parcelRequire(\"39wDe\");\n\nvar $2WDu2 = parcelRequire(\"2WDu2\");\n\"use strict\";\nconst $08c34e1ba95c0965$var$DefaultWebGLSystems = [\n    ...(0, $4deGe.SharedSystems),\n    (0, $jvNyo.GlUboSystem),\n    (0, $1a3Lw.GlBackBufferSystem),\n    (0, $8D8uA.GlContextSystem),\n    (0, $aJW6I.GlBufferSystem),\n    (0, $2WDu2.GlTextureSystem),\n    (0, $fA05m.GlRenderTargetSystem),\n    (0, $7aRIR.GlGeometrySystem),\n    (0, $jS5sk.GlUniformGroupSystem),\n    (0, $2Z5qq.GlShaderSystem),\n    (0, $94DBT.GlEncoderSystem),\n    (0, $39wDe.GlStateSystem),\n    (0, $cozHw.GlStencilSystem),\n    (0, $4xaOd.GlColorMaskSystem)\n];\nconst $08c34e1ba95c0965$var$DefaultWebGLPipes = [\n    ...(0, $4deGe.SharedRenderPipes)\n];\nconst $08c34e1ba95c0965$var$DefaultWebGLAdapters = [\n    (0, $8ml9k.GlBatchAdaptor),\n    (0, $9S3KH.GlMeshAdaptor),\n    (0, $cptWh.GlGraphicsAdaptor)\n];\nconst $08c34e1ba95c0965$var$systems = [];\nconst $08c34e1ba95c0965$var$renderPipes = [];\nconst $08c34e1ba95c0965$var$renderPipeAdaptors = [];\n(0, $i9BKe.extensions).handleByNamedList((0, $i9BKe.ExtensionType).WebGLSystem, $08c34e1ba95c0965$var$systems);\n(0, $i9BKe.extensions).handleByNamedList((0, $i9BKe.ExtensionType).WebGLPipes, $08c34e1ba95c0965$var$renderPipes);\n(0, $i9BKe.extensions).handleByNamedList((0, $i9BKe.ExtensionType).WebGLPipesAdaptor, $08c34e1ba95c0965$var$renderPipeAdaptors);\n(0, $i9BKe.extensions).add(...$08c34e1ba95c0965$var$DefaultWebGLSystems, ...$08c34e1ba95c0965$var$DefaultWebGLPipes, ...$08c34e1ba95c0965$var$DefaultWebGLAdapters);\nclass $08c34e1ba95c0965$export$f6cc00ef28d7cf97 extends (0, $3UUq4.AbstractRenderer) {\n    constructor(){\n        const systemConfig = {\n            name: \"webgl\",\n            type: (0, $2bK9z.RendererType).WEBGL,\n            systems: $08c34e1ba95c0965$var$systems,\n            renderPipes: $08c34e1ba95c0965$var$renderPipes,\n            renderPipeAdaptors: $08c34e1ba95c0965$var$renderPipeAdaptors\n        };\n        super(systemConfig);\n    }\n}\n\n});\nparcelRegister(\"cptWh\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlGraphicsAdaptor\", () => $5a3cc73d4355d7e9$export$973696ef22548d24);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $67Wkd = parcelRequire(\"67Wkd\");\n\nvar $3JBHn = parcelRequire(\"3JBHn\");\n\nvar $cNnNT = parcelRequire(\"cNnNT\");\n\nvar $ikSZA = parcelRequire(\"ikSZA\");\n\nvar $huPGn = parcelRequire(\"huPGn\");\n\nvar $kSpdC = parcelRequire(\"kSpdC\");\n\nvar $5FRY8 = parcelRequire(\"5FRY8\");\n\nvar $5iDyo = parcelRequire(\"5iDyo\");\n\nvar $cryyq = parcelRequire(\"cryyq\");\n\"use strict\";\nclass $5a3cc73d4355d7e9$export$973696ef22548d24 {\n    init() {\n        const uniforms = new (0, $cryyq.UniformGroup)({\n            uColor: {\n                value: new Float32Array([\n                    1,\n                    1,\n                    1,\n                    1\n                ]),\n                type: \"vec4<f32>\"\n            },\n            uTransformMatrix: {\n                value: new (0, $eY4rt.Matrix)(),\n                type: \"mat3x3<f32>\"\n            },\n            uRound: {\n                value: 0,\n                type: \"f32\"\n            }\n        });\n        const glProgram = (0, $3JBHn.compileHighShaderGlProgram)({\n            name: \"graphics\",\n            bits: [\n                (0, $cNnNT.colorBitGl),\n                (0, $ikSZA.generateTextureBatchBitGl)((0, $67Wkd.MAX_TEXTURES)),\n                (0, $huPGn.localUniformBitGl),\n                (0, $kSpdC.roundPixelsBitGl)\n            ]\n        });\n        this.shader = new (0, $5iDyo.Shader)({\n            glProgram: glProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: (0, $5FRY8.batchSamplersUniformGroup)\n            }\n        });\n    }\n    execute(graphicsPipe, renderable) {\n        const context = renderable.context;\n        const shader = context.customShader || this.shader;\n        const renderer = graphicsPipe.renderer;\n        const contextSystem = renderer.graphicsContext;\n        const { geometry: geometry, instructions: instructions } = contextSystem.getContextRenderData(context);\n        shader.groups[0] = renderer.globalUniforms.bindGroup;\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(geometry, shader.glProgram);\n        const batches = instructions.instructions;\n        for(let i = 0; i < instructions.instructionSize; i++){\n            const batch = batches[i];\n            if (batch.size) {\n                for(let j = 0; j < batch.textures.textures.length; j++)renderer.texture.bind(batch.textures.textures[j], j);\n                renderer.geometry.draw(\"triangle-list\", batch.size, batch.start);\n            }\n        }\n    }\n    destroy() {\n        this.shader.destroy(true);\n        this.shader = null;\n    }\n}\n/** @ignore */ $5a3cc73d4355d7e9$export$973696ef22548d24.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLPipesAdaptor\n    ],\n    name: \"graphics\"\n};\n\n});\nparcelRegister(\"5FRY8\", function(module, exports) {\n\n$parcel$export(module.exports, \"batchSamplersUniformGroup\", () => $ebe5f5894ae4e7d0$export$e08a38be63346709);\n\nvar $67Wkd = parcelRequire(\"67Wkd\");\n\nvar $cryyq = parcelRequire(\"cryyq\");\n\"use strict\";\nconst $ebe5f5894ae4e7d0$var$sampleValues = new Int32Array((0, $67Wkd.MAX_TEXTURES));\nfor(let i = 0; i < (0, $67Wkd.MAX_TEXTURES); i++)$ebe5f5894ae4e7d0$var$sampleValues[i] = i;\nconst $ebe5f5894ae4e7d0$export$e08a38be63346709 = new (0, $cryyq.UniformGroup)({\n    uTextures: {\n        value: $ebe5f5894ae4e7d0$var$sampleValues,\n        type: `i32`,\n        size: (0, $67Wkd.MAX_TEXTURES)\n    }\n}, {\n    isStatic: true\n});\n\n});\n\n\nparcelRegister(\"9S3KH\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlMeshAdaptor\", () => $ee11e087d5a9ace8$export$9d77a952b0b834a5);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $eY4rt = parcelRequire(\"eY4rt\");\n\nvar $3JBHn = parcelRequire(\"3JBHn\");\n\nvar $huPGn = parcelRequire(\"huPGn\");\n\nvar $kSpdC = parcelRequire(\"kSpdC\");\n\nvar $kGDJh = parcelRequire(\"kGDJh\");\n\nvar $5iDyo = parcelRequire(\"5iDyo\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\"use strict\";\nclass $ee11e087d5a9ace8$export$9d77a952b0b834a5 {\n    init() {\n        const glProgram = (0, $3JBHn.compileHighShaderGlProgram)({\n            name: \"mesh\",\n            bits: [\n                (0, $huPGn.localUniformBitGl),\n                (0, $kGDJh.textureBitGl),\n                (0, $kSpdC.roundPixelsBitGl)\n            ]\n        });\n        this._shader = new (0, $5iDyo.Shader)({\n            glProgram: glProgram,\n            resources: {\n                uTexture: (0, $bLlTJ.Texture).EMPTY.source,\n                textureUniforms: {\n                    uTextureMatrix: {\n                        type: \"mat3x3<f32>\",\n                        value: new (0, $eY4rt.Matrix)()\n                    }\n                }\n            }\n        });\n    }\n    execute(meshPipe, mesh) {\n        const renderer = meshPipe.renderer;\n        let shader = mesh._shader;\n        if (!shader) {\n            shader = this._shader;\n            const texture = mesh.texture;\n            const source = texture.source;\n            shader.resources.uTexture = source;\n            shader.resources.uSampler = source.style;\n            shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;\n        } else if (!shader.glProgram) {\n            (0, $hUCK4.warn)(\"Mesh shader has no glProgram\", mesh.shader);\n            return;\n        }\n        shader.groups[100] = renderer.globalUniforms.bindGroup;\n        shader.groups[101] = meshPipe.localUniformsBindGroup;\n        renderer.encoder.draw({\n            geometry: mesh._geometry,\n            shader: shader,\n            state: mesh.state\n        });\n    }\n    destroy() {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n$ee11e087d5a9ace8$export$9d77a952b0b834a5.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLPipesAdaptor\n    ],\n    name: \"mesh\"\n};\n\n});\n\nparcelRegister(\"8ml9k\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlBatchAdaptor\", () => $e6d51e5fe4448b69$export$3a163a0d7700c616);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $3JBHn = parcelRequire(\"3JBHn\");\n\nvar $cNnNT = parcelRequire(\"cNnNT\");\n\nvar $ikSZA = parcelRequire(\"ikSZA\");\n\nvar $kSpdC = parcelRequire(\"kSpdC\");\n\nvar $5FRY8 = parcelRequire(\"5FRY8\");\n\nvar $5iDyo = parcelRequire(\"5iDyo\");\n\nvar $2Aebl = parcelRequire(\"2Aebl\");\n\nvar $67Wkd = parcelRequire(\"67Wkd\");\n\"use strict\";\nclass $e6d51e5fe4448b69$export$3a163a0d7700c616 {\n    constructor(){\n        this._didUpload = false;\n        this._tempState = (0, $2Aebl.State).for2d();\n    }\n    init(batcherPipe) {\n        const glProgram = (0, $3JBHn.compileHighShaderGlProgram)({\n            name: \"batch\",\n            bits: [\n                (0, $cNnNT.colorBitGl),\n                (0, $ikSZA.generateTextureBatchBitGl)((0, $67Wkd.MAX_TEXTURES)),\n                (0, $kSpdC.roundPixelsBitGl)\n            ]\n        });\n        this._shader = new (0, $5iDyo.Shader)({\n            glProgram: glProgram,\n            resources: {\n                batchSamplers: (0, $5FRY8.batchSamplersUniformGroup)\n            }\n        });\n        batcherPipe.renderer.runners.contextChange.add(this);\n    }\n    contextChange() {\n        this._didUpload = false;\n    }\n    start(batchPipe, geometry) {\n        const renderer = batchPipe.renderer;\n        renderer.shader.bind(this._shader, this._didUpload);\n        renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);\n        renderer.geometry.bind(geometry, this._shader.glProgram);\n    }\n    execute(batchPipe, batch) {\n        const renderer = batchPipe.renderer;\n        this._didUpload = true;\n        this._tempState.blendMode = batch.blendMode;\n        renderer.state.set(this._tempState);\n        const textures = batch.textures.textures;\n        for(let i = 0; i < textures.length; i++)renderer.texture.bind(textures[i], i);\n        renderer.geometry.draw(\"triangle-list\", batch.size, batch.start);\n    }\n    destroy() {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n/** @ignore */ $e6d51e5fe4448b69$export$3a163a0d7700c616.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLPipesAdaptor\n    ],\n    name: \"batch\"\n};\n\n});\n\nparcelRegister(\"aJW6I\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlBufferSystem\", () => $9d64726abaf6b9c3$export$e361bc2ee7fe27c6);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $1UZ6r = parcelRequire(\"1UZ6r\");\n\nvar $iW6sc = parcelRequire(\"iW6sc\");\n\nvar $j1e0r = parcelRequire(\"j1e0r\");\n\"use strict\";\nclass $9d64726abaf6b9c3$export$e361bc2ee7fe27c6 {\n    /**\n   * @param {Renderer} renderer - The renderer this System works for.\n   */ constructor(renderer){\n        this._gpuBuffers = /* @__PURE__ */ Object.create(null);\n        /** Cache keeping track of the base bound buffer bases */ this._boundBufferBases = /* @__PURE__ */ Object.create(null);\n        this._renderer = renderer;\n    }\n    /**\n   * @ignore\n   */ destroy() {\n        this._renderer = null;\n        this._gl = null;\n        this._gpuBuffers = null;\n        this._boundBufferBases = null;\n    }\n    /** Sets up the renderer context and necessary buffers. */ contextChange() {\n        this._gpuBuffers = /* @__PURE__ */ Object.create(null);\n        this._gl = this._renderer.gl;\n    }\n    getGlBuffer(buffer) {\n        return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);\n    }\n    /**\n   * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n   * @param buffer - the buffer to bind to the renderer\n   */ bind(buffer) {\n        const { _gl: gl } = this;\n        const glBuffer = this.getGlBuffer(buffer);\n        gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n    }\n    /**\n   * Binds an uniform buffer to at the given index.\n   *\n   * A cache is used so a buffer will not be bound again if already bound.\n   * @param buffer - the buffer to bind\n   * @param index - the base index to bind it to.\n   */ bindBufferBase(buffer, index) {\n        const { _gl: gl } = this;\n        if (this._boundBufferBases[index] !== buffer) {\n            const glBuffer = this.getGlBuffer(buffer);\n            this._boundBufferBases[index] = buffer;\n            gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n        }\n    }\n    /**\n   * Binds a buffer whilst also binding its range.\n   * This will make the buffer start from the offset supplied rather than 0 when it is read.\n   * @param buffer - the buffer to bind\n   * @param index - the base index to bind at, defaults to 0\n   * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n   */ bindBufferRange(buffer, index, offset) {\n        const { _gl: gl } = this;\n        offset = offset || 0;\n        const glBuffer = this.getGlBuffer(buffer);\n        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);\n    }\n    /**\n   * Will ensure the data in the buffer is uploaded to the GPU.\n   * @param {Buffer} buffer - the buffer to update\n   */ updateBuffer(buffer) {\n        const { _gl: gl } = this;\n        const glBuffer = this.getGlBuffer(buffer);\n        if (buffer._updateID === glBuffer.updateID) return glBuffer;\n        glBuffer.updateID = buffer._updateID;\n        gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n        const data = buffer.data;\n        if (glBuffer.byteLength >= buffer.data.byteLength) gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);\n        else {\n            const drawType = buffer.descriptor.usage & (0, $1UZ6r.BufferUsage).STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n            glBuffer.byteLength = data.byteLength;\n            gl.bufferData(glBuffer.type, data, drawType);\n        }\n        return glBuffer;\n    }\n    /** dispose all WebGL resources of all managed buffers */ destroyAll() {\n        const gl = this._gl;\n        for(const id in this._gpuBuffers)gl.deleteBuffer(this._gpuBuffers[id].buffer);\n        this._gpuBuffers = /* @__PURE__ */ Object.create(null);\n    }\n    /**\n   * Disposes buffer\n   * @param {Buffer} buffer - buffer with data\n   * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray\n   */ onBufferDestroy(buffer, contextLost) {\n        const glBuffer = this._gpuBuffers[buffer.uid];\n        const gl = this._gl;\n        if (!contextLost) gl.deleteBuffer(glBuffer.buffer);\n        this._gpuBuffers[buffer.uid] = null;\n    }\n    /**\n   * creates and attaches a GLBuffer object tied to the current context.\n   * @param buffer\n   * @protected\n   */ createGLBuffer(buffer) {\n        const { _gl: gl } = this;\n        let type = (0, $iW6sc.BUFFER_TYPE).ARRAY_BUFFER;\n        if (buffer.descriptor.usage & (0, $1UZ6r.BufferUsage).INDEX) type = (0, $iW6sc.BUFFER_TYPE).ELEMENT_ARRAY_BUFFER;\n        else if (buffer.descriptor.usage & (0, $1UZ6r.BufferUsage).UNIFORM) type = (0, $iW6sc.BUFFER_TYPE).UNIFORM_BUFFER;\n        const glBuffer = new (0, $j1e0r.GlBuffer)(gl.createBuffer(), type);\n        this._gpuBuffers[buffer.uid] = glBuffer;\n        buffer.on(\"destroy\", this.onBufferDestroy, this);\n        return glBuffer;\n    }\n}\n/** @ignore */ $9d64726abaf6b9c3$export$e361bc2ee7fe27c6.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLSystem\n    ],\n    name: \"buffer\"\n};\n\n});\nparcelRegister(\"iW6sc\", function(module, exports) {\n\n$parcel$export(module.exports, \"BUFFER_TYPE\", () => $0197e1cb86a227e9$export$b595a7e482202b96);\n\"use strict\";\nvar $0197e1cb86a227e9$export$b595a7e482202b96 = /* @__PURE__ */ ((BUFFER_TYPE2)=>{\n    BUFFER_TYPE2[BUFFER_TYPE2[\"ELEMENT_ARRAY_BUFFER\"] = 34963] = \"ELEMENT_ARRAY_BUFFER\";\n    BUFFER_TYPE2[BUFFER_TYPE2[\"ARRAY_BUFFER\"] = 34962] = \"ARRAY_BUFFER\";\n    BUFFER_TYPE2[BUFFER_TYPE2[\"UNIFORM_BUFFER\"] = 35345] = \"UNIFORM_BUFFER\";\n    return BUFFER_TYPE2;\n})($0197e1cb86a227e9$export$b595a7e482202b96 || {});\n\n});\n\nparcelRegister(\"j1e0r\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlBuffer\", () => $ffc8977bfc141d19$export$e785124e31725f3f);\n\"use strict\";\nclass $ffc8977bfc141d19$export$e785124e31725f3f {\n    constructor(buffer, type){\n        this.buffer = buffer || null;\n        this.updateID = -1;\n        this.byteLength = -1;\n        this.type = type;\n    }\n}\n\n});\n\n\nparcelRegister(\"8D8uA\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlContextSystem\", () => $719acc43fc5eb9a0$export$6efe747e26df7565);\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\"use strict\";\nconst $719acc43fc5eb9a0$var$_GlContextSystem = class _GlContextSystem {\n    /** @param renderer - The renderer this System works for. */ constructor(renderer){\n        /**\n     * Features supported by current renderer.\n     * @type {object}\n     * @readonly\n     */ this.supports = {\n            /** Support for 32-bit indices buffer. */ uint32Indices: true,\n            /** Support for UniformBufferObjects */ uniformBufferObject: true,\n            /** Support for VertexArrayObjects */ vertexArrayObject: true,\n            /** Support for SRGB texture format */ srgbTextures: true,\n            /** Support for wrapping modes if a texture is non-power of two */ nonPowOf2wrapping: true,\n            /** Support for MSAA (antialiasing of dynamic textures) */ msaa: true,\n            /** Support for mipmaps if a texture is non-power of two */ nonPowOf2mipmaps: true\n        };\n        this._renderer = renderer;\n        this.extensions = /* @__PURE__ */ Object.create(null);\n        this.handleContextLost = this.handleContextLost.bind(this);\n        this.handleContextRestored = this.handleContextRestored.bind(this);\n    }\n    /**\n   * `true` if the context is lost\n   * @readonly\n   */ get isLost() {\n        return !this.gl || this.gl.isContextLost();\n    }\n    /**\n   * Handles the context change event.\n   * @param {WebGLRenderingContext} gl - New WebGL context.\n   */ contextChange(gl) {\n        this.gl = gl;\n        this._renderer.gl = gl;\n    }\n    init(options) {\n        options = {\n            ..._GlContextSystem.defaultOptions,\n            ...options\n        };\n        if (options.context) this.initFromContext(options.context);\n        else {\n            const alpha = this._renderer.background.alpha < 1;\n            const premultipliedAlpha = options.premultipliedAlpha ?? true;\n            const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;\n            this.createContext(options.preferWebGLVersion, {\n                alpha: alpha,\n                premultipliedAlpha: premultipliedAlpha,\n                antialias: antialias,\n                stencil: true,\n                preserveDrawingBuffer: options.preserveDrawingBuffer,\n                powerPreference: options.powerPreference ?? \"default\"\n            });\n        }\n    }\n    /**\n   * Initializes the context.\n   * @protected\n   * @param {WebGLRenderingContext} gl - WebGL context\n   */ initFromContext(gl) {\n        this.gl = gl;\n        this.webGLVersion = gl instanceof (0, $iCGeI.DOMAdapter).get().getWebGLRenderingContext() ? 1 : 2;\n        this.getExtensions();\n        this.validateContext(gl);\n        this._renderer.runners.contextChange.emit(gl);\n        const element = this._renderer.view.canvas;\n        element.addEventListener(\"webglcontextlost\", this.handleContextLost, false);\n        element.addEventListener(\"webglcontextrestored\", this.handleContextRestored, false);\n    }\n    /**\n   * Initialize from context options\n   * @protected\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext\n   * @param preferWebGLVersion\n   * @param {object} options - context attributes\n   */ createContext(preferWebGLVersion, options) {\n        let gl;\n        const canvas = this._renderer.view.canvas;\n        if (preferWebGLVersion === 2) gl = canvas.getContext(\"webgl2\", options);\n        if (!gl) {\n            gl = canvas.getContext(\"webgl\", options);\n            if (!gl) throw new Error(\"This browser does not support WebGL. Try using the canvas renderer\");\n        }\n        this.gl = gl;\n        this.initFromContext(this.gl);\n    }\n    /** Auto-populate the {@link GlContextSystem.extensions extensions}. */ getExtensions() {\n        const { gl: gl } = this;\n        const common = {\n            anisotropicFiltering: gl.getExtension(\"EXT_texture_filter_anisotropic\"),\n            floatTextureLinear: gl.getExtension(\"OES_texture_float_linear\"),\n            s3tc: gl.getExtension(\"WEBGL_compressed_texture_s3tc\"),\n            s3tc_sRGB: gl.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\"),\n            // eslint-disable-line camelcase\n            etc: gl.getExtension(\"WEBGL_compressed_texture_etc\"),\n            etc1: gl.getExtension(\"WEBGL_compressed_texture_etc1\"),\n            pvrtc: gl.getExtension(\"WEBGL_compressed_texture_pvrtc\") || gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\n            atc: gl.getExtension(\"WEBGL_compressed_texture_atc\"),\n            astc: gl.getExtension(\"WEBGL_compressed_texture_astc\"),\n            bptc: gl.getExtension(\"EXT_texture_compression_bptc\"),\n            rgtc: gl.getExtension(\"EXT_texture_compression_rgtc\"),\n            loseContext: gl.getExtension(\"WEBGL_lose_context\")\n        };\n        if (this.webGLVersion === 1) this.extensions = {\n            ...common,\n            drawBuffers: gl.getExtension(\"WEBGL_draw_buffers\"),\n            depthTexture: gl.getExtension(\"WEBGL_depth_texture\"),\n            vertexArrayObject: gl.getExtension(\"OES_vertex_array_object\") || gl.getExtension(\"MOZ_OES_vertex_array_object\") || gl.getExtension(\"WEBKIT_OES_vertex_array_object\"),\n            uint32ElementIndex: gl.getExtension(\"OES_element_index_uint\"),\n            // Floats and half-floats\n            floatTexture: gl.getExtension(\"OES_texture_float\"),\n            floatTextureLinear: gl.getExtension(\"OES_texture_float_linear\"),\n            textureHalfFloat: gl.getExtension(\"OES_texture_half_float\"),\n            textureHalfFloatLinear: gl.getExtension(\"OES_texture_half_float_linear\"),\n            vertexAttribDivisorANGLE: gl.getExtension(\"ANGLE_instanced_arrays\"),\n            srgb: gl.getExtension(\"EXT_sRGB\")\n        };\n        else {\n            this.extensions = {\n                ...common,\n                colorBufferFloat: gl.getExtension(\"EXT_color_buffer_float\")\n            };\n            const provokeExt = gl.getExtension(\"WEBGL_provoking_vertex\");\n            if (provokeExt) provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);\n        }\n    }\n    /**\n   * Handles a lost webgl context\n   * @param {WebGLContextEvent} event - The context lost event.\n   */ handleContextLost(event) {\n        event.preventDefault();\n        if (this._contextLossForced) {\n            this._contextLossForced = false;\n            setTimeout(()=>{\n                if (this.gl.isContextLost()) this.extensions.loseContext?.restoreContext();\n            }, 0);\n        }\n    }\n    /** Handles a restored webgl context. */ handleContextRestored() {\n        this._renderer.runners.contextChange.emit(this.gl);\n    }\n    destroy() {\n        const element = this._renderer.view.canvas;\n        this._renderer = null;\n        element.removeEventListener(\"webglcontextlost\", this.handleContextLost);\n        element.removeEventListener(\"webglcontextrestored\", this.handleContextRestored);\n        this.gl.useProgram(null);\n        this.extensions.loseContext?.loseContext();\n    }\n    /**\n   * this function can be called to force a webGL context loss\n   * this will release all resources on the GPU.\n   * Useful if you need to put Pixi to sleep, and save some GPU memory\n   *\n   * As soon as render is called - all resources will be created again.\n   */ forceContextLoss() {\n        this.extensions.loseContext?.loseContext();\n        this._contextLossForced = true;\n    }\n    /**\n   * Validate context.\n   * @param {WebGLRenderingContext} gl - Render context.\n   */ validateContext(gl) {\n        const attributes = gl.getContextAttributes();\n        if (attributes && !attributes.stencil) (0, $hUCK4.warn)(\"Provided WebGL context does not have a stencil buffer, masks may not render correctly\");\n        const supports = this.supports;\n        const isWebGl2 = this.webGLVersion === 2;\n        const extensions = this.extensions;\n        supports.uint32Indices = isWebGl2 || !!extensions.uint32ElementIndex;\n        supports.uniformBufferObject = isWebGl2;\n        supports.vertexArrayObject = isWebGl2 || !!extensions.vertexArrayObject;\n        supports.srgbTextures = isWebGl2 || !!extensions.srgb;\n        supports.nonPowOf2wrapping = isWebGl2;\n        supports.nonPowOf2mipmaps = isWebGl2;\n        supports.msaa = isWebGl2;\n        if (!supports.uint32Indices) (0, $hUCK4.warn)(\"Provided WebGL context does not support 32 index buffer, large scenes may not render correctly\");\n    }\n};\n/** @ignore */ $719acc43fc5eb9a0$var$_GlContextSystem.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLSystem\n    ],\n    name: \"context\"\n};\n/** The default options for the system. */ $719acc43fc5eb9a0$var$_GlContextSystem.defaultOptions = {\n    /**\n   * {@link WebGLOptions.context}\n   * @default null\n   */ context: null,\n    /**\n   * {@link WebGLOptions.premultipliedAlpha}\n   * @default true\n   */ premultipliedAlpha: true,\n    /**\n   * {@link WebGLOptions.preserveDrawingBuffer}\n   * @default false\n   */ preserveDrawingBuffer: false,\n    /**\n   * {@link WebGLOptions.powerPreference}\n   * @default default\n   */ powerPreference: void 0,\n    /**\n   * {@link WebGLOptions.webGLVersion}\n   * @default 2\n   */ preferWebGLVersion: 2\n};\nlet $719acc43fc5eb9a0$export$6efe747e26df7565 = $719acc43fc5eb9a0$var$_GlContextSystem;\n\n});\n\nparcelRegister(\"7aRIR\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlGeometrySystem\", () => $af1a69b87aab7e03$export$2ee3e1b0e7ef0cc8);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $kavUV = parcelRequire(\"kavUV\");\n\nvar $4EpFm = parcelRequire(\"4EpFm\");\n\nvar $bTJRY = parcelRequire(\"bTJRY\");\n\"use strict\";\nconst $af1a69b87aab7e03$var$topologyToGlMap = {\n    \"point-list\": 0,\n    \"line-list\": 1,\n    \"line-strip\": 3,\n    \"triangle-list\": 4,\n    \"triangle-strip\": 5\n};\nclass $af1a69b87aab7e03$export$2ee3e1b0e7ef0cc8 {\n    /** @param renderer - The renderer this System works for. */ constructor(renderer){\n        this._geometryVaoHash = /* @__PURE__ */ Object.create(null);\n        this._renderer = renderer;\n        this._activeGeometry = null;\n        this._activeVao = null;\n        this.hasVao = true;\n        this.hasInstance = true;\n    }\n    /** Sets up the renderer context and necessary buffers. */ contextChange() {\n        const gl = this.gl = this._renderer.gl;\n        if (!this._renderer.context.supports.vertexArrayObject) throw new Error(\"[PixiJS] Vertex Array Objects are not supported on this device\");\n        const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;\n        if (nativeVaoExtension) {\n            gl.createVertexArray = ()=>nativeVaoExtension.createVertexArrayOES();\n            gl.bindVertexArray = (vao)=>nativeVaoExtension.bindVertexArrayOES(vao);\n            gl.deleteVertexArray = (vao)=>nativeVaoExtension.deleteVertexArrayOES(vao);\n        }\n        const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;\n        if (nativeInstancedExtension) {\n            gl.drawArraysInstanced = (a, b, c, d)=>{\n                nativeInstancedExtension.drawArraysInstancedANGLE(a, b, c, d);\n            };\n            gl.drawElementsInstanced = (a, b, c, d, e)=>{\n                nativeInstancedExtension.drawElementsInstancedANGLE(a, b, c, d, e);\n            };\n            gl.vertexAttribDivisor = (a, b)=>nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);\n        }\n        this._activeGeometry = null;\n        this._activeVao = null;\n        this._geometryVaoHash = /* @__PURE__ */ Object.create(null);\n    }\n    /**\n   * Binds geometry so that is can be drawn. Creating a Vao if required\n   * @param geometry - Instance of geometry to bind.\n   * @param program - Instance of program to use vao for.\n   */ bind(geometry, program) {\n        const gl = this.gl;\n        this._activeGeometry = geometry;\n        const vao = this.getVao(geometry, program);\n        if (this._activeVao !== vao) {\n            this._activeVao = vao;\n            gl.bindVertexArray(vao);\n        }\n        this.updateBuffers();\n    }\n    /** Reset and unbind any active VAO and geometry. */ reset() {\n        this.unbind();\n    }\n    /** Update buffers of the currently bound geometry. */ updateBuffers() {\n        const geometry = this._activeGeometry;\n        const bufferSystem = this._renderer.buffer;\n        for(let i = 0; i < geometry.buffers.length; i++){\n            const buffer = geometry.buffers[i];\n            bufferSystem.updateBuffer(buffer);\n        }\n    }\n    /**\n   * Check compatibility between a geometry and a program\n   * @param geometry - Geometry instance.\n   * @param program - Program instance.\n   */ checkCompatibility(geometry, program) {\n        const geometryAttributes = geometry.attributes;\n        const shaderAttributes = program._attributeData;\n        for(const j in shaderAttributes){\n            if (!geometryAttributes[j]) throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n        }\n    }\n    /**\n   * Takes a geometry and program and generates a unique signature for them.\n   * @param geometry - To get signature from.\n   * @param program - To test geometry against.\n   * @returns - Unique signature of the geometry and program\n   */ getSignature(geometry, program) {\n        const attribs = geometry.attributes;\n        const shaderAttributes = program._attributeData;\n        const strings = [\n            \"g\",\n            geometry.uid\n        ];\n        for(const i in attribs)if (shaderAttributes[i]) strings.push(i, shaderAttributes[i].location);\n        return strings.join(\"-\");\n    }\n    getVao(geometry, program) {\n        return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);\n    }\n    /**\n   * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n   * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n   * attribute locations.\n   * @param geometry - Instance of geometry to to generate Vao for.\n   * @param program\n   * @param _incRefCount - Increment refCount of all geometry buffers.\n   */ initGeometryVao(geometry, program, _incRefCount = true) {\n        const gl = this._renderer.gl;\n        const bufferSystem = this._renderer.buffer;\n        this._renderer.shader._getProgramData(program);\n        this.checkCompatibility(geometry, program);\n        const signature = this.getSignature(geometry, program);\n        if (!this._geometryVaoHash[geometry.uid]) {\n            this._geometryVaoHash[geometry.uid] = /* @__PURE__ */ Object.create(null);\n            geometry.on(\"destroy\", this.onGeometryDestroy, this);\n        }\n        const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n        let vao = vaoObjectHash[signature];\n        if (vao) {\n            vaoObjectHash[program._key] = vao;\n            return vao;\n        }\n        (0, $4EpFm.ensureAttributes)(geometry, program._attributeData);\n        const buffers = geometry.buffers;\n        vao = gl.createVertexArray();\n        gl.bindVertexArray(vao);\n        for(let i = 0; i < buffers.length; i++){\n            const buffer = buffers[i];\n            bufferSystem.bind(buffer);\n        }\n        this.activateVao(geometry, program);\n        vaoObjectHash[program._key] = vao;\n        vaoObjectHash[signature] = vao;\n        gl.bindVertexArray(null);\n        return vao;\n    }\n    /**\n   * Disposes geometry.\n   * @param geometry - Geometry with buffers. Only VAO will be disposed\n   * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n   */ onGeometryDestroy(geometry, contextLost) {\n        const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n        const gl = this.gl;\n        if (vaoObjectHash) {\n            if (contextLost) for(const i in vaoObjectHash){\n                if (this._activeVao !== vaoObjectHash[i]) this.unbind();\n                gl.deleteVertexArray(vaoObjectHash[i]);\n            }\n            this._geometryVaoHash[geometry.uid] = null;\n        }\n    }\n    /**\n   * Dispose all WebGL resources of all managed geometries.\n   * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n   */ destroyAll(contextLost = false) {\n        const gl = this.gl;\n        for(const i in this._geometryVaoHash){\n            if (contextLost) for(const j in this._geometryVaoHash[i]){\n                const vaoObjectHash = this._geometryVaoHash[i];\n                if (this._activeVao !== vaoObjectHash) this.unbind();\n                gl.deleteVertexArray(vaoObjectHash[j]);\n            }\n            this._geometryVaoHash[i] = null;\n        }\n    }\n    /**\n   * Activate vertex array object.\n   * @param geometry - Geometry instance.\n   * @param program - Shader program instance.\n   */ activateVao(geometry, program) {\n        const gl = this._renderer.gl;\n        const bufferSystem = this._renderer.buffer;\n        const attributes = geometry.attributes;\n        if (geometry.indexBuffer) bufferSystem.bind(geometry.indexBuffer);\n        let lastBuffer = null;\n        for(const j in attributes){\n            const attribute = attributes[j];\n            const buffer = attribute.buffer;\n            const glBuffer = bufferSystem.getGlBuffer(buffer);\n            const programAttrib = program._attributeData[j];\n            if (programAttrib) {\n                if (lastBuffer !== glBuffer) {\n                    bufferSystem.bind(buffer);\n                    lastBuffer = glBuffer;\n                }\n                const location = attribute.location;\n                gl.enableVertexAttribArray(location);\n                const attributeInfo = (0, $kavUV.getAttributeInfoFromFormat)(attribute.format);\n                const type = (0, $bTJRY.getGlTypeFromFormat)(attribute.format);\n                if (programAttrib.format?.substring(1, 4) === \"int\") gl.vertexAttribIPointer(location, attributeInfo.size, type, attribute.stride, attribute.offset);\n                else gl.vertexAttribPointer(location, attributeInfo.size, type, attributeInfo.normalised, attribute.stride, attribute.offset);\n                if (attribute.instance) {\n                    if (this.hasInstance) gl.vertexAttribDivisor(location, 1);\n                    else throw new Error(\"geometry error, GPU Instancing is not supported on this device\");\n                }\n            }\n        }\n    }\n    /**\n   * Draws the currently bound geometry.\n   * @param topology - The type primitive to render.\n   * @param size - The number of elements to be rendered. If not specified, all vertices after the\n   *  starting vertex will be drawn.\n   * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n   *  drawing will start from the first vertex.\n   * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n   *  all instances will be drawn.\n   */ draw(topology, size, start, instanceCount) {\n        const { gl: gl } = this._renderer;\n        const geometry = this._activeGeometry;\n        const glTopology = $af1a69b87aab7e03$var$topologyToGlMap[geometry.topology || topology];\n        instanceCount || (instanceCount = geometry.instanceCount);\n        if (geometry.indexBuffer) {\n            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n            if (instanceCount > 1) gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);\n            else gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n        } else if (instanceCount > 1) gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);\n        else gl.drawArrays(glTopology, start || 0, size || geometry.getSize());\n        return this;\n    }\n    /** Unbind/reset everything. */ unbind() {\n        this.gl.bindVertexArray(null);\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n    destroy() {\n        this._renderer = null;\n        this.gl = null;\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n}\n/** @ignore */ $af1a69b87aab7e03$export$2ee3e1b0e7ef0cc8.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLSystem\n    ],\n    name: \"geometry\"\n};\n\n});\nparcelRegister(\"bTJRY\", function(module, exports) {\n\n$parcel$export(module.exports, \"getGlTypeFromFormat\", () => $a0dc6a33a2d76a7c$export$7d188452319c78cb);\n\nvar $9kjPM = parcelRequire(\"9kjPM\");\n\"use strict\";\nconst $a0dc6a33a2d76a7c$var$infoMap = {\n    uint8x2: (0, $9kjPM.GL_TYPES).UNSIGNED_BYTE,\n    uint8x4: (0, $9kjPM.GL_TYPES).UNSIGNED_BYTE,\n    sint8x2: (0, $9kjPM.GL_TYPES).BYTE,\n    sint8x4: (0, $9kjPM.GL_TYPES).BYTE,\n    unorm8x2: (0, $9kjPM.GL_TYPES).UNSIGNED_BYTE,\n    unorm8x4: (0, $9kjPM.GL_TYPES).UNSIGNED_BYTE,\n    snorm8x2: (0, $9kjPM.GL_TYPES).BYTE,\n    snorm8x4: (0, $9kjPM.GL_TYPES).BYTE,\n    uint16x2: (0, $9kjPM.GL_TYPES).UNSIGNED_SHORT,\n    uint16x4: (0, $9kjPM.GL_TYPES).UNSIGNED_SHORT,\n    sint16x2: (0, $9kjPM.GL_TYPES).SHORT,\n    sint16x4: (0, $9kjPM.GL_TYPES).SHORT,\n    unorm16x2: (0, $9kjPM.GL_TYPES).UNSIGNED_SHORT,\n    unorm16x4: (0, $9kjPM.GL_TYPES).UNSIGNED_SHORT,\n    snorm16x2: (0, $9kjPM.GL_TYPES).SHORT,\n    snorm16x4: (0, $9kjPM.GL_TYPES).SHORT,\n    float16x2: (0, $9kjPM.GL_TYPES).HALF_FLOAT,\n    float16x4: (0, $9kjPM.GL_TYPES).HALF_FLOAT,\n    float32: (0, $9kjPM.GL_TYPES).FLOAT,\n    float32x2: (0, $9kjPM.GL_TYPES).FLOAT,\n    float32x3: (0, $9kjPM.GL_TYPES).FLOAT,\n    float32x4: (0, $9kjPM.GL_TYPES).FLOAT,\n    uint32: (0, $9kjPM.GL_TYPES).UNSIGNED_INT,\n    uint32x2: (0, $9kjPM.GL_TYPES).UNSIGNED_INT,\n    uint32x3: (0, $9kjPM.GL_TYPES).UNSIGNED_INT,\n    uint32x4: (0, $9kjPM.GL_TYPES).UNSIGNED_INT,\n    sint32: (0, $9kjPM.GL_TYPES).INT,\n    sint32x2: (0, $9kjPM.GL_TYPES).INT,\n    sint32x3: (0, $9kjPM.GL_TYPES).INT,\n    sint32x4: (0, $9kjPM.GL_TYPES).INT\n};\nfunction $a0dc6a33a2d76a7c$export$7d188452319c78cb(format) {\n    return $a0dc6a33a2d76a7c$var$infoMap[format] ?? $a0dc6a33a2d76a7c$var$infoMap.float32;\n}\n\n});\nparcelRegister(\"9kjPM\", function(module, exports) {\n\n$parcel$export(module.exports, \"GL_FORMATS\", () => $0ec8dcdb21c3a0fa$export$65676f49f82312ef);\n$parcel$export(module.exports, \"GL_TARGETS\", () => $0ec8dcdb21c3a0fa$export$e58b55460af355b7);\n$parcel$export(module.exports, \"GL_TYPES\", () => $0ec8dcdb21c3a0fa$export$4d480d1b811469a7);\n\"use strict\";\nvar $0ec8dcdb21c3a0fa$export$65676f49f82312ef = /* @__PURE__ */ ((GL_FORMATS2)=>{\n    GL_FORMATS2[GL_FORMATS2[\"RGBA\"] = 6408] = \"RGBA\";\n    GL_FORMATS2[GL_FORMATS2[\"RGB\"] = 6407] = \"RGB\";\n    GL_FORMATS2[GL_FORMATS2[\"RG\"] = 33319] = \"RG\";\n    GL_FORMATS2[GL_FORMATS2[\"RED\"] = 6403] = \"RED\";\n    GL_FORMATS2[GL_FORMATS2[\"RGBA_INTEGER\"] = 36249] = \"RGBA_INTEGER\";\n    GL_FORMATS2[GL_FORMATS2[\"RGB_INTEGER\"] = 36248] = \"RGB_INTEGER\";\n    GL_FORMATS2[GL_FORMATS2[\"RG_INTEGER\"] = 33320] = \"RG_INTEGER\";\n    GL_FORMATS2[GL_FORMATS2[\"RED_INTEGER\"] = 36244] = \"RED_INTEGER\";\n    GL_FORMATS2[GL_FORMATS2[\"ALPHA\"] = 6406] = \"ALPHA\";\n    GL_FORMATS2[GL_FORMATS2[\"LUMINANCE\"] = 6409] = \"LUMINANCE\";\n    GL_FORMATS2[GL_FORMATS2[\"LUMINANCE_ALPHA\"] = 6410] = \"LUMINANCE_ALPHA\";\n    GL_FORMATS2[GL_FORMATS2[\"DEPTH_COMPONENT\"] = 6402] = \"DEPTH_COMPONENT\";\n    GL_FORMATS2[GL_FORMATS2[\"DEPTH_STENCIL\"] = 34041] = \"DEPTH_STENCIL\";\n    return GL_FORMATS2;\n})($0ec8dcdb21c3a0fa$export$65676f49f82312ef || {});\nvar $0ec8dcdb21c3a0fa$export$e58b55460af355b7 = /* @__PURE__ */ ((GL_TARGETS2)=>{\n    GL_TARGETS2[GL_TARGETS2[\"TEXTURE_2D\"] = 3553] = \"TEXTURE_2D\";\n    GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP\"] = 34067] = \"TEXTURE_CUBE_MAP\";\n    GL_TARGETS2[GL_TARGETS2[\"TEXTURE_2D_ARRAY\"] = 35866] = \"TEXTURE_2D_ARRAY\";\n    GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_X\"] = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\";\n    GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_X\"] = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\";\n    GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_Y\"] = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\";\n    GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_Y\"] = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\";\n    GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_Z\"] = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\";\n    GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_Z\"] = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n    return GL_TARGETS2;\n})($0ec8dcdb21c3a0fa$export$e58b55460af355b7 || {});\nvar $0ec8dcdb21c3a0fa$export$78720182cc3ed053 = /* @__PURE__ */ ((GL_WRAP_MODES2)=>{\n    GL_WRAP_MODES2[GL_WRAP_MODES2[\"CLAMP\"] = 33071] = \"CLAMP\";\n    GL_WRAP_MODES2[GL_WRAP_MODES2[\"REPEAT\"] = 10497] = \"REPEAT\";\n    GL_WRAP_MODES2[GL_WRAP_MODES2[\"MIRRORED_REPEAT\"] = 33648] = \"MIRRORED_REPEAT\";\n    return GL_WRAP_MODES2;\n})($0ec8dcdb21c3a0fa$export$78720182cc3ed053 || {});\nvar $0ec8dcdb21c3a0fa$export$4d480d1b811469a7 = /* @__PURE__ */ ((GL_TYPES2)=>{\n    GL_TYPES2[GL_TYPES2[\"UNSIGNED_BYTE\"] = 5121] = \"UNSIGNED_BYTE\";\n    GL_TYPES2[GL_TYPES2[\"UNSIGNED_SHORT\"] = 5123] = \"UNSIGNED_SHORT\";\n    GL_TYPES2[GL_TYPES2[\"UNSIGNED_SHORT_5_6_5\"] = 33635] = \"UNSIGNED_SHORT_5_6_5\";\n    GL_TYPES2[GL_TYPES2[\"UNSIGNED_SHORT_4_4_4_4\"] = 32819] = \"UNSIGNED_SHORT_4_4_4_4\";\n    GL_TYPES2[GL_TYPES2[\"UNSIGNED_SHORT_5_5_5_1\"] = 32820] = \"UNSIGNED_SHORT_5_5_5_1\";\n    GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT\"] = 5125] = \"UNSIGNED_INT\";\n    GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT_10F_11F_11F_REV\"] = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\";\n    GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT_2_10_10_10_REV\"] = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\";\n    GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT_24_8\"] = 34042] = \"UNSIGNED_INT_24_8\";\n    GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT_5_9_9_9_REV\"] = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\";\n    GL_TYPES2[GL_TYPES2[\"BYTE\"] = 5120] = \"BYTE\";\n    GL_TYPES2[GL_TYPES2[\"SHORT\"] = 5122] = \"SHORT\";\n    GL_TYPES2[GL_TYPES2[\"INT\"] = 5124] = \"INT\";\n    GL_TYPES2[GL_TYPES2[\"FLOAT\"] = 5126] = \"FLOAT\";\n    GL_TYPES2[GL_TYPES2[\"FLOAT_32_UNSIGNED_INT_24_8_REV\"] = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\";\n    GL_TYPES2[GL_TYPES2[\"HALF_FLOAT\"] = 36193] = \"HALF_FLOAT\";\n    return GL_TYPES2;\n})($0ec8dcdb21c3a0fa$export$4d480d1b811469a7 || {});\n\n});\n\n\n\nparcelRegister(\"1a3Lw\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlBackBufferSystem\", () => $f4d90515a13653e7$export$b7a84fc7768ed0dc);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\nvar $cOnev = parcelRequire(\"cOnev\");\n\nvar $5iDyo = parcelRequire(\"5iDyo\");\n\nvar $2Aebl = parcelRequire(\"2Aebl\");\n\nvar $iA5fe = parcelRequire(\"iA5fe\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\nvar $fK92B = parcelRequire(\"fK92B\");\n\"use strict\";\nconst $f4d90515a13653e7$var$bigTriangleGeometry = new (0, $cOnev.Geometry)({\n    attributes: {\n        aPosition: [\n            -1,\n            -1,\n            // Bottom left corner\n            3,\n            -1,\n            // Bottom right corner, extending beyond right edge\n            -1,\n            3\n        ]\n    }\n});\nconst $f4d90515a13653e7$var$_GlBackBufferSystem = class _GlBackBufferSystem {\n    constructor(renderer){\n        /** if true, the back buffer is used */ this.useBackBuffer = false;\n        this._useBackBufferThisRender = false;\n        this._renderer = renderer;\n    }\n    init(options = {}) {\n        const { useBackBuffer: useBackBuffer, antialias: antialias } = {\n            ..._GlBackBufferSystem.defaultOptions,\n            ...options\n        };\n        this.useBackBuffer = useBackBuffer;\n        this._antialias = antialias;\n        if (!this._renderer.context.supports.msaa) {\n            (0, $hUCK4.warn)(\"antialiasing, is not supported on when using the back buffer\");\n            this._antialias = false;\n        }\n        this._state = (0, $2Aebl.State).for2d();\n        const bigTriangleProgram = new (0, $fK92B.GlProgram)({\n            vertex: `\n                attribute vec2 aPosition;\n                out vec2 vUv;\n\n                void main() {\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n\n                    vUv = (aPosition + 1.0) / 2.0;\n\n                    // flip dem UVs\n                    vUv.y = 1.0 - vUv.y;\n                }`,\n            fragment: `\n                in vec2 vUv;\n                out vec4 finalColor;\n\n                uniform sampler2D uTexture;\n\n                void main() {\n                    finalColor = texture(uTexture, vUv);\n                }`,\n            name: \"big-triangle\"\n        });\n        this._bigTriangleShader = new (0, $5iDyo.Shader)({\n            glProgram: bigTriangleProgram,\n            resources: {\n                uTexture: (0, $bLlTJ.Texture).WHITE.source\n            }\n        });\n    }\n    /**\n   * This is called before the RenderTargetSystem is started. This is where\n   * we replace the target with the back buffer if required.\n   * @param options - The options for this render.\n   */ renderStart(options) {\n        const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);\n        this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;\n        if (this._useBackBufferThisRender) {\n            const renderTarget2 = this._renderer.renderTarget.getRenderTarget(options.target);\n            this._targetTexture = renderTarget2.colorTexture;\n            options.target = this._getBackBufferTexture(renderTarget2.colorTexture);\n        }\n    }\n    renderEnd() {\n        this._presentBackBuffer();\n    }\n    _presentBackBuffer() {\n        const renderer = this._renderer;\n        renderer.renderTarget.finishRenderPass();\n        if (!this._useBackBufferThisRender) return;\n        renderer.renderTarget.bind(this._targetTexture, false);\n        this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;\n        renderer.encoder.draw({\n            geometry: $f4d90515a13653e7$var$bigTriangleGeometry,\n            shader: this._bigTriangleShader,\n            state: this._state\n        });\n    }\n    _getBackBufferTexture(targetSourceTexture) {\n        this._backBufferTexture = this._backBufferTexture || new (0, $bLlTJ.Texture)({\n            source: new (0, $iA5fe.TextureSource)({\n                width: targetSourceTexture.width,\n                height: targetSourceTexture.height,\n                resolution: targetSourceTexture._resolution,\n                antialias: this._antialias\n            })\n        });\n        this._backBufferTexture.source.resize(targetSourceTexture.width, targetSourceTexture.height, targetSourceTexture._resolution);\n        return this._backBufferTexture;\n    }\n    /** destroys the back buffer */ destroy() {\n        if (this._backBufferTexture) {\n            this._backBufferTexture.destroy();\n            this._backBufferTexture = null;\n        }\n    }\n};\n/** @ignore */ $f4d90515a13653e7$var$_GlBackBufferSystem.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLSystem\n    ],\n    name: \"backBuffer\",\n    priority: 1\n};\n/** default options for the back buffer system */ $f4d90515a13653e7$var$_GlBackBufferSystem.defaultOptions = {\n    /** if true will use the back buffer where required */ useBackBuffer: false\n};\nlet $f4d90515a13653e7$export$b7a84fc7768ed0dc = $f4d90515a13653e7$var$_GlBackBufferSystem;\n\n});\n\nparcelRegister(\"4xaOd\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlColorMaskSystem\", () => $43f8a01f682b3752$export$a3d248296e259116);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\"use strict\";\nclass $43f8a01f682b3752$export$a3d248296e259116 {\n    constructor(renderer){\n        this._colorMaskCache = 15;\n        this._renderer = renderer;\n    }\n    setMask(colorMask) {\n        if (this._colorMaskCache === colorMask) return;\n        this._colorMaskCache = colorMask;\n        this._renderer.gl.colorMask(!!(colorMask & 8), !!(colorMask & 4), !!(colorMask & 2), !!(colorMask & 1));\n    }\n}\n/** @ignore */ $43f8a01f682b3752$export$a3d248296e259116.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLSystem\n    ],\n    name: \"colorMask\"\n};\n\n});\n\nparcelRegister(\"94DBT\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlEncoderSystem\", () => $e8f544f1554f2871$export$9b8b7836a27ecb86);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\"use strict\";\nclass $e8f544f1554f2871$export$9b8b7836a27ecb86 {\n    constructor(renderer){\n        this.commandFinished = Promise.resolve();\n        this._renderer = renderer;\n    }\n    setGeometry(geometry, shader) {\n        this._renderer.geometry.bind(geometry, shader.glProgram);\n    }\n    finishRenderPass() {}\n    draw(options) {\n        const renderer = this._renderer;\n        const { geometry: geometry, shader: shader, state: state, skipSync: skipSync, topology: type, size: size, start: start, instanceCount: instanceCount } = options;\n        renderer.shader.bind(shader, skipSync);\n        renderer.geometry.bind(geometry, renderer.shader._activeProgram);\n        if (state) renderer.state.set(state);\n        renderer.geometry.draw(type, size, start, instanceCount ?? geometry.instanceCount);\n    }\n    destroy() {\n        this._renderer = null;\n    }\n}\n/** @ignore */ $e8f544f1554f2871$export$9b8b7836a27ecb86.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLSystem\n    ],\n    name: \"encoder\"\n};\n\n});\n\nparcelRegister(\"cozHw\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlStencilSystem\", () => $c5b3329420d2f9d8$export$3846305e84de1078);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $gmJT6 = parcelRequire(\"gmJT6\");\n\nvar $eE5Ke = parcelRequire(\"eE5Ke\");\n\"use strict\";\nclass $c5b3329420d2f9d8$export$3846305e84de1078 {\n    constructor(renderer){\n        this._stencilCache = {\n            enabled: false,\n            stencilReference: 0,\n            stencilMode: (0, $eE5Ke.STENCIL_MODES).NONE\n        };\n        this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n    contextChange(gl) {\n        this._gl = gl;\n        this._comparisonFuncMapping = {\n            always: gl.ALWAYS,\n            never: gl.NEVER,\n            equal: gl.EQUAL,\n            \"not-equal\": gl.NOTEQUAL,\n            less: gl.LESS,\n            \"less-equal\": gl.LEQUAL,\n            greater: gl.GREATER,\n            \"greater-equal\": gl.GEQUAL\n        };\n        this._stencilOpsMapping = {\n            keep: gl.KEEP,\n            zero: gl.ZERO,\n            replace: gl.REPLACE,\n            invert: gl.INVERT,\n            \"increment-clamp\": gl.INCR,\n            \"decrement-clamp\": gl.DECR,\n            \"increment-wrap\": gl.INCR_WRAP,\n            \"decrement-wrap\": gl.DECR_WRAP\n        };\n        this._stencilCache.enabled = false;\n        this._stencilCache.stencilMode = (0, $eE5Ke.STENCIL_MODES).NONE;\n        this._stencilCache.stencilReference = 0;\n    }\n    onRenderTargetChange(renderTarget) {\n        if (this._activeRenderTarget === renderTarget) return;\n        this._activeRenderTarget = renderTarget;\n        let stencilState = this._renderTargetStencilState[renderTarget.uid];\n        if (!stencilState) stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n            stencilMode: (0, $eE5Ke.STENCIL_MODES).DISABLED,\n            stencilReference: 0\n        };\n        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n    }\n    setStencilMode(stencilMode, stencilReference) {\n        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n        const gl = this._gl;\n        const mode = (0, $gmJT6.GpuStencilModesToPixi)[stencilMode];\n        const _stencilCache = this._stencilCache;\n        stencilState.stencilMode = stencilMode;\n        stencilState.stencilReference = stencilReference;\n        if (stencilMode === (0, $eE5Ke.STENCIL_MODES).DISABLED) {\n            if (this._stencilCache.enabled) {\n                this._stencilCache.enabled = false;\n                gl.disable(gl.STENCIL_TEST);\n            }\n            return;\n        }\n        if (!this._stencilCache.enabled) {\n            this._stencilCache.enabled = true;\n            gl.enable(gl.STENCIL_TEST);\n        }\n        if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {\n            _stencilCache.stencilMode = stencilMode;\n            _stencilCache.stencilReference = stencilReference;\n            gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);\n            gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);\n        }\n    }\n}\n/** @ignore */ $c5b3329420d2f9d8$export$3846305e84de1078.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLSystem\n    ],\n    name: \"stencil\"\n};\n\n});\n\nparcelRegister(\"jvNyo\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlUboSystem\", () => $e581277dbbeb8f40$export$ed85354ffed1ae01);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $gl2WV = parcelRequire(\"gl2WV\");\n\nvar $3rnpU = parcelRequire(\"3rnpU\");\n\nvar $7FPDE = parcelRequire(\"7FPDE\");\n\"use strict\";\nclass $e581277dbbeb8f40$export$ed85354ffed1ae01 extends (0, $gl2WV.UboSystem) {\n    constructor(){\n        super({\n            createUboElements: (0, $3rnpU.createUboElementsSTD40),\n            generateUboSync: (0, $7FPDE.createUboSyncFunctionSTD40)\n        });\n    }\n}\n/** @ignore */ $e581277dbbeb8f40$export$ed85354ffed1ae01.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLSystem\n    ],\n    name: \"ubo\"\n};\n\n});\nparcelRegister(\"3rnpU\", function(module, exports) {\n\n$parcel$export(module.exports, \"WGSL_TO_STD40_SIZE\", () => $ccbfffaa00bcbc6d$export$44caba1858fd4b77);\n$parcel$export(module.exports, \"createUboElementsSTD40\", () => $ccbfffaa00bcbc6d$export$aafd0047b5156d22);\n\"use strict\";\nconst $ccbfffaa00bcbc6d$export$44caba1858fd4b77 = {\n    f32: 4,\n    \"vec2<f32>\": 8,\n    \"vec3<f32>\": 12,\n    \"vec4<f32>\": 16,\n    \"mat2x2<f32>\": 32,\n    \"mat3x3<f32>\": 48,\n    \"mat4x4<f32>\": 64\n};\nfunction $ccbfffaa00bcbc6d$export$aafd0047b5156d22(uniformData) {\n    const uboElements = uniformData.map((data)=>({\n            data: data,\n            offset: 0,\n            size: 0\n        }));\n    let size = 0;\n    let chunkSize = 0;\n    let offset = 0;\n    for(let i = 0; i < uboElements.length; i++){\n        const uboElement = uboElements[i];\n        size = $ccbfffaa00bcbc6d$export$44caba1858fd4b77[uboElement.data.type];\n        if (!size) throw new Error(`Unknown type ${uboElement.data.type}`);\n        if (uboElement.data.size > 1) size = Math.max(size, 16) * uboElement.data.size;\n        uboElement.size = size;\n        if (chunkSize % size !== 0 && chunkSize < 16) {\n            const lineUpValue = chunkSize % size % 16;\n            chunkSize += lineUpValue;\n            offset += lineUpValue;\n        }\n        if (chunkSize + size > 16) {\n            offset = Math.ceil(offset / 16) * 16;\n            uboElement.offset = offset;\n            offset += size;\n            chunkSize = size;\n        } else {\n            uboElement.offset = offset;\n            chunkSize += size;\n            offset += size;\n        }\n    }\n    offset = Math.ceil(offset / 16) * 16;\n    return {\n        uboElements: uboElements,\n        size: offset\n    };\n}\n\n});\n\nparcelRegister(\"7FPDE\", function(module, exports) {\n\n$parcel$export(module.exports, \"createUboSyncFunctionSTD40\", () => $329ad5c91db53d1a$export$657524d36b99cfb7);\n\nvar $5NNJl = parcelRequire(\"5NNJl\");\n\nvar $1nMtt = parcelRequire(\"1nMtt\");\n\nvar $bhzUn = parcelRequire(\"bhzUn\");\n\"use strict\";\nfunction $329ad5c91db53d1a$export$657524d36b99cfb7(uboElements) {\n    return (0, $5NNJl.createUboSyncFunction)(uboElements, \"uboStd40\", (0, $bhzUn.generateArraySyncSTD40), (0, $1nMtt.uboSyncFunctionsSTD40));\n}\n\n});\nparcelRegister(\"bhzUn\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateArraySyncSTD40\", () => $0b910441e6a331f2$export$9fb1ab94ee86ec60);\n\nvar $3rnpU = parcelRequire(\"3rnpU\");\n\"use strict\";\nfunction $0b910441e6a331f2$export$9fb1ab94ee86ec60(uboElement, offsetToAdd) {\n    const rowSize = Math.max((0, $3rnpU.WGSL_TO_STD40_SIZE)[uboElement.data.type] / 16, 1);\n    const elementSize = uboElement.data.value.length / uboElement.data.size;\n    const remainder = (4 - elementSize % 4) % 4;\n    return `\n        v = uv.${uboElement.data.name};\n        offset += ${offsetToAdd};\n\n        arrayOffset = offset;\n\n        t = 0;\n\n        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)\n        {\n            for(var j = 0; j < ${elementSize}; j++)\n            {\n                data[arrayOffset++] = v[t++];\n            }\n            ${remainder !== 0 ? `arrayOffset += ${remainder};` : \"\"}\n        }\n    `;\n}\n\n});\n\n\n\nparcelRegister(\"fA05m\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlRenderTargetSystem\", () => $1d7943bd5288cddc$export$50389001704f1c6a);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $bFvcQ = parcelRequire(\"bFvcQ\");\n\nvar $4SXq9 = parcelRequire(\"4SXq9\");\n\"use strict\";\nclass $1d7943bd5288cddc$export$50389001704f1c6a extends (0, $bFvcQ.RenderTargetSystem) {\n    constructor(renderer){\n        super(renderer);\n        this.adaptor = new (0, $4SXq9.GlRenderTargetAdaptor)();\n        this.adaptor.init(renderer, this);\n    }\n}\n/** @ignore */ $1d7943bd5288cddc$export$50389001704f1c6a.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLSystem\n    ],\n    name: \"renderTarget\"\n};\n\n});\nparcelRegister(\"4SXq9\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlRenderTargetAdaptor\", () => $e6015aa5f23f298a$export$d4bf7cc1dbb946ef);\n\nvar $fM4Mk = parcelRequire(\"fM4Mk\");\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\nvar $8xl7d = parcelRequire(\"8xl7d\");\n\nvar $hFYOq = parcelRequire(\"hFYOq\");\n\nvar $8ycms = parcelRequire(\"8ycms\");\n\"use strict\";\nclass $e6015aa5f23f298a$export$d4bf7cc1dbb946ef {\n    constructor(){\n        this._clearColorCache = [\n            0,\n            0,\n            0,\n            0\n        ];\n        this._viewPortCache = new (0, $fM4Mk.Rectangle)();\n    }\n    init(renderer, renderTargetSystem) {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n        renderer.runners.contextChange.add(this);\n    }\n    contextChange() {\n        this._clearColorCache = [\n            0,\n            0,\n            0,\n            0\n        ];\n        this._viewPortCache = new (0, $fM4Mk.Rectangle)();\n    }\n    copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n        const renderTargetSystem = this._renderTargetSystem;\n        const renderer = this._renderer;\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);\n        const gl = renderer.gl;\n        this.finishRenderPass(sourceRenderSurfaceTexture);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n        renderer.texture.bind(destinationTexture, 0);\n        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, originDest.x, originDest.y, originSrc.x, originSrc.y, size.width, size.height);\n        return destinationTexture;\n    }\n    startRenderPass(renderTarget, clear = true, clearColor, viewport) {\n        const renderTargetSystem = this._renderTargetSystem;\n        const source = renderTarget.colorTexture;\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n        let viewPortY = viewport.y;\n        if (renderTarget.isRoot) viewPortY = source.pixelHeight - viewport.height;\n        renderTarget.colorTextures.forEach((texture)=>{\n            this._renderer.texture.unbind(texture);\n        });\n        const gl = this._renderer.gl;\n        gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);\n        const viewPortCache = this._viewPortCache;\n        if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {\n            viewPortCache.x = viewport.x;\n            viewPortCache.y = viewPortY;\n            viewPortCache.width = viewport.width;\n            viewPortCache.height = viewport.height;\n            gl.viewport(viewport.x, viewPortY, viewport.width, viewport.height);\n        }\n        if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth)) this._initStencil(gpuRenderTarget);\n        this.clear(renderTarget, clear, clearColor);\n    }\n    finishRenderPass(renderTarget) {\n        const renderTargetSystem = this._renderTargetSystem;\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n        if (!glRenderTarget.msaa) return;\n        const gl = this._renderer.gl;\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);\n        gl.blitFramebuffer(0, 0, glRenderTarget.width, glRenderTarget.height, 0, 0, glRenderTarget.width, glRenderTarget.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);\n    }\n    initGpuRenderTarget(renderTarget) {\n        const renderer = this._renderer;\n        const gl = renderer.gl;\n        const glRenderTarget = new (0, $8ycms.GlRenderTarget)();\n        if ((0, $8xl7d.CanvasSource).test(renderTarget.colorTexture.resource)) {\n            glRenderTarget.framebuffer = null;\n            return glRenderTarget;\n        }\n        this._initColor(renderTarget, glRenderTarget);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        return glRenderTarget;\n    }\n    clear(_renderTarget, clear, clearColor) {\n        if (!clear) return;\n        const renderTargetSystem = this._renderTargetSystem;\n        if (typeof clear === \"boolean\") clear = clear ? (0, $hFYOq.CLEAR).ALL : (0, $hFYOq.CLEAR).NONE;\n        const gl = this._renderer.gl;\n        if (clear & (0, $hFYOq.CLEAR).COLOR) {\n            clearColor ?? (clearColor = renderTargetSystem.defaultClearColor);\n            const clearColorCache = this._clearColorCache;\n            const clearColorArray = clearColor;\n            if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {\n                clearColorCache[0] = clearColorArray[0];\n                clearColorCache[1] = clearColorArray[1];\n                clearColorCache[2] = clearColorArray[2];\n                clearColorCache[3] = clearColorArray[3];\n                gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);\n            }\n        }\n        gl.clear(clear);\n    }\n    resizeGpuRenderTarget(renderTarget) {\n        if (renderTarget.isRoot) return;\n        const renderTargetSystem = this._renderTargetSystem;\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n        this._resizeColor(renderTarget, glRenderTarget);\n        if (renderTarget.stencil) this._resizeStencil(glRenderTarget);\n    }\n    _initColor(renderTarget, glRenderTarget) {\n        const renderer = this._renderer;\n        const gl = renderer.gl;\n        const resolveTargetFramebuffer = gl.createFramebuffer();\n        glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;\n        gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);\n        glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;\n        glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;\n        renderTarget.colorTextures.forEach((colorTexture, i)=>{\n            const source = colorTexture.source;\n            if (source.antialias) {\n                if (renderer.context.supports.msaa) glRenderTarget.msaa = true;\n                else (0, $hUCK4.warn)(\"[RenderTexture] Antialiasing on textures is not supported in WebGL1\");\n            }\n            renderer.texture.bindSource(source, 0);\n            const glSource = renderer.texture.getGlSource(source);\n            const glTexture = glSource.texture;\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, 3553, // texture.target,\n            glTexture, 0);\n        });\n        if (glRenderTarget.msaa) {\n            const viewFramebuffer = gl.createFramebuffer();\n            glRenderTarget.framebuffer = viewFramebuffer;\n            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n            renderTarget.colorTextures.forEach((_, i)=>{\n                const msaaRenderBuffer = gl.createRenderbuffer();\n                glRenderTarget.msaaRenderBuffer[i] = msaaRenderBuffer;\n            });\n        } else glRenderTarget.framebuffer = resolveTargetFramebuffer;\n        this._resizeColor(renderTarget, glRenderTarget);\n    }\n    _resizeColor(renderTarget, glRenderTarget) {\n        const source = renderTarget.colorTexture.source;\n        glRenderTarget.width = source.pixelWidth;\n        glRenderTarget.height = source.pixelHeight;\n        renderTarget.colorTextures.forEach((colorTexture, i)=>{\n            if (i === 0) return;\n            colorTexture.source.resize(source.width, source.height, source._resolution);\n        });\n        if (glRenderTarget.msaa) {\n            const renderer = this._renderer;\n            const gl = renderer.gl;\n            const viewFramebuffer = glRenderTarget.framebuffer;\n            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n            renderTarget.colorTextures.forEach((colorTexture, i)=>{\n                const source2 = colorTexture.source;\n                renderer.texture.bindSource(source2, 0);\n                const glSource = renderer.texture.getGlSource(source2);\n                const glInternalFormat = glSource.internalFormat;\n                const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i];\n                gl.bindRenderbuffer(gl.RENDERBUFFER, msaaRenderBuffer);\n                gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 4, glInternalFormat, source2.pixelWidth, source2.pixelHeight);\n                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderBuffer);\n            });\n        }\n    }\n    _initStencil(glRenderTarget) {\n        if (glRenderTarget.framebuffer === null) return;\n        const gl = this._renderer.gl;\n        const depthStencilRenderBuffer = gl.createRenderbuffer();\n        glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;\n        gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilRenderBuffer);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilRenderBuffer);\n        this._resizeStencil(glRenderTarget);\n    }\n    _resizeStencil(glRenderTarget) {\n        const gl = this._renderer.gl;\n        gl.bindRenderbuffer(gl.RENDERBUFFER, glRenderTarget.depthStencilRenderBuffer);\n        if (glRenderTarget.msaa) gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 4, gl.DEPTH24_STENCIL8, glRenderTarget.width, glRenderTarget.height);\n        else gl.renderbufferStorage(gl.RENDERBUFFER, this._renderer.context.webGLVersion === 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL, glRenderTarget.width, glRenderTarget.height);\n    }\n}\n\n});\nparcelRegister(\"8ycms\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlRenderTarget\", () => $ad6c4732043c63de$export$849d02ac5943b5e7);\n\"use strict\";\nclass $ad6c4732043c63de$export$849d02ac5943b5e7 {\n    constructor(){\n        this.width = -1;\n        this.height = -1;\n        this.msaa = false;\n        this.msaaRenderBuffer = [];\n    }\n}\n\n});\n\n\n\nparcelRegister(\"2Z5qq\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlShaderSystem\", () => $f5d8d0596bd9ab8d$export$54fed9180ab691e4);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $43KdE = parcelRequire(\"43KdE\");\n\nvar $9sZUg = parcelRequire(\"9sZUg\");\n\"use strict\";\nconst $f5d8d0596bd9ab8d$var$defaultSyncData = {\n    textureCount: 0,\n    blockIndex: 0\n};\nclass $f5d8d0596bd9ab8d$export$54fed9180ab691e4 {\n    constructor(renderer){\n        /**\n     * @internal\n     * @private\n     */ this._activeProgram = null;\n        this._programDataHash = /* @__PURE__ */ Object.create(null);\n        this._nextIndex = 0;\n        this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null);\n        this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null);\n        this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);\n        this._renderer = renderer;\n    }\n    contextChange(gl) {\n        this._gl = gl;\n        this._maxBindings = gl.MAX_UNIFORM_BUFFER_BINDINGS ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;\n        this._programDataHash = /* @__PURE__ */ Object.create(null);\n        this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null);\n        this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null);\n        this._activeProgram = null;\n    }\n    /**\n   * Changes the current shader to the one given in parameter.\n   * @param shader - the new shader\n   * @param skipSync - false if the shader should automatically sync its uniforms.\n   * @returns the glProgram that belongs to the shader.\n   */ bind(shader, skipSync) {\n        this._setProgram(shader.glProgram);\n        if (skipSync) return;\n        $f5d8d0596bd9ab8d$var$defaultSyncData.textureCount = 0;\n        $f5d8d0596bd9ab8d$var$defaultSyncData.blockIndex = 0;\n        let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];\n        if (!syncFunction) syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);\n        syncFunction(this._renderer, shader, $f5d8d0596bd9ab8d$var$defaultSyncData);\n    }\n    /**\n   * Updates the uniform group.\n   * @param uniformGroup - the uniform group to update\n   */ updateUniformGroup(uniformGroup) {\n        this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, $f5d8d0596bd9ab8d$var$defaultSyncData);\n    }\n    /**\n   * Binds a uniform block to the shader.\n   * @param uniformGroup - the uniform group to bind\n   * @param name - the name of the uniform block\n   * @param index - the index of the uniform block\n   */ bindUniformBlock(uniformGroup, name, index = 0) {\n        const bufferSystem = this._renderer.buffer;\n        const programData = this._getProgramData(this._activeProgram);\n        const isBufferResource = uniformGroup._bufferResource;\n        if (isBufferResource) this._renderer.ubo.updateUniformGroup(uniformGroup);\n        bufferSystem.updateBuffer(uniformGroup.buffer);\n        let boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid];\n        if (boundIndex === void 0) {\n            const nextIndex = this._nextIndex++ % this._maxBindings;\n            const currentBoundUniformGroup = this._boundIndexToUniformsHash[nextIndex];\n            if (currentBoundUniformGroup) this._boundUniformsIdsToIndexHash[currentBoundUniformGroup.uid] = void 0;\n            boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid] = nextIndex;\n            this._boundIndexToUniformsHash[nextIndex] = uniformGroup;\n            if (isBufferResource) bufferSystem.bindBufferRange(uniformGroup.buffer, nextIndex, uniformGroup.offset);\n            else bufferSystem.bindBufferBase(uniformGroup.buffer, nextIndex);\n        }\n        const gl = this._gl;\n        const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;\n        if (programData.uniformBlockBindings[index] === boundIndex) return;\n        programData.uniformBlockBindings[index] = boundIndex;\n        gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundIndex);\n    }\n    _setProgram(program) {\n        if (this._activeProgram === program) return;\n        this._activeProgram = program;\n        const programData = this._getProgramData(program);\n        this._gl.useProgram(programData.program);\n    }\n    /**\n   * @param program - the program to get the data for\n   * @internal\n   * @private\n   */ _getProgramData(program) {\n        return this._programDataHash[program._key] || this._createProgramData(program);\n    }\n    _createProgramData(program) {\n        const key = program._key;\n        this._programDataHash[key] = (0, $9sZUg.generateProgram)(this._gl, program);\n        return this._programDataHash[key];\n    }\n    destroy() {\n        for (const key of Object.keys(this._programDataHash)){\n            const programData = this._programDataHash[key];\n            programData.destroy();\n            this._programDataHash[key] = null;\n        }\n        this._programDataHash = null;\n        this._boundUniformsIdsToIndexHash = null;\n    }\n    /**\n   * Creates a function that can be executed that will sync the shader as efficiently as possible.\n   * Overridden by the unsafe eval package if you don't want eval used in your project.\n   * @param shader - the shader to generate the sync function for\n   * @param shaderSystem - the shader system to use\n   * @returns - the generated sync function\n   * @ignore\n   */ _generateShaderSync(shader, shaderSystem) {\n        return (0, $43KdE.generateShaderSyncCode)(shader, shaderSystem);\n    }\n}\n/** @ignore */ $f5d8d0596bd9ab8d$export$54fed9180ab691e4.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLSystem\n    ],\n    name: \"shader\"\n};\n\n});\nparcelRegister(\"43KdE\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateShaderSyncCode\", () => $24ae4fd4bd77e301$export$7b73f9835f0afdab);\n\nvar $1bR8i = parcelRequire(\"1bR8i\");\n\nvar $cryyq = parcelRequire(\"cryyq\");\n\nvar $iA5fe = parcelRequire(\"iA5fe\");\n\"use strict\";\nfunction $24ae4fd4bd77e301$export$7b73f9835f0afdab(shader, shaderSystem) {\n    const funcFragments = [];\n    const headerFragments = [\n        `\n        var g = s.groups;\n        var sS = r.shader;\n        var p = s.glProgram;\n        var ugS = r.uniformGroup;\n        var resources;\n    `\n    ];\n    let addedTextreSystem = false;\n    let blockIndex = 0;\n    let textureCount = 0;\n    const programData = shaderSystem._getProgramData(shader.glProgram);\n    for(const i in shader.groups){\n        const group = shader.groups[i];\n        funcFragments.push(`\n            resources = g[${i}].resources;\n        `);\n        for(const j in group.resources){\n            const resource = group.resources[j];\n            if (resource instanceof (0, $cryyq.UniformGroup)) {\n                if (resource.ubo) funcFragments.push(`\n                        sS.bindUniformBlock(\n                            resources[${j}],\n                            sS._uniformBindMap[${i}[${j}],\n                            ${blockIndex++}\n                        );\n                    `);\n                else funcFragments.push(`\n                        ugS.updateUniformGroup(resources[${j}], p, sD);\n                    `);\n            } else if (resource instanceof (0, $1bR8i.BufferResource)) funcFragments.push(`\n                    sS.bindUniformBlock(\n                        resources[${j}],\n                        sS._uniformBindMap[${i}[${j}],\n                        ${blockIndex++}\n                    );\n                `);\n            else if (resource instanceof (0, $iA5fe.TextureSource)) {\n                const uniformName = shader._uniformBindMap[i][j];\n                const uniformData = programData.uniformData[uniformName];\n                if (uniformData) {\n                    if (!addedTextreSystem) {\n                        addedTextreSystem = true;\n                        headerFragments.push(`\n                        var tS = r.texture;\n                        `);\n                    }\n                    shaderSystem._gl.uniform1i(uniformData.location, textureCount);\n                    funcFragments.push(`\n                        tS.bind(resources[${j}], ${textureCount});\n                    `);\n                    textureCount++;\n                }\n            }\n        }\n    }\n    const functionSource = [\n        ...headerFragments,\n        ...funcFragments\n    ].join(\"\\n\");\n    return new Function(\"r\", \"s\", \"sD\", functionSource);\n}\n\n});\n\nparcelRegister(\"9sZUg\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateProgram\", () => $7613641dd99f08d4$export$44c84e8c8e54bce9);\n\nvar $hUCK4 = parcelRequire(\"hUCK4\");\n\nvar $8yo5i = parcelRequire(\"8yo5i\");\n\nvar $4bZHP = parcelRequire(\"4bZHP\");\n\nvar $7W2e3 = parcelRequire(\"7W2e3\");\n\nvar $kel5F = parcelRequire(\"kel5F\");\n\nvar $b6HNS = parcelRequire(\"b6HNS\");\n\nvar $3yIvZ = parcelRequire(\"3yIvZ\");\n\nvar $2nhJs = parcelRequire(\"2nhJs\");\n\"use strict\";\nfunction $7613641dd99f08d4$export$44c84e8c8e54bce9(gl, program) {\n    const glVertShader = (0, $4bZHP.compileShader)(gl, gl.VERTEX_SHADER, program.vertex);\n    const glFragShader = (0, $4bZHP.compileShader)(gl, gl.FRAGMENT_SHADER, program.fragment);\n    const webGLProgram = gl.createProgram();\n    gl.attachShader(webGLProgram, glVertShader);\n    gl.attachShader(webGLProgram, glFragShader);\n    const transformFeedbackVaryings = program.transformFeedbackVaryings;\n    if (transformFeedbackVaryings) {\n        if (typeof gl.transformFeedbackVaryings !== \"function\") (0, $hUCK4.warn)(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);\n        else gl.transformFeedbackVaryings(webGLProgram, transformFeedbackVaryings.names, transformFeedbackVaryings.bufferMode === \"separate\" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS);\n    }\n    gl.linkProgram(webGLProgram);\n    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) (0, $2nhJs.logProgramError)(gl, webGLProgram, glVertShader, glFragShader);\n    program._attributeData = (0, $kel5F.extractAttributesFromGlProgram)(webGLProgram, gl, !/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m.test(program.vertex));\n    program._uniformData = (0, $3yIvZ.getUniformData)(webGLProgram, gl);\n    program._uniformBlockData = (0, $b6HNS.getUboData)(webGLProgram, gl);\n    gl.deleteShader(glVertShader);\n    gl.deleteShader(glFragShader);\n    const uniformData = {};\n    for(const i in program._uniformData){\n        const data = program._uniformData[i];\n        uniformData[i] = {\n            location: gl.getUniformLocation(webGLProgram, i),\n            value: (0, $7W2e3.defaultValue)(data.type, data.size)\n        };\n    }\n    const glProgram = new (0, $8yo5i.GlProgramData)(webGLProgram, uniformData);\n    return glProgram;\n}\n\n});\nparcelRegister(\"8yo5i\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlProgramData\", () => $390445385c240c74$export$ed24f21e055efd10);\n\"use strict\";\nclass $390445385c240c74$export$181be621ce68aec5 {\n}\nclass $390445385c240c74$export$ed24f21e055efd10 {\n    /**\n   * Makes a new Pixi program.\n   * @param program - webgl program\n   * @param uniformData - uniforms\n   */ constructor(program, uniformData){\n        this.program = program;\n        this.uniformData = uniformData;\n        this.uniformGroups = {};\n        this.uniformDirtyGroups = {};\n        this.uniformBlockBindings = {};\n    }\n    /** Destroys this program. */ destroy() {\n        this.uniformData = null;\n        this.uniformGroups = null;\n        this.uniformDirtyGroups = null;\n        this.uniformBlockBindings = null;\n        this.program = null;\n    }\n}\n\n});\n\nparcelRegister(\"4bZHP\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileShader\", () => $e23060614d4157a3$export$9b5304f4eb007cf0);\n\"use strict\";\nfunction $e23060614d4157a3$export$9b5304f4eb007cf0(gl, type, src) {\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, src);\n    gl.compileShader(shader);\n    return shader;\n}\n\n});\n\nparcelRegister(\"7W2e3\", function(module, exports) {\n\n$parcel$export(module.exports, \"defaultValue\", () => $bc6ac37af3d2844a$export$1a01ae0705bafd37);\n\"use strict\";\nfunction $bc6ac37af3d2844a$var$booleanArray(size) {\n    const array = new Array(size);\n    for(let i = 0; i < array.length; i++)array[i] = false;\n    return array;\n}\nfunction $bc6ac37af3d2844a$export$1a01ae0705bafd37(type, size) {\n    switch(type){\n        case \"float\":\n            return 0;\n        case \"vec2\":\n            return new Float32Array(2 * size);\n        case \"vec3\":\n            return new Float32Array(3 * size);\n        case \"vec4\":\n            return new Float32Array(4 * size);\n        case \"int\":\n        case \"uint\":\n        case \"sampler2D\":\n        case \"sampler2DArray\":\n            return 0;\n        case \"ivec2\":\n            return new Int32Array(2 * size);\n        case \"ivec3\":\n            return new Int32Array(3 * size);\n        case \"ivec4\":\n            return new Int32Array(4 * size);\n        case \"uvec2\":\n            return new Uint32Array(2 * size);\n        case \"uvec3\":\n            return new Uint32Array(3 * size);\n        case \"uvec4\":\n            return new Uint32Array(4 * size);\n        case \"bool\":\n            return false;\n        case \"bvec2\":\n            return $bc6ac37af3d2844a$var$booleanArray(2 * size);\n        case \"bvec3\":\n            return $bc6ac37af3d2844a$var$booleanArray(3 * size);\n        case \"bvec4\":\n            return $bc6ac37af3d2844a$var$booleanArray(4 * size);\n        case \"mat2\":\n            return new Float32Array([\n                1,\n                0,\n                0,\n                1\n            ]);\n        case \"mat3\":\n            return new Float32Array([\n                1,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                1\n            ]);\n        case \"mat4\":\n            return new Float32Array([\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1\n            ]);\n    }\n    return null;\n}\n\n});\n\nparcelRegister(\"kel5F\", function(module, exports) {\n\n$parcel$export(module.exports, \"extractAttributesFromGlProgram\", () => $bf8df0b792dc2986$export$8c8c8d19aa26a952);\n\nvar $kavUV = parcelRequire(\"kavUV\");\n\nvar $gV2ls = parcelRequire(\"gV2ls\");\n\"use strict\";\nfunction $bf8df0b792dc2986$export$8c8c8d19aa26a952(program, gl, sortAttributes = false) {\n    const attributes = {};\n    const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n    for(let i = 0; i < totalAttributes; i++){\n        const attribData = gl.getActiveAttrib(program, i);\n        if (attribData.name.startsWith(\"gl_\")) continue;\n        const format = (0, $gV2ls.mapGlToVertexFormat)(gl, attribData.type);\n        attributes[attribData.name] = {\n            location: 0,\n            format: // set further down..\n            format,\n            stride: (0, $kavUV.getAttributeInfoFromFormat)(format).stride,\n            offset: 0,\n            instance: false,\n            start: 0\n        };\n    }\n    const keys = Object.keys(attributes);\n    if (sortAttributes) {\n        keys.sort((a, b)=>a > b ? 1 : -1);\n        for(let i = 0; i < keys.length; i++){\n            attributes[keys[i]].location = i;\n            gl.bindAttribLocation(program, i, keys[i]);\n        }\n        gl.linkProgram(program);\n    } else for(let i = 0; i < keys.length; i++)attributes[keys[i]].location = gl.getAttribLocation(program, keys[i]);\n    return attributes;\n}\n\n});\nparcelRegister(\"gV2ls\", function(module, exports) {\n\n$parcel$export(module.exports, \"mapType\", () => $1dddf959f73a7109$export$4de3a94418d86ca7);\n$parcel$export(module.exports, \"mapGlToVertexFormat\", () => $1dddf959f73a7109$export$7c31aa59606c890c);\n\"use strict\";\nlet $1dddf959f73a7109$var$GL_TABLE = null;\nconst $1dddf959f73a7109$var$GL_TO_GLSL_TYPES = {\n    FLOAT: \"float\",\n    FLOAT_VEC2: \"vec2\",\n    FLOAT_VEC3: \"vec3\",\n    FLOAT_VEC4: \"vec4\",\n    INT: \"int\",\n    INT_VEC2: \"ivec2\",\n    INT_VEC3: \"ivec3\",\n    INT_VEC4: \"ivec4\",\n    UNSIGNED_INT: \"uint\",\n    UNSIGNED_INT_VEC2: \"uvec2\",\n    UNSIGNED_INT_VEC3: \"uvec3\",\n    UNSIGNED_INT_VEC4: \"uvec4\",\n    BOOL: \"bool\",\n    BOOL_VEC2: \"bvec2\",\n    BOOL_VEC3: \"bvec3\",\n    BOOL_VEC4: \"bvec4\",\n    FLOAT_MAT2: \"mat2\",\n    FLOAT_MAT3: \"mat3\",\n    FLOAT_MAT4: \"mat4\",\n    SAMPLER_2D: \"sampler2D\",\n    INT_SAMPLER_2D: \"sampler2D\",\n    UNSIGNED_INT_SAMPLER_2D: \"sampler2D\",\n    SAMPLER_CUBE: \"samplerCube\",\n    INT_SAMPLER_CUBE: \"samplerCube\",\n    UNSIGNED_INT_SAMPLER_CUBE: \"samplerCube\",\n    SAMPLER_2D_ARRAY: \"sampler2DArray\",\n    INT_SAMPLER_2D_ARRAY: \"sampler2DArray\",\n    UNSIGNED_INT_SAMPLER_2D_ARRAY: \"sampler2DArray\"\n};\nconst $1dddf959f73a7109$var$GLSL_TO_VERTEX_TYPES = {\n    float: \"float32\",\n    vec2: \"float32x2\",\n    vec3: \"float32x3\",\n    vec4: \"float32x4\",\n    int: \"sint32\",\n    ivec2: \"sint32x2\",\n    ivec3: \"sint32x3\",\n    ivec4: \"sint32x4\",\n    uint: \"uint32\",\n    uvec2: \"uint32x2\",\n    uvec3: \"uint32x3\",\n    uvec4: \"uint32x4\",\n    bool: \"uint32\",\n    bvec2: \"uint32x2\",\n    bvec3: \"uint32x3\",\n    bvec4: \"uint32x4\"\n};\nfunction $1dddf959f73a7109$export$4de3a94418d86ca7(gl, type) {\n    if (!$1dddf959f73a7109$var$GL_TABLE) {\n        const typeNames = Object.keys($1dddf959f73a7109$var$GL_TO_GLSL_TYPES);\n        $1dddf959f73a7109$var$GL_TABLE = {};\n        for(let i = 0; i < typeNames.length; ++i){\n            const tn = typeNames[i];\n            $1dddf959f73a7109$var$GL_TABLE[gl[tn]] = $1dddf959f73a7109$var$GL_TO_GLSL_TYPES[tn];\n        }\n    }\n    return $1dddf959f73a7109$var$GL_TABLE[type];\n}\nfunction $1dddf959f73a7109$export$7c31aa59606c890c(gl, type) {\n    const typeValue = $1dddf959f73a7109$export$4de3a94418d86ca7(gl, type);\n    return $1dddf959f73a7109$var$GLSL_TO_VERTEX_TYPES[typeValue] || \"float32\";\n}\n\n});\n\n\nparcelRegister(\"b6HNS\", function(module, exports) {\n\n$parcel$export(module.exports, \"getUboData\", () => $e65c359389111496$export$452e938e127b3a20);\n\"use strict\";\nfunction $e65c359389111496$export$452e938e127b3a20(program, gl) {\n    if (!gl.ACTIVE_UNIFORM_BLOCKS) return {};\n    const uniformBlocks = {};\n    const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);\n    for(let i = 0; i < totalUniformsBlocks; i++){\n        const name = gl.getActiveUniformBlockName(program, i);\n        const uniformBlockIndex = gl.getUniformBlockIndex(program, name);\n        const size = gl.getActiveUniformBlockParameter(program, i, gl.UNIFORM_BLOCK_DATA_SIZE);\n        uniformBlocks[name] = {\n            name: name,\n            index: uniformBlockIndex,\n            size: size\n        };\n    }\n    return uniformBlocks;\n}\n\n});\n\nparcelRegister(\"3yIvZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"getUniformData\", () => $e8f2b0a1c1a069e8$export$d38fd6033d9429a5);\n\nvar $7W2e3 = parcelRequire(\"7W2e3\");\n\nvar $gV2ls = parcelRequire(\"gV2ls\");\n\"use strict\";\nfunction $e8f2b0a1c1a069e8$export$d38fd6033d9429a5(program, gl) {\n    const uniforms = {};\n    const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n    for(let i = 0; i < totalUniforms; i++){\n        const uniformData = gl.getActiveUniform(program, i);\n        const name = uniformData.name.replace(/\\[.*?\\]$/, \"\");\n        const isArray = !!uniformData.name.match(/\\[.*?\\]$/);\n        const type = (0, $gV2ls.mapType)(gl, uniformData.type);\n        uniforms[name] = {\n            name: name,\n            index: i,\n            type: type,\n            size: uniformData.size,\n            isArray: isArray,\n            value: (0, $7W2e3.defaultValue)(type, uniformData.size)\n        };\n    }\n    return uniforms;\n}\n\n});\n\nparcelRegister(\"2nhJs\", function(module, exports) {\n\n$parcel$export(module.exports, \"logProgramError\", () => $8579711571469dc1$export$4b35d6c62dc992b0);\n\"use strict\";\nfunction $8579711571469dc1$var$logPrettyShaderError(gl, shader) {\n    const shaderSrc = gl.getShaderSource(shader).split(\"\\n\").map((line, index)=>`${index}: ${line}`);\n    const shaderLog = gl.getShaderInfoLog(shader);\n    const splitShader = shaderLog.split(\"\\n\");\n    const dedupe = {};\n    const lineNumbers = splitShader.map((line)=>parseFloat(line.replace(/^ERROR\\: 0\\:([\\d]+)\\:.*$/, \"$1\"))).filter((n)=>{\n        if (n && !dedupe[n]) {\n            dedupe[n] = true;\n            return true;\n        }\n        return false;\n    });\n    const logArgs = [\n        \"\"\n    ];\n    lineNumbers.forEach((number)=>{\n        shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;\n        logArgs.push(\"background: #FF0000; color:#FFFFFF; font-size: 10px\", \"font-size: 10px\");\n    });\n    const fragmentSourceToLog = shaderSrc.join(\"\\n\");\n    logArgs[0] = fragmentSourceToLog;\n    console.error(shaderLog);\n    console.groupCollapsed(\"click to view full shader code\");\n    console.warn(...logArgs);\n    console.groupEnd();\n}\nfunction $8579711571469dc1$export$4b35d6c62dc992b0(gl, program, vertexShader, fragmentShader) {\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) $8579711571469dc1$var$logPrettyShaderError(gl, vertexShader);\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) $8579711571469dc1$var$logPrettyShaderError(gl, fragmentShader);\n        console.error(\"PixiJS Error: Could not initialize shader.\");\n        if (gl.getProgramInfoLog(program) !== \"\") console.warn(\"PixiJS Warning: gl.getProgramInfoLog()\", gl.getProgramInfoLog(program));\n    }\n}\n\n});\n\n\n\nparcelRegister(\"jS5sk\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlUniformGroupSystem\", () => $dd7a79aadc34ff0f$export$1dadd6b65a7ae71a);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $aUpHF = parcelRequire(\"aUpHF\");\n\"use strict\";\nclass $dd7a79aadc34ff0f$export$1dadd6b65a7ae71a {\n    /** @param renderer - The renderer this System works for. */ constructor(renderer){\n        /** Cache to holds the generated functions. Stored against UniformObjects unique signature. */ this._cache = {};\n        this._uniformGroupSyncHash = {};\n        this._renderer = renderer;\n        this.gl = null;\n        this._cache = {};\n    }\n    contextChange(gl) {\n        this.gl = gl;\n    }\n    /**\n   * Uploads the uniforms values to the currently bound shader.\n   * @param group - the uniforms values that be applied to the current shader\n   * @param program\n   * @param syncData\n   * @param syncData.textureCount\n   */ updateUniformGroup(group, program, syncData) {\n        const programData = this._renderer.shader._getProgramData(program);\n        if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid]) {\n            programData.uniformDirtyGroups[group.uid] = group._dirtyId;\n            const syncFunc = this._getUniformSyncFunction(group, program);\n            syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);\n        }\n    }\n    /**\n   * Overrideable by the pixi.js/unsafe-eval package to use static syncUniforms instead.\n   * @param group\n   * @param program\n   */ _getUniformSyncFunction(group, program) {\n        return this._uniformGroupSyncHash[group._signature]?.[program._key] || this._createUniformSyncFunction(group, program);\n    }\n    _createUniformSyncFunction(group, program) {\n        const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature] || (this._uniformGroupSyncHash[group._signature] = {});\n        const id = this._getSignature(group, program._uniformData, \"u\");\n        if (!this._cache[id]) this._cache[id] = this._generateUniformsSync(group, program._uniformData);\n        uniformGroupSyncHash[program._key] = this._cache[id];\n        return uniformGroupSyncHash[program._key];\n    }\n    _generateUniformsSync(group, uniformData) {\n        return (0, $aUpHF.generateUniformsSync)(group, uniformData);\n    }\n    /**\n   * Takes a uniform group and data and generates a unique signature for them.\n   * @param group - The uniform group to get signature of\n   * @param group.uniforms\n   * @param uniformData - Uniform information generated by the shader\n   * @param preFix\n   * @returns Unique signature of the uniform group\n   */ _getSignature(group, uniformData, preFix) {\n        const uniforms = group.uniforms;\n        const strings = [\n            `${preFix}-`\n        ];\n        for(const i in uniforms){\n            strings.push(i);\n            if (uniformData[i]) strings.push(uniformData[i].type);\n        }\n        return strings.join(\"-\");\n    }\n    /** Destroys this System and removes all its textures. */ destroy() {\n        this._renderer = null;\n        this._cache = null;\n    }\n}\n/** @ignore */ $dd7a79aadc34ff0f$export$1dadd6b65a7ae71a.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLSystem\n    ],\n    name: \"uniformGroup\"\n};\n\n});\nparcelRegister(\"aUpHF\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateUniformsSync\", () => $dc036dc5fcdd1552$export$20c95d1c2d5a6828);\n\nvar $1bR8i = parcelRequire(\"1bR8i\");\n\nvar $cryyq = parcelRequire(\"cryyq\");\n\nvar $4OFSF = parcelRequire(\"4OFSF\");\n\nvar $ckHs5 = parcelRequire(\"ckHs5\");\n\"use strict\";\nfunction $dc036dc5fcdd1552$export$20c95d1c2d5a6828(group, uniformData) {\n    const funcFragments = [\n        `\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n        var name = null;\n    `\n    ];\n    for(const i in group.uniforms){\n        if (!uniformData[i]) {\n            if (group.uniforms[i] instanceof (0, $cryyq.UniformGroup)) {\n                if (group.uniforms[i].ubo) funcFragments.push(`\n                        renderer.shader.bindUniformBlock(uv.${i}, \"${i}\");\n                    `);\n                else funcFragments.push(`\n                        renderer.shader.updateUniformGroup(uv.${i});\n                    `);\n            } else if (group.uniforms[i] instanceof (0, $1bR8i.BufferResource)) funcFragments.push(`\n                        renderer.shader.bindBufferResource(uv.${i}, \"${i}\");\n                    `);\n            continue;\n        }\n        const uniform = group.uniformStructures[i];\n        let parsed = false;\n        for(let j = 0; j < (0, $4OFSF.uniformParsers).length; j++){\n            const parser = (0, $4OFSF.uniformParsers)[j];\n            if (uniform.type === parser.type && parser.test(uniform)) {\n                funcFragments.push(`name = \"${i}\";`, (0, $4OFSF.uniformParsers)[j].uniform);\n                parsed = true;\n                break;\n            }\n        }\n        if (!parsed) {\n            const templateType = uniform.size === 1 ? (0, $ckHs5.UNIFORM_TO_SINGLE_SETTERS) : (0, $ckHs5.UNIFORM_TO_ARRAY_SETTERS);\n            const template = templateType[uniform.type].replace(\"location\", `ud[\"${i}\"].location`);\n            funcFragments.push(`\n            cu = ud[\"${i}\"];\n            cv = cu.value;\n            v = uv[\"${i}\"];\n            ${template};`);\n        }\n    }\n    return new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", funcFragments.join(\"\\n\"));\n}\n\n});\nparcelRegister(\"ckHs5\", function(module, exports) {\n\n$parcel$export(module.exports, \"UNIFORM_TO_SINGLE_SETTERS\", () => $a179197e5ce62d9d$export$2619e56ae9962898);\n$parcel$export(module.exports, \"UNIFORM_TO_ARRAY_SETTERS\", () => $a179197e5ce62d9d$export$ac1fb1a14f78b100);\n\"use strict\";\nconst $a179197e5ce62d9d$export$2619e56ae9962898 = {\n    f32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1f(location, v);\n        }`,\n    \"vec2<f32>\": `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2f(location, v[0], v[1]);\n        }`,\n    \"vec3<f32>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3f(location, v[0], v[1], v[2]);\n        }`,\n    \"vec4<f32>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n        }`,\n    i32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }`,\n    \"vec2<i32>\": `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }`,\n    \"vec3<i32>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }`,\n    \"vec4<i32>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }`,\n    u32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1ui(location, v);\n        }`,\n    \"vec2<u32>\": `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2ui(location, v[0], v[1]);\n        }`,\n    \"vec3<u32>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3ui(location, v[0], v[1], v[2]);\n        }`,\n    \"vec4<u32>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n        }`,\n    bool: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }`,\n    \"vec2<bool>\": `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }`,\n    \"vec3<bool>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }`,\n    \"vec4<bool>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }`,\n    \"mat2x2<f32>\": `gl.uniformMatrix2fv(location, false, v);`,\n    \"mat3x3<f32>\": `gl.uniformMatrix3fv(location, false, v);`,\n    \"mat4x4<f32>\": `gl.uniformMatrix4fv(location, false, v);`\n};\nconst $a179197e5ce62d9d$export$ac1fb1a14f78b100 = {\n    f32: `gl.uniform1fv(location, v);`,\n    \"vec2<f32>\": `gl.uniform2fv(location, v);`,\n    \"vec3<f32>\": `gl.uniform3fv(location, v);`,\n    \"vec4<f32>\": `gl.uniform4fv(location, v);`,\n    \"mat2x2<f32>\": `gl.uniformMatrix2fv(location, false, v);`,\n    \"mat3x3<f32>\": `gl.uniformMatrix3fv(location, false, v);`,\n    \"mat4x4<f32>\": `gl.uniformMatrix4fv(location, false, v);`,\n    i32: `gl.uniform1iv(location, v);`,\n    \"vec2<i32>\": `gl.uniform2iv(location, v);`,\n    \"vec3<i32>\": `gl.uniform3iv(location, v);`,\n    \"vec4<i32>\": `gl.uniform4iv(location, v);`,\n    u32: `gl.uniform1iv(location, v);`,\n    \"vec2<u32>\": `gl.uniform2iv(location, v);`,\n    \"vec3<u32>\": `gl.uniform3iv(location, v);`,\n    \"vec4<u32>\": `gl.uniform4iv(location, v);`,\n    bool: `gl.uniform1iv(location, v);`,\n    \"vec2<bool>\": `gl.uniform2iv(location, v);`,\n    \"vec3<bool>\": `gl.uniform3iv(location, v);`,\n    \"vec4<bool>\": `gl.uniform4iv(location, v);`\n};\n\n});\n\n\n\nparcelRegister(\"39wDe\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlStateSystem\", () => $724532dc015d0d7e$export$3ece59c346e5d37);\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $2Aebl = parcelRequire(\"2Aebl\");\n\nvar $hA4ZB = parcelRequire(\"hA4ZB\");\n\"use strict\";\nconst $724532dc015d0d7e$var$BLEND = 0;\nconst $724532dc015d0d7e$var$OFFSET = 1;\nconst $724532dc015d0d7e$var$CULLING = 2;\nconst $724532dc015d0d7e$var$DEPTH_TEST = 3;\nconst $724532dc015d0d7e$var$WINDING = 4;\nconst $724532dc015d0d7e$var$DEPTH_MASK = 5;\nconst $724532dc015d0d7e$var$_GlStateSystem = class _GlStateSystem {\n    constructor(){\n        this.gl = null;\n        this.stateId = 0;\n        this.polygonOffset = 0;\n        this.blendMode = \"none\";\n        this._blendEq = false;\n        this.map = [];\n        this.map[$724532dc015d0d7e$var$BLEND] = this.setBlend;\n        this.map[$724532dc015d0d7e$var$OFFSET] = this.setOffset;\n        this.map[$724532dc015d0d7e$var$CULLING] = this.setCullFace;\n        this.map[$724532dc015d0d7e$var$DEPTH_TEST] = this.setDepthTest;\n        this.map[$724532dc015d0d7e$var$WINDING] = this.setFrontFace;\n        this.map[$724532dc015d0d7e$var$DEPTH_MASK] = this.setDepthMask;\n        this.checks = [];\n        this.defaultState = (0, $2Aebl.State).for2d();\n    }\n    contextChange(gl) {\n        this.gl = gl;\n        this.blendModesMap = (0, $hA4ZB.mapWebGLBlendModesToPixi)(gl);\n        this.reset();\n    }\n    /**\n   * Sets the current state\n   * @param {*} state - The state to set.\n   */ set(state) {\n        state = state || this.defaultState;\n        if (this.stateId !== state.data) {\n            let diff = this.stateId ^ state.data;\n            let i = 0;\n            while(diff){\n                if (diff & 1) this.map[i].call(this, !!(state.data & 1 << i));\n                diff = diff >> 1;\n                i++;\n            }\n            this.stateId = state.data;\n        }\n        for(let i = 0; i < this.checks.length; i++)this.checks[i](this, state);\n    }\n    /**\n   * Sets the state, when previous state is unknown.\n   * @param {*} state - The state to set\n   */ forceState(state) {\n        state = state || this.defaultState;\n        for(let i = 0; i < this.map.length; i++)this.map[i].call(this, !!(state.data & 1 << i));\n        for(let i = 0; i < this.checks.length; i++)this.checks[i](this, state);\n        this.stateId = state.data;\n    }\n    /**\n   * Sets whether to enable or disable blending.\n   * @param value - Turn on or off WebGl blending.\n   */ setBlend(value) {\n        this._updateCheck(_GlStateSystem._checkBlendMode, value);\n        this.gl[value ? \"enable\" : \"disable\"](this.gl.BLEND);\n    }\n    /**\n   * Sets whether to enable or disable polygon offset fill.\n   * @param value - Turn on or off webgl polygon offset testing.\n   */ setOffset(value) {\n        this._updateCheck(_GlStateSystem._checkPolygonOffset, value);\n        this.gl[value ? \"enable\" : \"disable\"](this.gl.POLYGON_OFFSET_FILL);\n    }\n    /**\n   * Sets whether to enable or disable depth test.\n   * @param value - Turn on or off webgl depth testing.\n   */ setDepthTest(value) {\n        this.gl[value ? \"enable\" : \"disable\"](this.gl.DEPTH_TEST);\n    }\n    /**\n   * Sets whether to enable or disable depth mask.\n   * @param value - Turn on or off webgl depth mask.\n   */ setDepthMask(value) {\n        this.gl.depthMask(value);\n    }\n    /**\n   * Sets whether to enable or disable cull face.\n   * @param {boolean} value - Turn on or off webgl cull face.\n   */ setCullFace(value) {\n        this.gl[value ? \"enable\" : \"disable\"](this.gl.CULL_FACE);\n    }\n    /**\n   * Sets the gl front face.\n   * @param {boolean} value - true is clockwise and false is counter-clockwise\n   */ setFrontFace(value) {\n        this.gl.frontFace(this.gl[value ? \"CW\" : \"CCW\"]);\n    }\n    /**\n   * Sets the blend mode.\n   * @param {number} value - The blend mode to set to.\n   */ setBlendMode(value) {\n        if (!this.blendModesMap[value]) value = \"normal\";\n        if (value === this.blendMode) return;\n        this.blendMode = value;\n        const mode = this.blendModesMap[value];\n        const gl = this.gl;\n        if (mode.length === 2) gl.blendFunc(mode[0], mode[1]);\n        else gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);\n        if (mode.length === 6) {\n            this._blendEq = true;\n            gl.blendEquationSeparate(mode[4], mode[5]);\n        } else if (this._blendEq) {\n            this._blendEq = false;\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n        }\n    }\n    /**\n   * Sets the polygon offset.\n   * @param {number} value - the polygon offset\n   * @param {number} scale - the polygon offset scale\n   */ setPolygonOffset(value, scale) {\n        this.gl.polygonOffset(value, scale);\n    }\n    // used\n    /** Resets all the logic and disables the VAOs. */ reset() {\n        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);\n        this.forceState(this.defaultState);\n        this._blendEq = true;\n        this.blendMode = \"\";\n        this.setBlendMode(\"normal\");\n    }\n    /**\n   * Checks to see which updates should be checked based on which settings have been activated.\n   *\n   * For example, if blend is enabled then we should check the blend modes each time the state is changed\n   * or if polygon fill is activated then we need to check if the polygon offset changes.\n   * The idea is that we only check what we have too.\n   * @param func - the checking function to add or remove\n   * @param value - should the check function be added or removed.\n   */ _updateCheck(func, value) {\n        const index = this.checks.indexOf(func);\n        if (value && index === -1) this.checks.push(func);\n        else if (!value && index !== -1) this.checks.splice(index, 1);\n    }\n    /**\n   * A private little wrapper function that we call to check the blend mode.\n   * @param system - the System to perform the state check on\n   * @param state - the state that the blendMode will pulled from\n   */ static _checkBlendMode(system, state) {\n        system.setBlendMode(state.blendMode);\n    }\n    /**\n   * A private little wrapper function that we call to check the polygon offset.\n   * @param system - the System to perform the state check on\n   * @param state - the state that the blendMode will pulled from\n   */ static _checkPolygonOffset(system, state) {\n        system.setPolygonOffset(1, state.polygonOffset);\n    }\n    /**\n   * @ignore\n   */ destroy() {\n        this.gl = null;\n        this.checks.length = 0;\n    }\n};\n/** @ignore */ $724532dc015d0d7e$var$_GlStateSystem.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLSystem\n    ],\n    name: \"state\"\n};\nlet $724532dc015d0d7e$export$3ece59c346e5d37 = $724532dc015d0d7e$var$_GlStateSystem;\n\n});\nparcelRegister(\"hA4ZB\", function(module, exports) {\n\n$parcel$export(module.exports, \"mapWebGLBlendModesToPixi\", () => $aa2ebd1b48f322b1$export$57ed86928a8d2aa1);\n\"use strict\";\nfunction $aa2ebd1b48f322b1$export$57ed86928a8d2aa1(gl) {\n    const blendMap = {};\n    blendMap.normal = [\n        gl.ONE,\n        gl.ONE_MINUS_SRC_ALPHA\n    ];\n    blendMap.add = [\n        gl.ONE,\n        gl.ONE\n    ];\n    blendMap.multiply = [\n        gl.DST_COLOR,\n        gl.ONE_MINUS_SRC_ALPHA,\n        gl.ONE,\n        gl.ONE_MINUS_SRC_ALPHA\n    ];\n    blendMap.screen = [\n        gl.ONE,\n        gl.ONE_MINUS_SRC_COLOR,\n        gl.ONE,\n        gl.ONE_MINUS_SRC_ALPHA\n    ];\n    blendMap.none = [\n        0,\n        0\n    ];\n    blendMap[\"normal-npm\"] = [\n        gl.SRC_ALPHA,\n        gl.ONE_MINUS_SRC_ALPHA,\n        gl.ONE,\n        gl.ONE_MINUS_SRC_ALPHA\n    ];\n    blendMap[\"add-npm\"] = [\n        gl.SRC_ALPHA,\n        gl.ONE,\n        gl.ONE,\n        gl.ONE\n    ];\n    blendMap[\"screen-npm\"] = [\n        gl.SRC_ALPHA,\n        gl.ONE_MINUS_SRC_COLOR,\n        gl.ONE,\n        gl.ONE_MINUS_SRC_ALPHA\n    ];\n    blendMap.erase = [\n        gl.ZERO,\n        gl.ONE_MINUS_SRC_ALPHA\n    ];\n    return blendMap;\n}\n\n});\n\n\nparcelRegister(\"2WDu2\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlTextureSystem\", () => $16148d8c3c382afd$export$a4a6f67fda81946a);\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\nvar $i9BKe = parcelRequire(\"i9BKe\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\nvar $8V3H6 = parcelRequire(\"8V3H6\");\n\nvar $7HHTi = parcelRequire(\"7HHTi\");\n\nvar $e2J15 = parcelRequire(\"e2J15\");\n\nvar $4DDYK = parcelRequire(\"4DDYK\");\n\nvar $gHIBu = parcelRequire(\"gHIBu\");\n\nvar $4JQmo = parcelRequire(\"4JQmo\");\n\nvar $6mS9o = parcelRequire(\"6mS9o\");\n\nvar $l9Yyl = parcelRequire(\"l9Yyl\");\n\nvar $lkFWs = parcelRequire(\"lkFWs\");\n\n\"use strict\";\nconst $16148d8c3c382afd$var$BYTES_PER_PIXEL = 4;\nclass $16148d8c3c382afd$export$a4a6f67fda81946a {\n    constructor(renderer){\n        this.managedTextures = [];\n        this._glTextures = /* @__PURE__ */ Object.create(null);\n        this._glSamplers = /* @__PURE__ */ Object.create(null);\n        this._boundTextures = [];\n        this._activeTextureLocation = -1;\n        this._boundSamplers = /* @__PURE__ */ Object.create(null);\n        this._uploads = {\n            image: (0, $4DDYK.glUploadImageResource),\n            buffer: (0, $7HHTi.glUploadBufferImageResource),\n            video: (0, $gHIBu.glUploadVideoResource),\n            compressed: (0, $e2J15.glUploadCompressedTextureResource)\n        };\n        // TODO - separate samplers will be a cool thing to add, but not right now!\n        this._useSeparateSamplers = false;\n        this._renderer = renderer;\n    }\n    contextChange(gl) {\n        this._gl = gl;\n        if (!this._mapFormatToInternalFormat) {\n            this._mapFormatToInternalFormat = (0, $l9Yyl.mapFormatToGlInternalFormat)(gl, this._renderer.context.extensions);\n            this._mapFormatToType = (0, $lkFWs.mapFormatToGlType)(gl);\n            this._mapFormatToFormat = (0, $6mS9o.mapFormatToGlFormat)(gl);\n        }\n        this._glTextures = /* @__PURE__ */ Object.create(null);\n        this._glSamplers = /* @__PURE__ */ Object.create(null);\n        this._boundSamplers = /* @__PURE__ */ Object.create(null);\n        for(let i = 0; i < 16; i++)this.bind((0, $bLlTJ.Texture).EMPTY, i);\n    }\n    initSource(source) {\n        this.bind(source);\n    }\n    bind(texture, location = 0) {\n        const source = texture.source;\n        if (texture) {\n            this.bindSource(source, location);\n            if (this._useSeparateSamplers) this._bindSampler(source.style, location);\n        } else {\n            this.bindSource(null, location);\n            if (this._useSeparateSamplers) this._bindSampler(null, location);\n        }\n    }\n    bindSource(source, location = 0) {\n        const gl = this._gl;\n        source._touched = this._renderer.textureGC.count;\n        if (this._boundTextures[location] !== source) {\n            this._boundTextures[location] = source;\n            this._activateLocation(location);\n            source = source || (0, $bLlTJ.Texture).EMPTY.source;\n            const glTexture = this.getGlSource(source);\n            gl.bindTexture(glTexture.target, glTexture.texture);\n        }\n    }\n    _bindSampler(style, location = 0) {\n        const gl = this._gl;\n        if (!style) {\n            this._boundSamplers[location] = null;\n            gl.bindSampler(location, null);\n            return;\n        }\n        const sampler = this._getGlSampler(style);\n        if (this._boundSamplers[location] !== sampler) {\n            this._boundSamplers[location] = sampler;\n            gl.bindSampler(location, sampler);\n        }\n    }\n    unbind(texture) {\n        const source = texture.source;\n        const boundTextures = this._boundTextures;\n        const gl = this._gl;\n        for(let i = 0; i < boundTextures.length; i++)if (boundTextures[i] === source) {\n            this._activateLocation(i);\n            const glTexture = this.getGlSource(source);\n            gl.bindTexture(glTexture.target, null);\n            boundTextures[i] = null;\n        }\n    }\n    _activateLocation(location) {\n        if (this._activeTextureLocation !== location) {\n            this._activeTextureLocation = location;\n            this._gl.activeTexture(this._gl.TEXTURE0 + location);\n        }\n    }\n    _initSource(source) {\n        const gl = this._gl;\n        const glTexture = new (0, $8V3H6.GlTexture)(gl.createTexture());\n        glTexture.type = this._mapFormatToType[source.format];\n        glTexture.internalFormat = this._mapFormatToInternalFormat[source.format];\n        glTexture.format = this._mapFormatToFormat[source.format];\n        if (source.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source.isPowerOfTwo)) {\n            const biggestDimension = Math.max(source.width, source.height);\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n        this._glTextures[source.uid] = glTexture;\n        if (!this.managedTextures.includes(source)) {\n            source.on(\"update\", this.onSourceUpdate, this);\n            source.on(\"resize\", this.onSourceUpdate, this);\n            source.on(\"styleChange\", this.onStyleChange, this);\n            source.on(\"destroy\", this.onSourceDestroy, this);\n            source.on(\"unload\", this.onSourceUnload, this);\n            source.on(\"updateMipmaps\", this.onUpdateMipmaps, this);\n            this.managedTextures.push(source);\n        }\n        this.onSourceUpdate(source);\n        this.updateStyle(source, false);\n        return glTexture;\n    }\n    onStyleChange(source) {\n        this.updateStyle(source, false);\n    }\n    updateStyle(source, firstCreation) {\n        const gl = this._gl;\n        const glTexture = this.getGlSource(source);\n        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n        this._boundTextures[this._activeTextureLocation] = source;\n        (0, $4JQmo.applyStyleParams)(source.style, gl, source.mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, \"texParameteri\", gl.TEXTURE_2D, // will force a clamp to edge if the texture is not a power of two\n        !this._renderer.context.supports.nonPowOf2wrapping && !source.isPowerOfTwo, firstCreation);\n    }\n    onSourceUnload(source) {\n        const glTexture = this._glTextures[source.uid];\n        if (!glTexture) return;\n        this.unbind(source);\n        this._glTextures[source.uid] = null;\n        this._gl.deleteTexture(glTexture.texture);\n    }\n    onSourceUpdate(source) {\n        const gl = this._gl;\n        const glTexture = this.getGlSource(source);\n        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n        this._boundTextures[this._activeTextureLocation] = source;\n        if (this._uploads[source.uploadMethodId]) this._uploads[source.uploadMethodId].upload(source, glTexture, gl, this._renderer.context.webGLVersion);\n        else gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.pixelWidth, source.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1) this.onUpdateMipmaps(source, false);\n    }\n    onUpdateMipmaps(source, bind = true) {\n        if (bind) this.bindSource(source, 0);\n        const glTexture = this.getGlSource(source);\n        this._gl.generateMipmap(glTexture.target);\n    }\n    onSourceDestroy(source) {\n        source.off(\"destroy\", this.onSourceDestroy, this);\n        source.off(\"update\", this.onSourceUpdate, this);\n        source.off(\"resize\", this.onSourceUpdate, this);\n        source.off(\"unload\", this.onSourceUnload, this);\n        source.off(\"styleChange\", this.onStyleChange, this);\n        source.off(\"updateMipmaps\", this.onUpdateMipmaps, this);\n        this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n        this.onSourceUnload(source);\n    }\n    _initSampler(style) {\n        const gl = this._gl;\n        const glSampler = this._gl.createSampler();\n        this._glSamplers[style._resourceId] = glSampler;\n        (0, $4JQmo.applyStyleParams)(style, gl, this._boundTextures[this._activeTextureLocation].mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, \"samplerParameteri\", glSampler, false, true);\n        return this._glSamplers[style._resourceId];\n    }\n    _getGlSampler(sampler) {\n        return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n    getGlSource(source) {\n        return this._glTextures[source.uid] || this._initSource(source);\n    }\n    generateCanvas(texture) {\n        const { pixels: pixels, width: width, height: height } = this.getPixels(texture);\n        const canvas = (0, $iCGeI.DOMAdapter).get().createCanvas();\n        canvas.width = width;\n        canvas.height = height;\n        const ctx = canvas.getContext(\"2d\");\n        if (ctx) {\n            const imageData = ctx.createImageData(width, height);\n            imageData.data.set(pixels);\n            ctx.putImageData(imageData, 0, 0);\n        }\n        return canvas;\n    }\n    getPixels(texture) {\n        const resolution = texture.source.resolution;\n        const frame = texture.frame;\n        const width = Math.max(Math.round(frame.width * resolution), 1);\n        const height = Math.max(Math.round(frame.height * resolution), 1);\n        const pixels = new Uint8Array($16148d8c3c382afd$var$BYTES_PER_PIXEL * width * height);\n        const renderer = this._renderer;\n        const renderTarget = renderer.renderTarget.getRenderTarget(texture);\n        const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);\n        const gl = renderer.gl;\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);\n        gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n        return {\n            pixels: new Uint8ClampedArray(pixels.buffer),\n            width: width,\n            height: height\n        };\n    }\n    destroy() {\n        this.managedTextures.slice().forEach((source)=>this.onSourceDestroy(source));\n        this.managedTextures = null;\n        this._renderer = null;\n    }\n}\n/** @ignore */ $16148d8c3c382afd$export$a4a6f67fda81946a.extension = {\n    type: [\n        (0, $i9BKe.ExtensionType).WebGLSystem\n    ],\n    name: \"texture\"\n};\n\n});\nparcelRegister(\"8V3H6\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlTexture\", () => $f9536c3ec3a863a1$export$77c65e0fc65f3a30);\n\nvar $9kjPM = parcelRequire(\"9kjPM\");\n\"use strict\";\nclass $f9536c3ec3a863a1$export$77c65e0fc65f3a30 {\n    constructor(texture){\n        this.target = (0, $9kjPM.GL_TARGETS).TEXTURE_2D;\n        this.texture = texture;\n        this.width = -1;\n        this.height = -1;\n        this.type = (0, $9kjPM.GL_TYPES).UNSIGNED_BYTE;\n        this.internalFormat = (0, $9kjPM.GL_FORMATS).RGBA;\n        this.format = (0, $9kjPM.GL_FORMATS).RGBA;\n        this.samplerType = 0;\n    }\n}\n\n});\n\nparcelRegister(\"7HHTi\", function(module, exports) {\n\n$parcel$export(module.exports, \"glUploadBufferImageResource\", () => $2d24f7c2359a60e1$export$aa4eec5aa64bfd28);\n\"use strict\";\nconst $2d24f7c2359a60e1$export$aa4eec5aa64bfd28 = {\n    id: \"image\",\n    upload (source, glTexture, gl) {\n        if (glTexture.width === source.width || glTexture.height === source.height) gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, glTexture.format, glTexture.type, source.resource);\n        else gl.texImage2D(glTexture.target, 0, glTexture.internalFormat, source.width, source.height, 0, glTexture.format, glTexture.type, source.resource);\n        glTexture.width = source.width;\n        glTexture.height = source.height;\n    }\n};\n\n});\n\nparcelRegister(\"e2J15\", function(module, exports) {\n\n$parcel$export(module.exports, \"glUploadCompressedTextureResource\", () => $9ef5b33d36b4d06b$export$97d1715760cee374);\n\"use strict\";\nconst $9ef5b33d36b4d06b$var$compressedFormatMap = {\n    \"bc1-rgba-unorm\": true,\n    \"bc1-rgba-unorm-srgb\": true,\n    \"bc2-rgba-unorm\": true,\n    \"bc2-rgba-unorm-srgb\": true,\n    \"bc3-rgba-unorm\": true,\n    \"bc3-rgba-unorm-srgb\": true,\n    \"bc4-r-unorm\": true,\n    \"bc4-r-snorm\": true,\n    \"bc5-rg-unorm\": true,\n    \"bc5-rg-snorm\": true,\n    \"bc6h-rgb-ufloat\": true,\n    \"bc6h-rgb-float\": true,\n    \"bc7-rgba-unorm\": true,\n    \"bc7-rgba-unorm-srgb\": true,\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    \"etc2-rgb8unorm\": true,\n    \"etc2-rgb8unorm-srgb\": true,\n    \"etc2-rgb8a1unorm\": true,\n    \"etc2-rgb8a1unorm-srgb\": true,\n    \"etc2-rgba8unorm\": true,\n    \"etc2-rgba8unorm-srgb\": true,\n    \"eac-r11unorm\": true,\n    \"eac-r11snorm\": true,\n    \"eac-rg11unorm\": true,\n    \"eac-rg11snorm\": true,\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    \"astc-4x4-unorm\": true,\n    \"astc-4x4-unorm-srgb\": true,\n    \"astc-5x4-unorm\": true,\n    \"astc-5x4-unorm-srgb\": true,\n    \"astc-5x5-unorm\": true,\n    \"astc-5x5-unorm-srgb\": true,\n    \"astc-6x5-unorm\": true,\n    \"astc-6x5-unorm-srgb\": true,\n    \"astc-6x6-unorm\": true,\n    \"astc-6x6-unorm-srgb\": true,\n    \"astc-8x5-unorm\": true,\n    \"astc-8x5-unorm-srgb\": true,\n    \"astc-8x6-unorm\": true,\n    \"astc-8x6-unorm-srgb\": true,\n    \"astc-8x8-unorm\": true,\n    \"astc-8x8-unorm-srgb\": true,\n    \"astc-10x5-unorm\": true,\n    \"astc-10x5-unorm-srgb\": true,\n    \"astc-10x6-unorm\": true,\n    \"astc-10x6-unorm-srgb\": true,\n    \"astc-10x8-unorm\": true,\n    \"astc-10x8-unorm-srgb\": true,\n    \"astc-10x10-unorm\": true,\n    \"astc-10x10-unorm-srgb\": true,\n    \"astc-12x10-unorm\": true,\n    \"astc-12x10-unorm-srgb\": true,\n    \"astc-12x12-unorm\": true,\n    \"astc-12x12-unorm-srgb\": true\n};\nconst $9ef5b33d36b4d06b$export$97d1715760cee374 = {\n    id: \"compressed\",\n    upload (source, glTexture, gl) {\n        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n        let mipWidth = source.pixelWidth;\n        let mipHeight = source.pixelHeight;\n        const compressed = !!$9ef5b33d36b4d06b$var$compressedFormatMap[source.format];\n        for(let i = 0; i < source.resource.length; i++){\n            const levelBuffer = source.resource[i];\n            if (compressed) gl.compressedTexImage2D(gl.TEXTURE_2D, i, glTexture.internalFormat, mipWidth, mipHeight, 0, levelBuffer);\n            else gl.texImage2D(gl.TEXTURE_2D, i, glTexture.internalFormat, mipWidth, mipHeight, 0, glTexture.format, glTexture.type, levelBuffer);\n            mipWidth = Math.max(mipWidth >> 1, 1);\n            mipHeight = Math.max(mipHeight >> 1, 1);\n        }\n    }\n};\n\n});\n\nparcelRegister(\"4DDYK\", function(module, exports) {\n\n$parcel$export(module.exports, \"glUploadImageResource\", () => $52029e2e17d70473$export$3cfb43b040bc4df8);\n\"use strict\";\nconst $52029e2e17d70473$export$3cfb43b040bc4df8 = {\n    id: \"image\",\n    upload (source, glTexture, gl, webGLVersion) {\n        const premultipliedAlpha = source.alphaMode === \"premultiply-alpha-on-upload\";\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);\n        const glWidth = glTexture.width;\n        const glHeight = glTexture.height;\n        const textureWidth = source.pixelWidth;\n        const textureHeight = source.pixelHeight;\n        const resourceWidth = source.resourceWidth;\n        const resourceHeight = source.resourceHeight;\n        if (resourceWidth < textureWidth || resourceHeight < textureHeight) {\n            if (glWidth !== textureWidth || glHeight !== textureHeight) gl.texImage2D(glTexture.target, 0, glTexture.internalFormat, textureWidth, textureHeight, 0, glTexture.format, glTexture.type, null);\n            if (webGLVersion === 2) gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, resourceWidth, resourceHeight, glTexture.format, glTexture.type, source.resource);\n            else gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, glTexture.format, glTexture.type, source.resource);\n        } else if (glWidth === textureWidth || glHeight === textureHeight) gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, glTexture.format, glTexture.type, source.resource);\n        else if (webGLVersion === 2) gl.texImage2D(glTexture.target, 0, glTexture.internalFormat, textureWidth, textureHeight, 0, glTexture.format, glTexture.type, source.resource);\n        else gl.texImage2D(glTexture.target, 0, glTexture.internalFormat, glTexture.format, glTexture.type, source.resource);\n        glTexture.width = textureWidth;\n        glTexture.height = textureHeight;\n    }\n};\n\n});\n\nparcelRegister(\"gHIBu\", function(module, exports) {\n\n$parcel$export(module.exports, \"glUploadVideoResource\", () => $4ebe7112f6bf6666$export$a442959494e20fc);\n\nvar $4DDYK = parcelRequire(\"4DDYK\");\n\"use strict\";\nconst $4ebe7112f6bf6666$export$a442959494e20fc = {\n    id: \"video\",\n    upload (source, glTexture, gl, webGLVersion) {\n        if (!source.isValid) {\n            gl.texImage2D(glTexture.target, 0, glTexture.internalFormat, 1, 1, 0, glTexture.format, glTexture.type, null);\n            return;\n        }\n        (0, $4DDYK.glUploadImageResource).upload(source, glTexture, gl, webGLVersion);\n    }\n};\n\n});\n\nparcelRegister(\"4JQmo\", function(module, exports) {\n\n$parcel$export(module.exports, \"applyStyleParams\", () => $94f5659bdaf1001d$export$7be2fbeda5b178b7);\n\nvar $2SVDG = parcelRequire(\"2SVDG\");\n\"use strict\";\nfunction $94f5659bdaf1001d$export$7be2fbeda5b178b7(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam, forceClamp, firstCreation) {\n    const castParam = firstParam;\n    if (!firstCreation || style.addressModeU !== \"repeat\" || style.addressModeV !== \"repeat\" || style.addressModeW !== \"repeat\") {\n        const wrapModeS = (0, $2SVDG.wrapModeToGlAddress)[forceClamp ? \"clamp-to-edge\" : style.addressModeU];\n        const wrapModeT = (0, $2SVDG.wrapModeToGlAddress)[forceClamp ? \"clamp-to-edge\" : style.addressModeV];\n        const wrapModeR = (0, $2SVDG.wrapModeToGlAddress)[forceClamp ? \"clamp-to-edge\" : style.addressModeW];\n        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);\n        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);\n        if (gl.TEXTURE_WRAP_R) gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);\n    }\n    if (!firstCreation || style.magFilter !== \"linear\") gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, (0, $2SVDG.scaleModeToGlFilter)[style.magFilter]);\n    if (mipmaps) {\n        if (!firstCreation || style.mipmapFilter !== \"linear\") {\n            const glFilterMode = (0, $2SVDG.mipmapScaleModeToGlFilter)[style.minFilter][style.mipmapFilter];\n            gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);\n        }\n    } else gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, (0, $2SVDG.scaleModeToGlFilter)[style.minFilter]);\n    if (anisotropicExt && style.maxAnisotropy > 1) {\n        const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n        gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n    }\n    if (style.compare) gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, (0, $2SVDG.compareModeToGlCompare)[style.compare]);\n}\n\n});\nparcelRegister(\"2SVDG\", function(module, exports) {\n\n$parcel$export(module.exports, \"scaleModeToGlFilter\", () => $dacba914c81174bd$export$801e6deda261184a);\n$parcel$export(module.exports, \"mipmapScaleModeToGlFilter\", () => $dacba914c81174bd$export$aba49ce9fa09b298);\n$parcel$export(module.exports, \"wrapModeToGlAddress\", () => $dacba914c81174bd$export$cc1c4e2fb99490bd);\n$parcel$export(module.exports, \"compareModeToGlCompare\", () => $dacba914c81174bd$export$4518bf8c33a3aebc);\n\"use strict\";\nconst $dacba914c81174bd$export$801e6deda261184a = {\n    linear: 9729,\n    nearest: 9728\n};\nconst $dacba914c81174bd$export$aba49ce9fa09b298 = {\n    linear: {\n        linear: 9987,\n        nearest: 9985\n    },\n    nearest: {\n        linear: 9986,\n        nearest: 9984\n    }\n};\nconst $dacba914c81174bd$export$cc1c4e2fb99490bd = {\n    \"clamp-to-edge\": 33071,\n    repeat: 10497,\n    \"mirror-repeat\": 33648\n};\nconst $dacba914c81174bd$export$4518bf8c33a3aebc = {\n    never: 512,\n    less: 513,\n    equal: 514,\n    \"less-equal\": 515,\n    greater: 516,\n    \"not-equal\": 517,\n    \"greater-equal\": 518,\n    always: 519\n};\n\n});\n\n\nparcelRegister(\"6mS9o\", function(module, exports) {\n\n$parcel$export(module.exports, \"mapFormatToGlFormat\", () => $e88cdb8c143a8533$export$42ed406df12ab342);\n\"use strict\";\nfunction $e88cdb8c143a8533$export$42ed406df12ab342(gl) {\n    return {\n        // 8-bit formats\n        r8unorm: gl.RED,\n        r8snorm: gl.RED,\n        r8uint: gl.RED,\n        r8sint: gl.RED,\n        // 16-bit formats\n        r16uint: gl.RED,\n        r16sint: gl.RED,\n        r16float: gl.RED,\n        rg8unorm: gl.RG,\n        rg8snorm: gl.RG,\n        rg8uint: gl.RG,\n        rg8sint: gl.RG,\n        // 32-bit formats\n        r32uint: gl.RED,\n        r32sint: gl.RED,\n        r32float: gl.RED,\n        rg16uint: gl.RG,\n        rg16sint: gl.RG,\n        rg16float: gl.RG,\n        rgba8unorm: gl.RGBA,\n        \"rgba8unorm-srgb\": gl.RGBA,\n        // Packed 32-bit formats\n        rgba8snorm: gl.RGBA,\n        rgba8uint: gl.RGBA,\n        rgba8sint: gl.RGBA,\n        bgra8unorm: gl.RGBA,\n        \"bgra8unorm-srgb\": gl.RGBA,\n        rgb9e5ufloat: gl.RGB,\n        rgb10a2unorm: gl.RGBA,\n        rg11b10ufloat: gl.RGB,\n        // 64-bit formats\n        rg32uint: gl.RG,\n        rg32sint: gl.RG,\n        rg32float: gl.RG,\n        rgba16uint: gl.RGBA,\n        rgba16sint: gl.RGBA,\n        rgba16float: gl.RGBA,\n        // 128-bit formats\n        rgba32uint: gl.RGBA,\n        rgba32sint: gl.RGBA,\n        rgba32float: gl.RGBA,\n        // Depth/stencil formats\n        stencil8: gl.STENCIL_INDEX8,\n        depth16unorm: gl.DEPTH_COMPONENT,\n        depth24plus: gl.DEPTH_COMPONENT,\n        \"depth24plus-stencil8\": gl.DEPTH_STENCIL,\n        depth32float: gl.DEPTH_COMPONENT,\n        \"depth32float-stencil8\": gl.DEPTH_STENCIL\n    };\n}\n\n});\n\nparcelRegister(\"l9Yyl\", function(module, exports) {\n\n$parcel$export(module.exports, \"mapFormatToGlInternalFormat\", () => $0ca35fd83728246d$export$555b87969daa38c6);\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\"use strict\";\nfunction $0ca35fd83728246d$export$555b87969daa38c6(gl, extensions) {\n    let srgb = {};\n    let bgra8unorm = gl.RGBA;\n    if (!(gl instanceof (0, $iCGeI.DOMAdapter).get().getWebGLRenderingContext())) {\n        srgb = {\n            \"rgba8unorm-srgb\": gl.SRGB8_ALPHA8,\n            \"bgra8unorm-srgb\": gl.SRGB8_ALPHA8\n        };\n        bgra8unorm = gl.RGBA8;\n    } else if (extensions.srgb) srgb = {\n        \"rgba8unorm-srgb\": extensions.srgb.SRGB8_ALPHA8_EXT,\n        \"bgra8unorm-srgb\": extensions.srgb.SRGB8_ALPHA8_EXT\n    };\n    return {\n        // 8-bit formats\n        r8unorm: gl.R8,\n        r8snorm: gl.R8_SNORM,\n        r8uint: gl.R8UI,\n        r8sint: gl.R8I,\n        // 16-bit formats\n        r16uint: gl.R16UI,\n        r16sint: gl.R16I,\n        r16float: gl.R16F,\n        rg8unorm: gl.RG8,\n        rg8snorm: gl.RG8_SNORM,\n        rg8uint: gl.RG8UI,\n        rg8sint: gl.RG8I,\n        // 32-bit formats\n        r32uint: gl.R32UI,\n        r32sint: gl.R32I,\n        r32float: gl.R32F,\n        rg16uint: gl.RG16UI,\n        rg16sint: gl.RG16I,\n        rg16float: gl.RG16F,\n        rgba8unorm: gl.RGBA,\n        ...srgb,\n        // Packed 32-bit formats\n        rgba8snorm: gl.RGBA8_SNORM,\n        rgba8uint: gl.RGBA8UI,\n        rgba8sint: gl.RGBA8I,\n        bgra8unorm: bgra8unorm,\n        rgb9e5ufloat: gl.RGB9_E5,\n        rgb10a2unorm: gl.RGB10_A2,\n        rg11b10ufloat: gl.R11F_G11F_B10F,\n        // 64-bit formats\n        rg32uint: gl.RG32UI,\n        rg32sint: gl.RG32I,\n        rg32float: gl.RG32F,\n        rgba16uint: gl.RGBA16UI,\n        rgba16sint: gl.RGBA16I,\n        rgba16float: gl.RGBA16F,\n        // 128-bit formats\n        rgba32uint: gl.RGBA32UI,\n        rgba32sint: gl.RGBA32I,\n        rgba32float: gl.RGBA32F,\n        // Depth/stencil formats\n        stencil8: gl.STENCIL_INDEX8,\n        depth16unorm: gl.DEPTH_COMPONENT16,\n        depth24plus: gl.DEPTH_COMPONENT24,\n        \"depth24plus-stencil8\": gl.DEPTH24_STENCIL8,\n        depth32float: gl.DEPTH_COMPONENT32F,\n        \"depth32float-stencil8\": gl.DEPTH32F_STENCIL8,\n        // Compressed formats\n        ...extensions.s3tc ? {\n            \"bc1-rgba-unorm\": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n            \"bc2-rgba-unorm\": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n            \"bc3-rgba-unorm\": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT\n        } : {},\n        ...extensions.s3tc_sRGB ? {\n            \"bc1-rgba-unorm-srgb\": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,\n            \"bc2-rgba-unorm-srgb\": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,\n            \"bc3-rgba-unorm-srgb\": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT\n        } : {},\n        ...extensions.rgtc ? {\n            \"bc4-r-unorm\": extensions.rgtc.COMPRESSED_RED_RGTC1_EXT,\n            \"bc4-r-snorm\": extensions.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,\n            \"bc5-rg-unorm\": extensions.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,\n            \"bc5-rg-snorm\": extensions.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT\n        } : {},\n        ...extensions.bptc ? {\n            \"bc6h-rgb-float\": extensions.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,\n            \"bc6h-rgb-ufloat\": extensions.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,\n            \"bc7-rgba-unorm\": extensions.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,\n            \"bc7-rgba-unorm-srgb\": extensions.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT\n        } : {},\n        ...extensions.etc ? {\n            \"etc2-rgb8unorm\": extensions.etc.COMPRESSED_RGB8_ETC2,\n            \"etc2-rgb8unorm-srgb\": extensions.etc.COMPRESSED_SRGB8_ETC2,\n            \"etc2-rgb8a1unorm\": extensions.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n            \"etc2-rgb8a1unorm-srgb\": extensions.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n            \"etc2-rgba8unorm\": extensions.etc.COMPRESSED_RGBA8_ETC2_EAC,\n            \"etc2-rgba8unorm-srgb\": extensions.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,\n            \"eac-r11unorm\": extensions.etc.COMPRESSED_R11_EAC,\n            // 'eac-r11snorm'\n            \"eac-rg11unorm\": extensions.etc.COMPRESSED_SIGNED_RG11_EAC\n        } : {},\n        ...extensions.astc ? {\n            \"astc-4x4-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,\n            \"astc-4x4-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,\n            \"astc-5x4-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,\n            \"astc-5x4-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,\n            \"astc-5x5-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,\n            \"astc-5x5-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,\n            \"astc-6x5-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,\n            \"astc-6x5-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,\n            \"astc-6x6-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,\n            \"astc-6x6-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,\n            \"astc-8x5-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,\n            \"astc-8x5-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,\n            \"astc-8x6-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,\n            \"astc-8x6-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,\n            \"astc-8x8-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,\n            \"astc-8x8-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,\n            \"astc-10x5-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,\n            \"astc-10x5-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,\n            \"astc-10x6-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,\n            \"astc-10x6-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,\n            \"astc-10x8-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,\n            \"astc-10x8-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,\n            \"astc-10x10-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,\n            \"astc-10x10-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,\n            \"astc-12x10-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,\n            \"astc-12x10-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,\n            \"astc-12x12-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,\n            \"astc-12x12-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR\n        } : {}\n    };\n}\n\n});\n\nparcelRegister(\"lkFWs\", function(module, exports) {\n\n$parcel$export(module.exports, \"mapFormatToGlType\", () => $1afec7d3f497de00$export$21c93d3b4ec1a2c2);\n\"use strict\";\nfunction $1afec7d3f497de00$export$21c93d3b4ec1a2c2(gl) {\n    return {\n        // 8-bit formats\n        r8unorm: gl.UNSIGNED_BYTE,\n        r8snorm: gl.BYTE,\n        r8uint: gl.UNSIGNED_BYTE,\n        r8sint: gl.BYTE,\n        // 16-bit formats\n        r16uint: gl.UNSIGNED_SHORT,\n        r16sint: gl.SHORT,\n        r16float: gl.HALF_FLOAT,\n        rg8unorm: gl.UNSIGNED_BYTE,\n        rg8snorm: gl.BYTE,\n        rg8uint: gl.UNSIGNED_BYTE,\n        rg8sint: gl.BYTE,\n        // 32-bit formats\n        r32uint: gl.UNSIGNED_INT,\n        r32sint: gl.INT,\n        r32float: gl.FLOAT,\n        rg16uint: gl.UNSIGNED_SHORT,\n        rg16sint: gl.SHORT,\n        rg16float: gl.HALF_FLOAT,\n        rgba8unorm: gl.UNSIGNED_BYTE,\n        \"rgba8unorm-srgb\": gl.UNSIGNED_BYTE,\n        // Packed 32-bit formats\n        rgba8snorm: gl.BYTE,\n        rgba8uint: gl.UNSIGNED_BYTE,\n        rgba8sint: gl.BYTE,\n        bgra8unorm: gl.UNSIGNED_BYTE,\n        \"bgra8unorm-srgb\": gl.UNSIGNED_BYTE,\n        rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,\n        rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,\n        rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,\n        // 64-bit formats\n        rg32uint: gl.UNSIGNED_INT,\n        rg32sint: gl.INT,\n        rg32float: gl.FLOAT,\n        rgba16uint: gl.UNSIGNED_SHORT,\n        rgba16sint: gl.SHORT,\n        rgba16float: gl.HALF_FLOAT,\n        // 128-bit formats\n        rgba32uint: gl.UNSIGNED_INT,\n        rgba32sint: gl.INT,\n        rgba32float: gl.FLOAT,\n        // Depth/stencil formats\n        stencil8: gl.UNSIGNED_BYTE,\n        depth16unorm: gl.UNSIGNED_SHORT,\n        depth24plus: gl.UNSIGNED_INT,\n        \"depth24plus-stencil8\": gl.UNSIGNED_INT_24_8,\n        depth32float: gl.FLOAT,\n        \"depth32float-stencil8\": gl.FLOAT_32_UNSIGNED_INT_24_8_REV\n    };\n}\n\n});\n\n\n\n\n//# sourceMappingURL=WebGLRenderer.717481ab.js.map\n","import { extensions, ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { GlGraphicsAdaptor } from '../../../scene/graphics/gl/GlGraphicsAdaptor.mjs';\nimport { GlMeshAdaptor } from '../../../scene/mesh/gl/GlMeshAdaptor.mjs';\nimport { GlBatchAdaptor } from '../../batcher/gl/GlBatchAdaptor.mjs';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer.mjs';\nimport { SharedSystems, SharedRenderPipes } from '../shared/system/SharedSystems.mjs';\nimport { RendererType } from '../types.mjs';\nimport { GlBufferSystem } from './buffer/GlBufferSystem.mjs';\nimport { GlContextSystem } from './context/GlContextSystem.mjs';\nimport { GlGeometrySystem } from './geometry/GlGeometrySystem.mjs';\nimport { GlBackBufferSystem } from './GlBackBufferSystem.mjs';\nimport { GlColorMaskSystem } from './GlColorMaskSystem.mjs';\nimport { GlEncoderSystem } from './GlEncoderSystem.mjs';\nimport { GlStencilSystem } from './GlStencilSystem.mjs';\nimport { GlUboSystem } from './GlUboSystem.mjs';\nimport { GlRenderTargetSystem } from './renderTarget/GlRenderTargetSystem.mjs';\nimport { GlShaderSystem } from './shader/GlShaderSystem.mjs';\nimport { GlUniformGroupSystem } from './shader/GlUniformGroupSystem.mjs';\nimport { GlStateSystem } from './state/GlStateSystem.mjs';\nimport { GlTextureSystem } from './texture/GlTextureSystem.mjs';\n\n\"use strict\";\nconst DefaultWebGLSystems = [\n  ...SharedSystems,\n  GlUboSystem,\n  GlBackBufferSystem,\n  GlContextSystem,\n  GlBufferSystem,\n  GlTextureSystem,\n  GlRenderTargetSystem,\n  GlGeometrySystem,\n  GlUniformGroupSystem,\n  GlShaderSystem,\n  GlEncoderSystem,\n  GlStateSystem,\n  GlStencilSystem,\n  GlColorMaskSystem\n];\nconst DefaultWebGLPipes = [...SharedRenderPipes];\nconst DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];\nconst systems = [];\nconst renderPipes = [];\nconst renderPipeAdaptors = [];\nextensions.handleByNamedList(ExtensionType.WebGLSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors);\nextensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);\nclass WebGLRenderer extends AbstractRenderer {\n  constructor() {\n    const systemConfig = {\n      name: \"webgl\",\n      type: RendererType.WEBGL,\n      systems,\n      renderPipes,\n      renderPipeAdaptors\n    };\n    super(systemConfig);\n  }\n}\n\nexport { WebGLRenderer };\n//# sourceMappingURL=WebGLRenderer.mjs.map\n","import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { GlGraphicsAdaptor } from '../../../scene/graphics/gl/GlGraphicsAdaptor';\nimport { GlMeshAdaptor } from '../../../scene/mesh/gl/GlMeshAdaptor';\nimport { GlBatchAdaptor } from '../../batcher/gl/GlBatchAdaptor';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer';\nimport { SharedRenderPipes, SharedSystems } from '../shared/system/SharedSystems';\nimport { RendererType } from '../types';\nimport { GlBufferSystem } from './buffer/GlBufferSystem';\nimport { GlContextSystem } from './context/GlContextSystem';\nimport { GlGeometrySystem } from './geometry/GlGeometrySystem';\nimport { GlBackBufferSystem } from './GlBackBufferSystem';\nimport { GlColorMaskSystem } from './GlColorMaskSystem';\nimport { GlEncoderSystem } from './GlEncoderSystem';\nimport { GlStencilSystem } from './GlStencilSystem';\nimport { GlUboSystem } from './GlUboSystem';\nimport { GlRenderTargetSystem } from './renderTarget/GlRenderTargetSystem';\nimport { GlShaderSystem } from './shader/GlShaderSystem';\nimport { GlUniformGroupSystem } from './shader/GlUniformGroupSystem';\nimport { GlStateSystem } from './state/GlStateSystem';\nimport { GlTextureSystem } from './texture/GlTextureSystem';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { PipeConstructor } from '../shared/instructions/RenderPipe';\nimport type { SharedRendererOptions } from '../shared/system/SharedSystems';\nimport type { SystemConstructor } from '../shared/system/System';\nimport type { ExtractRendererOptions, ExtractSystemTypes } from '../shared/system/utils/typeUtils';\nimport type { GlRenderingContext } from './context/GlRenderingContext';\n\nconst DefaultWebGLSystems = [\n    ...SharedSystems,\n    GlUboSystem,\n    GlBackBufferSystem,\n    GlContextSystem,\n    GlBufferSystem,\n    GlTextureSystem,\n    GlRenderTargetSystem,\n    GlGeometrySystem,\n    GlUniformGroupSystem,\n    GlShaderSystem,\n    GlEncoderSystem,\n    GlStateSystem,\n    GlStencilSystem,\n    GlColorMaskSystem,\n];\nconst DefaultWebGLPipes = [...SharedRenderPipes];\nconst DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];\n\n// installed systems will bbe added to this array by the extensions manager..\nconst systems: { name: string; value: SystemConstructor }[] = [];\nconst renderPipes: { name: string; value: PipeConstructor }[] = [];\nconst renderPipeAdaptors: { name: string; value: any }[] = [];\n\nextensions.handleByNamedList(ExtensionType.WebGLSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors);\n\n// add all the default systems as well as any user defined ones from the extensions\nextensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);\n\n/** The default WebGL renderer, uses WebGL2 contexts. */\ntype WebGLSystems = ExtractSystemTypes<typeof DefaultWebGLSystems> & PixiMixins.RendererSystems & PixiMixins.WebGLSystems;\n\n/** The default WebGL renderer, uses WebGL2 contexts. */\nexport type WebGLPipes = ExtractSystemTypes<typeof DefaultWebGLPipes> & PixiMixins.RendererPipes & PixiMixins.WebGLPipes;\n\n/**\n * Options for WebGLRenderer.\n * @memberof rendering\n */\nexport interface WebGLOptions\n    extends\n    SharedRendererOptions,\n    ExtractRendererOptions<typeof DefaultWebGLSystems>,\n    PixiMixins.WebGLOptions {}\n\n/**\n * The default WebGL renderer, uses WebGL2 contexts.\n * @memberof rendering\n */\nexport interface WebGLRenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGLPipes, WebGLOptions, T>,\n    WebGLSystems {}\n\n/* eslint-disable max-len */\n/**\n * The WebGL PixiJS Renderer. This renderer allows you to use the most common graphics API, WebGL (and WebGL2).\n *\n * ```ts\n * // Create a new renderer\n * const renderer = new WebGLRenderer();\n * await renderer.init();\n *\n * // Add the renderer to the stage\n * document.body.appendChild(renderer.canvas);\n *\n * // Create a new stage\n * const stage = new Container();\n *\n * // Render the stage\n * renderer.render(stage);\n * ```\n *\n * You can use {@link rendering.autoDetectRenderer} to create a renderer that will automatically detect the best\n * renderer for the environment.\n *\n *\n * ```ts\n * // Create a new renderer\n * const renderer = await rendering.autoDetectRenderer({\n *    preference:'webgl',\n * });\n * ```\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a WebGL renderer:\n *\n * | WebGL Core Systems                          | Systems that are specific to the WebGL renderer                               |\n * | ------------------------------------------- | ----------------------------------------------------------------------------- |\n * | {@link rendering.GlUboSystem}               | This manages WebGL2 uniform buffer objects feature for shaders                |\n * | {@link rendering.GlBackBufferSystem}        | manages the back buffer, used so that we can pixi can pixels from the screen  |\n * | {@link rendering.GlContextSystem}           | This manages the WebGL context and its extensions                             |\n * | {@link rendering.GlBufferSystem}            | This manages buffers and their GPU resources, keeps everything in sync        |\n * | {@link rendering.GlTextureSystem}           | This manages textures and their GPU resources, keeps everything in sync       |\n * | {@link rendering.GlRenderTargetSystem}      | This manages what we render too. For example the screen, or another texture   |\n * | {@link rendering.GlGeometrySystem}          | This manages geometry, used for drawing meshes via the GPU                    |\n * | {@link rendering.GlUniformGroupSystem}      | This manages uniform groups. Syncing shader properties with the GPU           |\n * | {@link rendering.GlShaderSystem}            | This manages shaders, programs that run on the GPU to output lovely pixels    |\n * | {@link rendering.GlEncoderSystem}           | This manages encoders, a WebGPU Paradigm, use it to draw a mesh + shader      |\n * | {@link rendering.GlStateSystem}             | This manages the state of the WebGL context. eg the various flags that can be set blend modes / depthTesting etc |\n * | {@link rendering.GlStencilSystem}           | This manages the stencil buffer. Used primarily for masking                   |\n * | {@link rendering.GlColorMaskSystem}         | This manages the color mask. Used for color masking                           |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @memberof rendering\n * @property {rendering.GlUboSystem} ubo - UboSystem instance.\n * @property {rendering.GlBackBufferSystem} backBuffer - BackBufferSystem instance.\n * @property {rendering.GlContextSystem} context - ContextSystem instance.\n * @property {rendering.GlBufferSystem} buffer - BufferSystem instance.\n * @property {rendering.GlTextureSystem} texture - TextureSystem instance.\n * @property {rendering.GlRenderTargetSystem} renderTarget - RenderTargetSystem instance.\n * @property {rendering.GlGeometrySystem} geometry - GeometrySystem instance.\n * @property {rendering.GlUniformGroupSystem} uniformGroup - UniformGroupSystem instance.\n * @property {rendering.GlShaderSystem} shader - ShaderSystem instance.\n * @property {rendering.GlEncoderSystem} encoder - EncoderSystem instance.\n * @property {rendering.GlStateSystem} state - StateSystem instance.\n * @property {rendering.GlStencilSystem} stencil - StencilSystem instance.\n * @property {rendering.GlColorMaskSystem} colorMask - ColorMaskSystem instance.\n * @extends rendering.AbstractRenderer\n */\n/* eslint-enable max-len */\nexport class WebGLRenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGLPipes, WebGLOptions, T>\n    implements WebGLSystems\n{\n    public gl: GlRenderingContext;\n\n    constructor()\n    {\n        const systemConfig = {\n            name: 'webgl',\n            type: RendererType.WEBGL,\n            systems,\n            renderPipes,\n            renderPipeAdaptors,\n        };\n\n        super(systemConfig);\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { MAX_TEXTURES } from '../../../rendering/batcher/shared/const.mjs';\nimport { compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBitGl } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { batchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/batchSamplersUniformGroup.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\n\n\"use strict\";\nclass GlGraphicsAdaptor {\n  init() {\n    const uniforms = new UniformGroup({\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    const glProgram = compileHighShaderGlProgram({\n      name: \"graphics\",\n      bits: [\n        colorBitGl,\n        generateTextureBatchBitGl(MAX_TEXTURES),\n        localUniformBitGl,\n        roundPixelsBitGl\n      ]\n    });\n    this.shader = new Shader({\n      glProgram,\n      resources: {\n        localUniforms: uniforms,\n        batchSamplers: batchSamplersUniformGroup\n      }\n    });\n  }\n  execute(graphicsPipe, renderable) {\n    const context = renderable.context;\n    const shader = context.customShader || this.shader;\n    const renderer = graphicsPipe.renderer;\n    const contextSystem = renderer.graphicsContext;\n    const {\n      geometry,\n      instructions\n    } = contextSystem.getContextRenderData(context);\n    shader.groups[0] = renderer.globalUniforms.bindGroup;\n    renderer.shader.bind(shader);\n    renderer.geometry.bind(geometry, shader.glProgram);\n    const batches = instructions.instructions;\n    for (let i = 0; i < instructions.instructionSize; i++) {\n      const batch = batches[i];\n      if (batch.size) {\n        for (let j = 0; j < batch.textures.textures.length; j++) {\n          renderer.texture.bind(batch.textures.textures[j], j);\n        }\n        renderer.geometry.draw(\"triangle-list\", batch.size, batch.start);\n      }\n    }\n  }\n  destroy() {\n    this.shader.destroy(true);\n    this.shader = null;\n  }\n}\n/** @ignore */\nGlGraphicsAdaptor.extension = {\n  type: [\n    ExtensionType.WebGLPipesAdaptor\n  ],\n  name: \"graphics\"\n};\n\nexport { GlGraphicsAdaptor };\n//# sourceMappingURL=GlGraphicsAdaptor.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { MAX_TEXTURES } from '../../../rendering/batcher/shared/const';\nimport { compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBitGl } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { batchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/batchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\n\nimport type { Batch } from '../../../rendering/batcher/shared/Batcher';\nimport type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\nimport type { Graphics } from '../shared/Graphics';\nimport type { GraphicsAdaptor, GraphicsPipe } from '../shared/GraphicsPipe';\n\n/**\n * A GraphicsAdaptor that uses WebGL to render graphics.\n * @memberof rendering\n * @ignore\n */\nexport class GlGraphicsAdaptor implements GraphicsAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public shader: Shader;\n\n    public init()\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const glProgram = compileHighShaderGlProgram({\n            name: 'graphics',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(MAX_TEXTURES),\n                localUniformBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        this.shader = new Shader({\n            glProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: batchSamplersUniformGroup,\n            }\n        });\n    }\n\n    public execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void\n    {\n        const context = renderable.context;\n        const shader = context.customShader || this.shader;\n        const renderer = graphicsPipe.renderer as WebGLRenderer;\n        const contextSystem = renderer.graphicsContext;\n\n        const {\n            geometry, instructions,\n        } = contextSystem.getContextRenderData(context);\n\n        // WebGL specific..\n        shader.groups[0] = renderer.globalUniforms.bindGroup;\n\n        renderer.shader.bind(shader);\n\n        renderer.geometry.bind(geometry, shader.glProgram);\n\n        const batches = instructions.instructions as Batch[];\n\n        for (let i = 0; i < instructions.instructionSize; i++)\n        {\n            const batch = batches[i];\n\n            if (batch.size)\n            {\n                for (let j = 0; j < batch.textures.textures.length; j++)\n                {\n                    renderer.texture.bind(batch.textures.textures[j], j);\n                }\n\n                renderer.geometry.draw('triangle-list', batch.size, batch.start);\n            }\n        }\n    }\n\n    public destroy(): void\n    {\n        this.shader.destroy(true);\n        this.shader = null;\n    }\n}\n","import { MAX_TEXTURES } from '../../../batcher/shared/const.mjs';\nimport { UniformGroup } from '../../shared/shader/UniformGroup.mjs';\n\n\"use strict\";\nconst sampleValues = new Int32Array(MAX_TEXTURES);\nfor (let i = 0; i < MAX_TEXTURES; i++) {\n  sampleValues[i] = i;\n}\nconst batchSamplersUniformGroup = new UniformGroup({\n  uTextures: { value: sampleValues, type: `i32`, size: MAX_TEXTURES }\n}, { isStatic: true });\n\nexport { batchSamplersUniformGroup };\n//# sourceMappingURL=batchSamplersUniformGroup.mjs.map\n","import { MAX_TEXTURES } from '../../../batcher/shared/const';\nimport { UniformGroup } from '../../shared/shader/UniformGroup';\n\nconst sampleValues = new Int32Array(MAX_TEXTURES);\n\nfor (let i = 0; i < MAX_TEXTURES; i++)\n{\n    sampleValues[i] = i;\n}\n\nexport const batchSamplersUniformGroup = new UniformGroup({\n    uTextures: { value: sampleValues, type: `i32`, size: MAX_TEXTURES }\n}, { isStatic: true });\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { textureBitGl } from '../../../rendering/high-shader/shader-bits/textureBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\n\n\"use strict\";\nclass GlMeshAdaptor {\n  init() {\n    const glProgram = compileHighShaderGlProgram({\n      name: \"mesh\",\n      bits: [\n        localUniformBitGl,\n        textureBitGl,\n        roundPixelsBitGl\n      ]\n    });\n    this._shader = new Shader({\n      glProgram,\n      resources: {\n        uTexture: Texture.EMPTY.source,\n        textureUniforms: {\n          uTextureMatrix: { type: \"mat3x3<f32>\", value: new Matrix() }\n        }\n      }\n    });\n  }\n  execute(meshPipe, mesh) {\n    const renderer = meshPipe.renderer;\n    let shader = mesh._shader;\n    if (!shader) {\n      shader = this._shader;\n      const texture = mesh.texture;\n      const source = texture.source;\n      shader.resources.uTexture = source;\n      shader.resources.uSampler = source.style;\n      shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;\n    } else if (!shader.glProgram) {\n      warn(\"Mesh shader has no glProgram\", mesh.shader);\n      return;\n    }\n    shader.groups[100] = renderer.globalUniforms.bindGroup;\n    shader.groups[101] = meshPipe.localUniformsBindGroup;\n    renderer.encoder.draw({\n      geometry: mesh._geometry,\n      shader,\n      state: mesh.state\n    });\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n}\nGlMeshAdaptor.extension = {\n  type: [\n    ExtensionType.WebGLPipesAdaptor\n  ],\n  name: \"mesh\"\n};\n\nexport { GlMeshAdaptor };\n//# sourceMappingURL=GlMeshAdaptor.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { textureBitGl } from '../../../rendering/high-shader/shader-bits/textureBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { Mesh } from '../shared/Mesh';\nimport type { MeshAdaptor, MeshPipe } from '../shared/MeshPipe';\n\n/**\n * A MeshAdaptor that uses the WebGL to render meshes.\n * @memberof rendering\n * @ignore\n */\nexport class GlMeshAdaptor implements MeshAdaptor\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'mesh',\n    } as const;\n\n    private _shader: Shader;\n\n    public init(): void\n    {\n        const glProgram = compileHighShaderGlProgram({\n            name: 'mesh',\n            bits: [\n                localUniformBitGl,\n                textureBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        this._shader = new Shader({\n            glProgram,\n            resources: {\n                uTexture: Texture.EMPTY.source,\n                textureUniforms: {\n                    uTextureMatrix: { type: 'mat3x3<f32>', value: new Matrix() },\n                }\n            }\n        });\n    }\n\n    public execute(meshPipe: MeshPipe, mesh: Mesh): void\n    {\n        const renderer = meshPipe.renderer;\n\n        let shader: Shader = mesh._shader;\n\n        if (!shader)\n        {\n            shader = this._shader;\n\n            const texture = mesh.texture;\n            const source = texture.source;\n\n            shader.resources.uTexture = source;\n            shader.resources.uSampler = source.style;\n            shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;\n        }\n        else if (!shader.glProgram)\n        {\n            // #if _DEBUG\n            warn('Mesh shader has no glProgram', mesh.shader);\n            // #endif\n\n            return;\n        }\n\n        // setting the groups to be high to be compatible and not\n        // overlap any other groups\n        shader.groups[100] = renderer.globalUniforms.bindGroup;\n        shader.groups[101] = meshPipe.localUniformsBindGroup;\n\n        renderer.encoder.draw({\n            geometry: mesh._geometry,\n            shader,\n            state: mesh.state,\n        });\n    }\n\n    public destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { compileHighShaderGlProgram } from '../../high-shader/compileHighShaderToProgram.mjs';\nimport { colorBitGl } from '../../high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBitGl } from '../../high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { roundPixelsBitGl } from '../../high-shader/shader-bits/roundPixelsBit.mjs';\nimport { batchSamplersUniformGroup } from '../../renderers/gl/shader/batchSamplersUniformGroup.mjs';\nimport { Shader } from '../../renderers/shared/shader/Shader.mjs';\nimport { State } from '../../renderers/shared/state/State.mjs';\nimport { MAX_TEXTURES } from '../shared/const.mjs';\n\n\"use strict\";\nclass GlBatchAdaptor {\n  constructor() {\n    this._didUpload = false;\n    this._tempState = State.for2d();\n  }\n  init(batcherPipe) {\n    const glProgram = compileHighShaderGlProgram({\n      name: \"batch\",\n      bits: [\n        colorBitGl,\n        generateTextureBatchBitGl(MAX_TEXTURES),\n        roundPixelsBitGl\n      ]\n    });\n    this._shader = new Shader({\n      glProgram,\n      resources: {\n        batchSamplers: batchSamplersUniformGroup\n      }\n    });\n    batcherPipe.renderer.runners.contextChange.add(this);\n  }\n  contextChange() {\n    this._didUpload = false;\n  }\n  start(batchPipe, geometry) {\n    const renderer = batchPipe.renderer;\n    renderer.shader.bind(this._shader, this._didUpload);\n    renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);\n    renderer.geometry.bind(geometry, this._shader.glProgram);\n  }\n  execute(batchPipe, batch) {\n    const renderer = batchPipe.renderer;\n    this._didUpload = true;\n    this._tempState.blendMode = batch.blendMode;\n    renderer.state.set(this._tempState);\n    const textures = batch.textures.textures;\n    for (let i = 0; i < textures.length; i++) {\n      renderer.texture.bind(textures[i], i);\n    }\n    renderer.geometry.draw(\"triangle-list\", batch.size, batch.start);\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n}\n/** @ignore */\nGlBatchAdaptor.extension = {\n  type: [\n    ExtensionType.WebGLPipesAdaptor\n  ],\n  name: \"batch\"\n};\n\nexport { GlBatchAdaptor };\n//# sourceMappingURL=GlBatchAdaptor.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { compileHighShaderGlProgram } from '../../high-shader/compileHighShaderToProgram';\nimport { colorBitGl } from '../../high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBitGl } from '../../high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBitGl } from '../../high-shader/shader-bits/roundPixelsBit';\nimport { batchSamplersUniformGroup } from '../../renderers/gl/shader/batchSamplersUniformGroup';\nimport { Shader } from '../../renderers/shared/shader/Shader';\nimport { State } from '../../renderers/shared/state/State';\nimport { MAX_TEXTURES } from '../shared/const';\n\nimport type { WebGLRenderer } from '../../renderers/gl/WebGLRenderer';\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { Batch } from '../shared/Batcher';\nimport type { BatcherAdaptor, BatcherPipe } from '../shared/BatcherPipe';\n\n/**\n * A BatcherAdaptor that uses WebGL to render batches.\n * @memberof rendering\n * @ignore\n */\nexport class GlBatchAdaptor implements BatcherAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'batch',\n    } as const;\n\n    private _shader: Shader;\n    private _didUpload = false;\n    private readonly _tempState = State.for2d();\n\n    public init(batcherPipe: BatcherPipe): void\n    {\n        const glProgram = compileHighShaderGlProgram({\n            name: 'batch',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(MAX_TEXTURES),\n                roundPixelsBitGl,\n            ]\n        });\n\n        this._shader = new Shader({\n            glProgram,\n            resources: {\n                batchSamplers: batchSamplersUniformGroup,\n            }\n        });\n\n        batcherPipe.renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._didUpload = false;\n    }\n\n    public start(batchPipe: BatcherPipe, geometry: Geometry): void\n    {\n        const renderer = batchPipe.renderer as WebGLRenderer;\n\n        renderer.shader.bind(this._shader, this._didUpload);\n\n        renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);\n\n        renderer.geometry.bind(geometry, this._shader.glProgram);\n    }\n\n    public execute(batchPipe: BatcherPipe, batch: Batch): void\n    {\n        const renderer = batchPipe.renderer as WebGLRenderer;\n\n        this._didUpload = true;\n\n        this._tempState.blendMode = batch.blendMode;\n\n        renderer.state.set(this._tempState);\n\n        const textures = batch.textures.textures;\n\n        for (let i = 0; i < textures.length; i++)\n        {\n            renderer.texture.bind(textures[i], i);\n        }\n\n        renderer.geometry.draw('triangle-list', batch.size, batch.start);\n    }\n\n    public destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { BufferUsage } from '../../shared/buffer/const.mjs';\nimport { BUFFER_TYPE } from './const.mjs';\nimport { GlBuffer } from './GlBuffer.mjs';\n\n\"use strict\";\nclass GlBufferSystem {\n  /**\n   * @param {Renderer} renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this._gpuBuffers = /* @__PURE__ */ Object.create(null);\n    /** Cache keeping track of the base bound buffer bases */\n    this._boundBufferBases = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  /**\n   * @ignore\n   */\n  destroy() {\n    this._renderer = null;\n    this._gl = null;\n    this._gpuBuffers = null;\n    this._boundBufferBases = null;\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    this._gpuBuffers = /* @__PURE__ */ Object.create(null);\n    this._gl = this._renderer.gl;\n  }\n  getGlBuffer(buffer) {\n    return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);\n  }\n  /**\n   * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n   * @param buffer - the buffer to bind to the renderer\n   */\n  bind(buffer) {\n    const { _gl: gl } = this;\n    const glBuffer = this.getGlBuffer(buffer);\n    gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n  }\n  /**\n   * Binds an uniform buffer to at the given index.\n   *\n   * A cache is used so a buffer will not be bound again if already bound.\n   * @param buffer - the buffer to bind\n   * @param index - the base index to bind it to.\n   */\n  bindBufferBase(buffer, index) {\n    const { _gl: gl } = this;\n    if (this._boundBufferBases[index] !== buffer) {\n      const glBuffer = this.getGlBuffer(buffer);\n      this._boundBufferBases[index] = buffer;\n      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n    }\n  }\n  /**\n   * Binds a buffer whilst also binding its range.\n   * This will make the buffer start from the offset supplied rather than 0 when it is read.\n   * @param buffer - the buffer to bind\n   * @param index - the base index to bind at, defaults to 0\n   * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n   */\n  bindBufferRange(buffer, index, offset) {\n    const { _gl: gl } = this;\n    offset = offset || 0;\n    const glBuffer = this.getGlBuffer(buffer);\n    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);\n  }\n  /**\n   * Will ensure the data in the buffer is uploaded to the GPU.\n   * @param {Buffer} buffer - the buffer to update\n   */\n  updateBuffer(buffer) {\n    const { _gl: gl } = this;\n    const glBuffer = this.getGlBuffer(buffer);\n    if (buffer._updateID === glBuffer.updateID) {\n      return glBuffer;\n    }\n    glBuffer.updateID = buffer._updateID;\n    gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n    const data = buffer.data;\n    if (glBuffer.byteLength >= buffer.data.byteLength) {\n      gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);\n    } else {\n      const drawType = buffer.descriptor.usage & BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n      glBuffer.byteLength = data.byteLength;\n      gl.bufferData(glBuffer.type, data, drawType);\n    }\n    return glBuffer;\n  }\n  /** dispose all WebGL resources of all managed buffers */\n  destroyAll() {\n    const gl = this._gl;\n    for (const id in this._gpuBuffers) {\n      gl.deleteBuffer(this._gpuBuffers[id].buffer);\n    }\n    this._gpuBuffers = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Disposes buffer\n   * @param {Buffer} buffer - buffer with data\n   * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray\n   */\n  onBufferDestroy(buffer, contextLost) {\n    const glBuffer = this._gpuBuffers[buffer.uid];\n    const gl = this._gl;\n    if (!contextLost) {\n      gl.deleteBuffer(glBuffer.buffer);\n    }\n    this._gpuBuffers[buffer.uid] = null;\n  }\n  /**\n   * creates and attaches a GLBuffer object tied to the current context.\n   * @param buffer\n   * @protected\n   */\n  createGLBuffer(buffer) {\n    const { _gl: gl } = this;\n    let type = BUFFER_TYPE.ARRAY_BUFFER;\n    if (buffer.descriptor.usage & BufferUsage.INDEX) {\n      type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n    } else if (buffer.descriptor.usage & BufferUsage.UNIFORM) {\n      type = BUFFER_TYPE.UNIFORM_BUFFER;\n    }\n    const glBuffer = new GlBuffer(gl.createBuffer(), type);\n    this._gpuBuffers[buffer.uid] = glBuffer;\n    buffer.on(\"destroy\", this.onBufferDestroy, this);\n    return glBuffer;\n  }\n}\n/** @ignore */\nGlBufferSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem\n  ],\n  name: \"buffer\"\n};\n\nexport { GlBufferSystem };\n//# sourceMappingURL=GlBufferSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { BufferUsage } from '../../shared/buffer/const';\nimport { BUFFER_TYPE } from './const';\nimport { GlBuffer } from './GlBuffer';\n\nimport type { Buffer } from '../../shared/buffer/Buffer';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * System plugin to the renderer to manage buffers.\n *\n * WebGL uses Buffers as a way to store objects to the GPU.\n * This system makes working with them a lot easier.\n *\n * Buffers are used in three main places in WebGL\n * - geometry information\n * - Uniform information (via uniform buffer objects - a WebGL 2 only feature)\n * - Transform feedback information. (WebGL 2 only feature)\n *\n * This system will handle the binding of buffers to the GPU as well as uploading\n * them. With this system, you never need to work directly with GPU buffers, but instead work with\n * the Buffer class.\n * @class\n * @memberof rendering\n */\nexport class GlBufferSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'buffer',\n    } as const;\n\n    private _gl: GlRenderingContext;\n    private _gpuBuffers: {[key: number]: GlBuffer} = Object.create(null);\n\n    /** Cache keeping track of the base bound buffer bases */\n    private readonly _boundBufferBases: {[key: number]: Buffer} = Object.create(null);\n\n    private _renderer: WebGLRenderer;\n\n    /**\n     * @param {Renderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * @ignore\n     */\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._gl = null;\n        this._gpuBuffers = null;\n        (this._boundBufferBases as null) = null;\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        this._gpuBuffers = Object.create(null);\n        this._gl = this._renderer.gl;\n    }\n\n    public getGlBuffer(buffer: Buffer): GlBuffer\n    {\n        return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);\n    }\n\n    /**\n     * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n     * @param buffer - the buffer to bind to the renderer\n     */\n    public bind(buffer: Buffer): void\n    {\n        const { _gl: gl } = this;\n\n        const glBuffer = this.getGlBuffer(buffer);\n\n        gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n    }\n\n    /**\n     * Binds an uniform buffer to at the given index.\n     *\n     * A cache is used so a buffer will not be bound again if already bound.\n     * @param buffer - the buffer to bind\n     * @param index - the base index to bind it to.\n     */\n    public bindBufferBase(buffer: Buffer, index: number): void\n    {\n        const { _gl: gl } = this;\n\n        if (this._boundBufferBases[index] !== buffer)\n        {\n            const glBuffer = this.getGlBuffer(buffer);\n\n            this._boundBufferBases[index] = buffer;\n\n            gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n        }\n    }\n\n    /**\n     * Binds a buffer whilst also binding its range.\n     * This will make the buffer start from the offset supplied rather than 0 when it is read.\n     * @param buffer - the buffer to bind\n     * @param index - the base index to bind at, defaults to 0\n     * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n     */\n    public bindBufferRange(buffer: Buffer, index?: number, offset?: number): void\n    {\n        const { _gl: gl } = this;\n\n        offset = offset || 0;\n\n        const glBuffer = this.getGlBuffer(buffer);\n\n        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);\n    }\n\n    /**\n     * Will ensure the data in the buffer is uploaded to the GPU.\n     * @param {Buffer} buffer - the buffer to update\n     */\n    public updateBuffer(buffer: Buffer): GlBuffer\n    {\n        const { _gl: gl } = this;\n\n        const glBuffer = this.getGlBuffer(buffer);\n\n        if (buffer._updateID === glBuffer.updateID)\n        {\n            return glBuffer;\n        }\n\n        glBuffer.updateID = buffer._updateID;\n\n        gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n\n        const data = buffer.data;\n\n        if (glBuffer.byteLength >= buffer.data.byteLength)\n        {\n            // assuming our buffers are aligned to 4 bits...\n            // offset is always zero for now!\n            gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);\n        }\n        else\n        {\n            const drawType = (buffer.descriptor.usage & BufferUsage.STATIC) ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n\n            glBuffer.byteLength = data.byteLength;\n\n            // assuming our buffers are aligned to 4 bits...\n            gl.bufferData(glBuffer.type, data, drawType);\n        }\n\n        return glBuffer;\n    }\n\n    /** dispose all WebGL resources of all managed buffers */\n    public destroyAll(): void\n    {\n        const gl = this._gl;\n\n        for (const id in this._gpuBuffers)\n        {\n            gl.deleteBuffer(this._gpuBuffers[id].buffer);\n        }\n\n        this._gpuBuffers = Object.create(null);\n    }\n\n    /**\n     * Disposes buffer\n     * @param {Buffer} buffer - buffer with data\n     * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    protected onBufferDestroy(buffer: Buffer, contextLost?: boolean): void\n    {\n        const glBuffer = this._gpuBuffers[buffer.uid];\n\n        const gl = this._gl;\n\n        if (!contextLost)\n        {\n            gl.deleteBuffer(glBuffer.buffer);\n        }\n\n        this._gpuBuffers[buffer.uid] = null;\n    }\n\n    /**\n     * creates and attaches a GLBuffer object tied to the current context.\n     * @param buffer\n     * @protected\n     */\n    protected createGLBuffer(buffer: Buffer): GlBuffer\n    {\n        const { _gl: gl } = this;\n\n        let type = BUFFER_TYPE.ARRAY_BUFFER;\n\n        if ((buffer.descriptor.usage & BufferUsage.INDEX))\n        {\n            type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n        }\n        else if ((buffer.descriptor.usage & BufferUsage.UNIFORM))\n        {\n            type = BUFFER_TYPE.UNIFORM_BUFFER;\n        }\n\n        const glBuffer = new GlBuffer(gl.createBuffer(), type);\n\n        this._gpuBuffers[buffer.uid] = glBuffer;\n\n        buffer.on('destroy', this.onBufferDestroy, this);\n\n        return glBuffer;\n    }\n}\n","\"use strict\";\nvar BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {\n  BUFFER_TYPE2[BUFFER_TYPE2[\"ELEMENT_ARRAY_BUFFER\"] = 34963] = \"ELEMENT_ARRAY_BUFFER\";\n  BUFFER_TYPE2[BUFFER_TYPE2[\"ARRAY_BUFFER\"] = 34962] = \"ARRAY_BUFFER\";\n  BUFFER_TYPE2[BUFFER_TYPE2[\"UNIFORM_BUFFER\"] = 35345] = \"UNIFORM_BUFFER\";\n  return BUFFER_TYPE2;\n})(BUFFER_TYPE || {});\n\nexport { BUFFER_TYPE };\n//# sourceMappingURL=const.mjs.map\n","/**\n * Constants for various buffer types in Pixi\n * @see BUFFER_TYPE\n * @name BUFFER_TYPE\n * @static\n * @enum {number}\n * @property {number} ELEMENT_ARRAY_BUFFER - buffer type for using as an index buffer\n * @property {number} ARRAY_BUFFER - buffer type for using attribute data\n * @property {number} UNIFORM_BUFFER - the buffer type is for uniform buffer objects\n */\nexport enum BUFFER_TYPE\n    // eslint-disable-next-line @typescript-eslint/indent\n {\n    ELEMENT_ARRAY_BUFFER = 34963,\n    ARRAY_BUFFER = 34962,\n    UNIFORM_BUFFER = 35345,\n}\n\n","\"use strict\";\nclass GlBuffer {\n  constructor(buffer, type) {\n    this.buffer = buffer || null;\n    this.updateID = -1;\n    this.byteLength = -1;\n    this.type = type;\n  }\n}\n\nexport { GlBuffer };\n//# sourceMappingURL=GlBuffer.mjs.map\n","import type { BUFFER_TYPE } from './const';\n\nexport class GlBuffer\n{\n    public buffer: WebGLBuffer;\n    public updateID: number;\n    public byteLength: number;\n    public type: number;\n\n    constructor(buffer: WebGLBuffer, type: BUFFER_TYPE)\n    {\n        this.buffer = buffer || null;\n        this.updateID = -1;\n        this.byteLength = -1;\n        this.type = type;\n    }\n}\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nconst _GlContextSystem = class _GlContextSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    /**\n     * Features supported by current renderer.\n     * @type {object}\n     * @readonly\n     */\n    this.supports = {\n      /** Support for 32-bit indices buffer. */\n      uint32Indices: true,\n      /** Support for UniformBufferObjects */\n      uniformBufferObject: true,\n      /** Support for VertexArrayObjects */\n      vertexArrayObject: true,\n      /** Support for SRGB texture format */\n      srgbTextures: true,\n      /** Support for wrapping modes if a texture is non-power of two */\n      nonPowOf2wrapping: true,\n      /** Support for MSAA (antialiasing of dynamic textures) */\n      msaa: true,\n      /** Support for mipmaps if a texture is non-power of two */\n      nonPowOf2mipmaps: true\n    };\n    this._renderer = renderer;\n    this.extensions = /* @__PURE__ */ Object.create(null);\n    this.handleContextLost = this.handleContextLost.bind(this);\n    this.handleContextRestored = this.handleContextRestored.bind(this);\n  }\n  /**\n   * `true` if the context is lost\n   * @readonly\n   */\n  get isLost() {\n    return !this.gl || this.gl.isContextLost();\n  }\n  /**\n   * Handles the context change event.\n   * @param {WebGLRenderingContext} gl - New WebGL context.\n   */\n  contextChange(gl) {\n    this.gl = gl;\n    this._renderer.gl = gl;\n  }\n  init(options) {\n    options = { ..._GlContextSystem.defaultOptions, ...options };\n    if (options.context) {\n      this.initFromContext(options.context);\n    } else {\n      const alpha = this._renderer.background.alpha < 1;\n      const premultipliedAlpha = options.premultipliedAlpha ?? true;\n      const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;\n      this.createContext(options.preferWebGLVersion, {\n        alpha,\n        premultipliedAlpha,\n        antialias,\n        stencil: true,\n        preserveDrawingBuffer: options.preserveDrawingBuffer,\n        powerPreference: options.powerPreference ?? \"default\"\n      });\n    }\n  }\n  /**\n   * Initializes the context.\n   * @protected\n   * @param {WebGLRenderingContext} gl - WebGL context\n   */\n  initFromContext(gl) {\n    this.gl = gl;\n    this.webGLVersion = gl instanceof DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;\n    this.getExtensions();\n    this.validateContext(gl);\n    this._renderer.runners.contextChange.emit(gl);\n    const element = this._renderer.view.canvas;\n    element.addEventListener(\"webglcontextlost\", this.handleContextLost, false);\n    element.addEventListener(\"webglcontextrestored\", this.handleContextRestored, false);\n  }\n  /**\n   * Initialize from context options\n   * @protected\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext\n   * @param preferWebGLVersion\n   * @param {object} options - context attributes\n   */\n  createContext(preferWebGLVersion, options) {\n    let gl;\n    const canvas = this._renderer.view.canvas;\n    if (preferWebGLVersion === 2) {\n      gl = canvas.getContext(\"webgl2\", options);\n    }\n    if (!gl) {\n      gl = canvas.getContext(\"webgl\", options);\n      if (!gl) {\n        throw new Error(\"This browser does not support WebGL. Try using the canvas renderer\");\n      }\n    }\n    this.gl = gl;\n    this.initFromContext(this.gl);\n  }\n  /** Auto-populate the {@link GlContextSystem.extensions extensions}. */\n  getExtensions() {\n    const { gl } = this;\n    const common = {\n      anisotropicFiltering: gl.getExtension(\"EXT_texture_filter_anisotropic\"),\n      floatTextureLinear: gl.getExtension(\"OES_texture_float_linear\"),\n      s3tc: gl.getExtension(\"WEBGL_compressed_texture_s3tc\"),\n      s3tc_sRGB: gl.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\"),\n      // eslint-disable-line camelcase\n      etc: gl.getExtension(\"WEBGL_compressed_texture_etc\"),\n      etc1: gl.getExtension(\"WEBGL_compressed_texture_etc1\"),\n      pvrtc: gl.getExtension(\"WEBGL_compressed_texture_pvrtc\") || gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\n      atc: gl.getExtension(\"WEBGL_compressed_texture_atc\"),\n      astc: gl.getExtension(\"WEBGL_compressed_texture_astc\"),\n      bptc: gl.getExtension(\"EXT_texture_compression_bptc\"),\n      rgtc: gl.getExtension(\"EXT_texture_compression_rgtc\"),\n      loseContext: gl.getExtension(\"WEBGL_lose_context\")\n    };\n    if (this.webGLVersion === 1) {\n      this.extensions = {\n        ...common,\n        drawBuffers: gl.getExtension(\"WEBGL_draw_buffers\"),\n        depthTexture: gl.getExtension(\"WEBGL_depth_texture\"),\n        vertexArrayObject: gl.getExtension(\"OES_vertex_array_object\") || gl.getExtension(\"MOZ_OES_vertex_array_object\") || gl.getExtension(\"WEBKIT_OES_vertex_array_object\"),\n        uint32ElementIndex: gl.getExtension(\"OES_element_index_uint\"),\n        // Floats and half-floats\n        floatTexture: gl.getExtension(\"OES_texture_float\"),\n        floatTextureLinear: gl.getExtension(\"OES_texture_float_linear\"),\n        textureHalfFloat: gl.getExtension(\"OES_texture_half_float\"),\n        textureHalfFloatLinear: gl.getExtension(\"OES_texture_half_float_linear\"),\n        vertexAttribDivisorANGLE: gl.getExtension(\"ANGLE_instanced_arrays\"),\n        srgb: gl.getExtension(\"EXT_sRGB\")\n      };\n    } else {\n      this.extensions = {\n        ...common,\n        colorBufferFloat: gl.getExtension(\"EXT_color_buffer_float\")\n      };\n      const provokeExt = gl.getExtension(\"WEBGL_provoking_vertex\");\n      if (provokeExt) {\n        provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);\n      }\n    }\n  }\n  /**\n   * Handles a lost webgl context\n   * @param {WebGLContextEvent} event - The context lost event.\n   */\n  handleContextLost(event) {\n    event.preventDefault();\n    if (this._contextLossForced) {\n      this._contextLossForced = false;\n      setTimeout(() => {\n        if (this.gl.isContextLost()) {\n          this.extensions.loseContext?.restoreContext();\n        }\n      }, 0);\n    }\n  }\n  /** Handles a restored webgl context. */\n  handleContextRestored() {\n    this._renderer.runners.contextChange.emit(this.gl);\n  }\n  destroy() {\n    const element = this._renderer.view.canvas;\n    this._renderer = null;\n    element.removeEventListener(\"webglcontextlost\", this.handleContextLost);\n    element.removeEventListener(\"webglcontextrestored\", this.handleContextRestored);\n    this.gl.useProgram(null);\n    this.extensions.loseContext?.loseContext();\n  }\n  /**\n   * this function can be called to force a webGL context loss\n   * this will release all resources on the GPU.\n   * Useful if you need to put Pixi to sleep, and save some GPU memory\n   *\n   * As soon as render is called - all resources will be created again.\n   */\n  forceContextLoss() {\n    this.extensions.loseContext?.loseContext();\n    this._contextLossForced = true;\n  }\n  /**\n   * Validate context.\n   * @param {WebGLRenderingContext} gl - Render context.\n   */\n  validateContext(gl) {\n    const attributes = gl.getContextAttributes();\n    if (attributes && !attributes.stencil) {\n      warn(\"Provided WebGL context does not have a stencil buffer, masks may not render correctly\");\n    }\n    const supports = this.supports;\n    const isWebGl2 = this.webGLVersion === 2;\n    const extensions = this.extensions;\n    supports.uint32Indices = isWebGl2 || !!extensions.uint32ElementIndex;\n    supports.uniformBufferObject = isWebGl2;\n    supports.vertexArrayObject = isWebGl2 || !!extensions.vertexArrayObject;\n    supports.srgbTextures = isWebGl2 || !!extensions.srgb;\n    supports.nonPowOf2wrapping = isWebGl2;\n    supports.nonPowOf2mipmaps = isWebGl2;\n    supports.msaa = isWebGl2;\n    if (!supports.uint32Indices) {\n      warn(\"Provided WebGL context does not support 32 index buffer, large scenes may not render correctly\");\n    }\n  }\n};\n/** @ignore */\n_GlContextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem\n  ],\n  name: \"context\"\n};\n/** The default options for the system. */\n_GlContextSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.context}\n   * @default null\n   */\n  context: null,\n  /**\n   * {@link WebGLOptions.premultipliedAlpha}\n   * @default true\n   */\n  premultipliedAlpha: true,\n  /**\n   * {@link WebGLOptions.preserveDrawingBuffer}\n   * @default false\n   */\n  preserveDrawingBuffer: false,\n  /**\n   * {@link WebGLOptions.powerPreference}\n   * @default default\n   */\n  powerPreference: void 0,\n  /**\n   * {@link WebGLOptions.webGLVersion}\n   * @default 2\n   */\n  preferWebGLVersion: 2\n};\nlet GlContextSystem = _GlContextSystem;\n\nexport { GlContextSystem };\n//# sourceMappingURL=GlContextSystem.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\nimport { type GpuPowerPreference } from '../../types';\n\nimport type { System } from '../../shared/system/System';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { WebGLExtensions } from './WebGLExtensions';\n\n/**\n * Options for the context system.\n * @memberof rendering\n * @property {WebGL2RenderingContext | null} [context=null] - User-provided WebGL rendering context object.\n * @property {GpuPowerPreference} [powerPreference='default'] - An optional hint indicating what configuration\n * of GPU is suitable for the WebGL context, can be `'high-performance'` or `'low-power'`. Setting to `'high-performance'`\n * will prioritize rendering performance over power consumption, while setting to `'low-power'` will prioritize power saving\n * over rendering performance.\n * @property {boolean} [premultipliedAlpha=true] - Whether the compositor will assume the drawing buffer contains\n * colors with premultiplied alpha.\n * @property {boolean} [preserveDrawingBuffer=false] - Whether to enable drawing buffer preservation.\n * If enabled, the drawing buffer will preserve\n * its value until cleared or overwritten. Enable this if you need to call `toDataUrl` on the WebGL context.\n * @property {boolean} [antialias] - Whether to enable antialiasing.\n * @property {1 | 2} [preferWebGLVersion=2] - The preferred WebGL version to use.\n */\nexport interface ContextSystemOptions\n{\n    /**\n     * User-provided WebGL rendering context object.\n     * @default null\n     * @memberof rendering.SharedRendererOptions\n     */\n    context: WebGL2RenderingContext | null;\n    /**\n     * An optional hint indicating what configuration of GPU is suitable for the WebGL context,\n     * can be `'high-performance'` or `'low-power'`.\n     * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n     * while setting to `'low-power'` will prioritize power saving over rendering performance.\n     * @memberof rendering.SharedRendererOptions\n     * @default undefined\n     */\n    powerPreference?: GpuPowerPreference;\n\n    /**\n     * Whether the compositor will assume the drawing buffer contains colors with premultiplied alpha.\n     * @default true\n     * @memberof rendering.SharedRendererOptions\n     */\n    premultipliedAlpha: boolean;\n    /**\n     * Whether to enable drawing buffer preservation. If enabled, the drawing buffer will preserve\n     * its value until cleared or overwritten. Enable this if you need to call `toDataUrl` on the WebGL context.\n     * @default false\n     * @memberof rendering.SharedRendererOptions\n     */\n    preserveDrawingBuffer: boolean;\n\n    antialias?: boolean;\n\n    /**\n     * The preferred WebGL version to use.\n     * @default 2\n     * @memberof rendering.SharedRendererOptions\n     */\n    preferWebGLVersion?: 1 | 2;\n}\n\n/**\n * System plugin to the renderer to manage the context\n * @memberof rendering\n */\nexport class GlContextSystem implements System<ContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'context',\n    } as const;\n\n    /** The default options for the system. */\n    public static defaultOptions: ContextSystemOptions = {\n        /**\n         * {@link WebGLOptions.context}\n         * @default null\n         */\n        context: null,\n        /**\n         * {@link WebGLOptions.premultipliedAlpha}\n         * @default true\n         */\n        premultipliedAlpha: true,\n        /**\n         * {@link WebGLOptions.preserveDrawingBuffer}\n         * @default false\n         */\n        preserveDrawingBuffer: false,\n        /**\n         * {@link WebGLOptions.powerPreference}\n         * @default default\n         */\n        powerPreference: undefined,\n        /**\n         * {@link WebGLOptions.webGLVersion}\n         * @default 2\n         */\n        preferWebGLVersion: 2,\n    };\n\n    protected CONTEXT_UID: number;\n    protected gl: WebGL2RenderingContext;\n\n    /**\n     * Features supported by current renderer.\n     * @type {object}\n     * @readonly\n     */\n    public supports = {\n        /** Support for 32-bit indices buffer. */\n        uint32Indices: true,\n        /** Support for UniformBufferObjects */\n        uniformBufferObject: true,\n        /** Support for VertexArrayObjects */\n        vertexArrayObject: true,\n        /** Support for SRGB texture format */\n        srgbTextures: true,\n        /** Support for wrapping modes if a texture is non-power of two */\n        nonPowOf2wrapping: true,\n        /** Support for MSAA (antialiasing of dynamic textures) */\n        msaa: true,\n        /** Support for mipmaps if a texture is non-power of two */\n        nonPowOf2mipmaps: true,\n    };\n\n    /**\n     * Extensions available.\n     * @type {object}\n     * @readonly\n     * @property {WEBGL_draw_buffers} drawBuffers - WebGL v1 extension\n     * @property {WEBGL_depth_texture} depthTexture - WebGL v1 extension\n     * @property {OES_texture_float} floatTexture - WebGL v1 extension\n     * @property {WEBGL_lose_context} loseContext - WebGL v1 extension\n     * @property {OES_vertex_array_object} vertexArrayObject - WebGL v1 extension\n     * @property {EXT_texture_filter_anisotropic} anisotropicFiltering - WebGL v1 and v2 extension\n     */\n    public extensions: WebGLExtensions;\n\n    public webGLVersion: 1 | 2;\n\n    private _renderer: WebGLRenderer;\n    private _contextLossForced: boolean;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n\n        this.extensions = Object.create(null);\n\n        // Bind functions\n        this.handleContextLost = this.handleContextLost.bind(this);\n        this.handleContextRestored = this.handleContextRestored.bind(this);\n    }\n\n    /**\n     * `true` if the context is lost\n     * @readonly\n     */\n    get isLost(): boolean\n    {\n        return (!this.gl || this.gl.isContextLost());\n    }\n\n    /**\n     * Handles the context change event.\n     * @param {WebGLRenderingContext} gl - New WebGL context.\n     */\n    protected contextChange(gl: WebGL2RenderingContext): void\n    {\n        this.gl = gl;\n        this._renderer.gl = gl;\n    }\n\n    public init(options: ContextSystemOptions): void\n    {\n        options = { ...GlContextSystem.defaultOptions, ...options };\n\n        /*\n         * The options passed in to create a new WebGL context.\n         */\n        if (options.context)\n        {\n            this.initFromContext(options.context);\n        }\n        else\n        {\n            const alpha = this._renderer.background.alpha < 1;\n            const premultipliedAlpha = options.premultipliedAlpha ?? true;\n            const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;\n\n            this.createContext(options.preferWebGLVersion, {\n                alpha,\n                premultipliedAlpha,\n                antialias,\n                stencil: true,\n                preserveDrawingBuffer: options.preserveDrawingBuffer,\n                powerPreference: options.powerPreference ?? 'default',\n            });\n        }\n    }\n\n    /**\n     * Initializes the context.\n     * @protected\n     * @param {WebGLRenderingContext} gl - WebGL context\n     */\n    protected initFromContext(gl: WebGL2RenderingContext): void\n    {\n        this.gl = gl;\n\n        this.webGLVersion = gl instanceof DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;\n\n        this.getExtensions();\n\n        this.validateContext(gl);\n\n        this._renderer.runners.contextChange.emit(gl);\n\n        const element = this._renderer.view.canvas;\n\n        (element as any).addEventListener('webglcontextlost', this.handleContextLost, false);\n        element.addEventListener('webglcontextrestored', this.handleContextRestored, false);\n    }\n\n    /**\n     * Initialize from context options\n     * @protected\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext\n     * @param preferWebGLVersion\n     * @param {object} options - context attributes\n     */\n    protected createContext(preferWebGLVersion: 1 | 2, options: WebGLContextAttributes): void\n    {\n        let gl: WebGL2RenderingContext | WebGLRenderingContext;\n        const canvas = this._renderer.view.canvas;\n\n        if (preferWebGLVersion === 2)\n        {\n            gl = canvas.getContext('webgl2', options);\n        }\n\n        if (!gl)\n        {\n            gl = canvas.getContext('webgl', options);\n\n            if (!gl)\n            {\n                // fail, not able to get a context\n                throw new Error('This browser does not support WebGL. Try using the canvas renderer');\n            }\n        }\n\n        this.gl = gl as WebGL2RenderingContext;\n\n        this.initFromContext(this.gl);\n    }\n\n    /** Auto-populate the {@link GlContextSystem.extensions extensions}. */\n    protected getExtensions(): void\n    {\n        // time to set up default extensions that Pixi uses.\n        const { gl } = this;\n\n        const common = {\n            anisotropicFiltering: gl.getExtension('EXT_texture_filter_anisotropic'),\n            floatTextureLinear: gl.getExtension('OES_texture_float_linear'),\n\n            s3tc: gl.getExtension('WEBGL_compressed_texture_s3tc'),\n            s3tc_sRGB: gl.getExtension('WEBGL_compressed_texture_s3tc_srgb'), // eslint-disable-line camelcase\n            etc: gl.getExtension('WEBGL_compressed_texture_etc'),\n            etc1: gl.getExtension('WEBGL_compressed_texture_etc1'),\n            pvrtc: gl.getExtension('WEBGL_compressed_texture_pvrtc')\n                || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n            atc: gl.getExtension('WEBGL_compressed_texture_atc'),\n            astc: gl.getExtension('WEBGL_compressed_texture_astc'),\n            bptc: gl.getExtension('EXT_texture_compression_bptc'),\n            rgtc: gl.getExtension('EXT_texture_compression_rgtc'),\n            loseContext: gl.getExtension('WEBGL_lose_context'),\n        };\n\n        if (this.webGLVersion === 1)\n        {\n            this.extensions = {\n                ...common,\n\n                drawBuffers: gl.getExtension('WEBGL_draw_buffers'),\n                depthTexture: gl.getExtension('WEBGL_depth_texture'),\n                vertexArrayObject: gl.getExtension('OES_vertex_array_object')\n                    || gl.getExtension('MOZ_OES_vertex_array_object')\n                    || gl.getExtension('WEBKIT_OES_vertex_array_object'),\n                uint32ElementIndex: gl.getExtension('OES_element_index_uint'),\n                // Floats and half-floats\n                floatTexture: gl.getExtension('OES_texture_float'),\n                floatTextureLinear: gl.getExtension('OES_texture_float_linear'),\n                textureHalfFloat: gl.getExtension('OES_texture_half_float'),\n                textureHalfFloatLinear: gl.getExtension('OES_texture_half_float_linear'),\n                vertexAttribDivisorANGLE: gl.getExtension('ANGLE_instanced_arrays'),\n                srgb: gl.getExtension('EXT_sRGB'),\n            };\n        }\n        else\n        {\n            this.extensions = {\n                ...common,\n                colorBufferFloat: gl.getExtension('EXT_color_buffer_float'),\n            };\n\n            const provokeExt = gl.getExtension('WEBGL_provoking_vertex');\n\n            if (provokeExt)\n            {\n                provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);\n            }\n        }\n    }\n\n    /**\n     * Handles a lost webgl context\n     * @param {WebGLContextEvent} event - The context lost event.\n     */\n    protected handleContextLost(event: WebGLContextEvent): void\n    {\n        event.preventDefault();\n\n        // only restore if we purposefully nuked it\n        if (this._contextLossForced)\n        {\n            this._contextLossForced = false;\n            // Restore the context after this event has exited\n            setTimeout(() =>\n            {\n                if (this.gl.isContextLost())\n                {\n                    this.extensions.loseContext?.restoreContext();\n                }\n            }, 0);\n        }\n    }\n\n    /** Handles a restored webgl context. */\n    protected handleContextRestored(): void\n    {\n        this._renderer.runners.contextChange.emit(this.gl);\n    }\n\n    public destroy(): void\n    {\n        const element = this._renderer.view.canvas;\n\n        this._renderer = null;\n\n        // remove listeners\n        (element as any).removeEventListener('webglcontextlost', this.handleContextLost);\n        element.removeEventListener('webglcontextrestored', this.handleContextRestored);\n\n        this.gl.useProgram(null);\n\n        this.extensions.loseContext?.loseContext();\n    }\n\n    /**\n     * this function can be called to force a webGL context loss\n     * this will release all resources on the GPU.\n     * Useful if you need to put Pixi to sleep, and save some GPU memory\n     *\n     * As soon as render is called - all resources will be created again.\n     */\n    public forceContextLoss(): void\n    {\n        this.extensions.loseContext?.loseContext();\n        this._contextLossForced = true;\n    }\n    /**\n     * Validate context.\n     * @param {WebGLRenderingContext} gl - Render context.\n     */\n    protected validateContext(gl: WebGL2RenderingContext): void\n    {\n        const attributes = gl.getContextAttributes();\n\n        // this is going to be fairly simple for now.. but at least we have room to grow!\n        if (attributes && !attributes.stencil)\n        {\n            // #if _DEBUG\n            /* eslint-disable max-len, no-console */\n            warn('Provided WebGL context does not have a stencil buffer, masks may not render correctly');\n            /* eslint-enable max-len, no-console */\n            // #endif\n        }\n\n        // support\n        const supports = this.supports;\n\n        const isWebGl2 = this.webGLVersion === 2;\n        const extensions = this.extensions;\n\n        supports.uint32Indices = isWebGl2 || !!extensions.uint32ElementIndex;\n        supports.uniformBufferObject = isWebGl2;\n        supports.vertexArrayObject = isWebGl2 || !!extensions.vertexArrayObject;\n        supports.srgbTextures = isWebGl2 || !!extensions.srgb;\n        supports.nonPowOf2wrapping = isWebGl2;\n        supports.nonPowOf2mipmaps = isWebGl2;\n        supports.msaa = isWebGl2;\n\n        if (!supports.uint32Indices)\n        {\n            // #if _DEBUG\n            /* eslint-disable max-len, no-console */\n            warn('Provided WebGL context does not support 32 index buffer, large scenes may not render correctly');\n            /* eslint-enable max-len, no-console */\n            // #endif\n        }\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { getAttributeInfoFromFormat } from '../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\nimport { ensureAttributes } from '../shader/program/ensureAttributes.mjs';\nimport { getGlTypeFromFormat } from './utils/getGlTypeFromFormat.mjs';\n\n\"use strict\";\nconst topologyToGlMap = {\n  \"point-list\": 0,\n  \"line-list\": 1,\n  \"line-strip\": 3,\n  \"triangle-list\": 4,\n  \"triangle-strip\": 5\n};\nclass GlGeometrySystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._geometryVaoHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    this._activeGeometry = null;\n    this._activeVao = null;\n    this.hasVao = true;\n    this.hasInstance = true;\n  }\n  /** Sets up the renderer context and necessary buffers. */\n  contextChange() {\n    const gl = this.gl = this._renderer.gl;\n    if (!this._renderer.context.supports.vertexArrayObject) {\n      throw new Error(\"[PixiJS] Vertex Array Objects are not supported on this device\");\n    }\n    const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;\n    if (nativeVaoExtension) {\n      gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();\n      gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);\n      gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);\n    }\n    const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;\n    if (nativeInstancedExtension) {\n      gl.drawArraysInstanced = (a, b, c, d) => {\n        nativeInstancedExtension.drawArraysInstancedANGLE(a, b, c, d);\n      };\n      gl.drawElementsInstanced = (a, b, c, d, e) => {\n        nativeInstancedExtension.drawElementsInstancedANGLE(a, b, c, d, e);\n      };\n      gl.vertexAttribDivisor = (a, b) => nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);\n    }\n    this._activeGeometry = null;\n    this._activeVao = null;\n    this._geometryVaoHash = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Binds geometry so that is can be drawn. Creating a Vao if required\n   * @param geometry - Instance of geometry to bind.\n   * @param program - Instance of program to use vao for.\n   */\n  bind(geometry, program) {\n    const gl = this.gl;\n    this._activeGeometry = geometry;\n    const vao = this.getVao(geometry, program);\n    if (this._activeVao !== vao) {\n      this._activeVao = vao;\n      gl.bindVertexArray(vao);\n    }\n    this.updateBuffers();\n  }\n  /** Reset and unbind any active VAO and geometry. */\n  reset() {\n    this.unbind();\n  }\n  /** Update buffers of the currently bound geometry. */\n  updateBuffers() {\n    const geometry = this._activeGeometry;\n    const bufferSystem = this._renderer.buffer;\n    for (let i = 0; i < geometry.buffers.length; i++) {\n      const buffer = geometry.buffers[i];\n      bufferSystem.updateBuffer(buffer);\n    }\n  }\n  /**\n   * Check compatibility between a geometry and a program\n   * @param geometry - Geometry instance.\n   * @param program - Program instance.\n   */\n  checkCompatibility(geometry, program) {\n    const geometryAttributes = geometry.attributes;\n    const shaderAttributes = program._attributeData;\n    for (const j in shaderAttributes) {\n      if (!geometryAttributes[j]) {\n        throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n      }\n    }\n  }\n  /**\n   * Takes a geometry and program and generates a unique signature for them.\n   * @param geometry - To get signature from.\n   * @param program - To test geometry against.\n   * @returns - Unique signature of the geometry and program\n   */\n  getSignature(geometry, program) {\n    const attribs = geometry.attributes;\n    const shaderAttributes = program._attributeData;\n    const strings = [\"g\", geometry.uid];\n    for (const i in attribs) {\n      if (shaderAttributes[i]) {\n        strings.push(i, shaderAttributes[i].location);\n      }\n    }\n    return strings.join(\"-\");\n  }\n  getVao(geometry, program) {\n    return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);\n  }\n  /**\n   * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n   * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n   * attribute locations.\n   * @param geometry - Instance of geometry to to generate Vao for.\n   * @param program\n   * @param _incRefCount - Increment refCount of all geometry buffers.\n   */\n  initGeometryVao(geometry, program, _incRefCount = true) {\n    const gl = this._renderer.gl;\n    const bufferSystem = this._renderer.buffer;\n    this._renderer.shader._getProgramData(program);\n    this.checkCompatibility(geometry, program);\n    const signature = this.getSignature(geometry, program);\n    if (!this._geometryVaoHash[geometry.uid]) {\n      this._geometryVaoHash[geometry.uid] = /* @__PURE__ */ Object.create(null);\n      geometry.on(\"destroy\", this.onGeometryDestroy, this);\n    }\n    const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n    let vao = vaoObjectHash[signature];\n    if (vao) {\n      vaoObjectHash[program._key] = vao;\n      return vao;\n    }\n    ensureAttributes(geometry, program._attributeData);\n    const buffers = geometry.buffers;\n    vao = gl.createVertexArray();\n    gl.bindVertexArray(vao);\n    for (let i = 0; i < buffers.length; i++) {\n      const buffer = buffers[i];\n      bufferSystem.bind(buffer);\n    }\n    this.activateVao(geometry, program);\n    vaoObjectHash[program._key] = vao;\n    vaoObjectHash[signature] = vao;\n    gl.bindVertexArray(null);\n    return vao;\n  }\n  /**\n   * Disposes geometry.\n   * @param geometry - Geometry with buffers. Only VAO will be disposed\n   * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n   */\n  onGeometryDestroy(geometry, contextLost) {\n    const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n    const gl = this.gl;\n    if (vaoObjectHash) {\n      if (contextLost) {\n        for (const i in vaoObjectHash) {\n          if (this._activeVao !== vaoObjectHash[i]) {\n            this.unbind();\n          }\n          gl.deleteVertexArray(vaoObjectHash[i]);\n        }\n      }\n      this._geometryVaoHash[geometry.uid] = null;\n    }\n  }\n  /**\n   * Dispose all WebGL resources of all managed geometries.\n   * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n   */\n  destroyAll(contextLost = false) {\n    const gl = this.gl;\n    for (const i in this._geometryVaoHash) {\n      if (contextLost) {\n        for (const j in this._geometryVaoHash[i]) {\n          const vaoObjectHash = this._geometryVaoHash[i];\n          if (this._activeVao !== vaoObjectHash) {\n            this.unbind();\n          }\n          gl.deleteVertexArray(vaoObjectHash[j]);\n        }\n      }\n      this._geometryVaoHash[i] = null;\n    }\n  }\n  /**\n   * Activate vertex array object.\n   * @param geometry - Geometry instance.\n   * @param program - Shader program instance.\n   */\n  activateVao(geometry, program) {\n    const gl = this._renderer.gl;\n    const bufferSystem = this._renderer.buffer;\n    const attributes = geometry.attributes;\n    if (geometry.indexBuffer) {\n      bufferSystem.bind(geometry.indexBuffer);\n    }\n    let lastBuffer = null;\n    for (const j in attributes) {\n      const attribute = attributes[j];\n      const buffer = attribute.buffer;\n      const glBuffer = bufferSystem.getGlBuffer(buffer);\n      const programAttrib = program._attributeData[j];\n      if (programAttrib) {\n        if (lastBuffer !== glBuffer) {\n          bufferSystem.bind(buffer);\n          lastBuffer = glBuffer;\n        }\n        const location = attribute.location;\n        gl.enableVertexAttribArray(location);\n        const attributeInfo = getAttributeInfoFromFormat(attribute.format);\n        const type = getGlTypeFromFormat(attribute.format);\n        if (programAttrib.format?.substring(1, 4) === \"int\") {\n          gl.vertexAttribIPointer(\n            location,\n            attributeInfo.size,\n            type,\n            attribute.stride,\n            attribute.offset\n          );\n        } else {\n          gl.vertexAttribPointer(\n            location,\n            attributeInfo.size,\n            type,\n            attributeInfo.normalised,\n            attribute.stride,\n            attribute.offset\n          );\n        }\n        if (attribute.instance) {\n          if (this.hasInstance) {\n            gl.vertexAttribDivisor(location, 1);\n          } else {\n            throw new Error(\"geometry error, GPU Instancing is not supported on this device\");\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Draws the currently bound geometry.\n   * @param topology - The type primitive to render.\n   * @param size - The number of elements to be rendered. If not specified, all vertices after the\n   *  starting vertex will be drawn.\n   * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n   *  drawing will start from the first vertex.\n   * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n   *  all instances will be drawn.\n   */\n  draw(topology, size, start, instanceCount) {\n    const { gl } = this._renderer;\n    const geometry = this._activeGeometry;\n    const glTopology = topologyToGlMap[geometry.topology || topology];\n    instanceCount || (instanceCount = geometry.instanceCount);\n    if (geometry.indexBuffer) {\n      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n      if (instanceCount > 1) {\n        gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);\n      } else {\n        gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n      }\n    } else if (instanceCount > 1) {\n      gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);\n    } else {\n      gl.drawArrays(glTopology, start || 0, size || geometry.getSize());\n    }\n    return this;\n  }\n  /** Unbind/reset everything. */\n  unbind() {\n    this.gl.bindVertexArray(null);\n    this._activeVao = null;\n    this._activeGeometry = null;\n  }\n  destroy() {\n    this._renderer = null;\n    this.gl = null;\n    this._activeVao = null;\n    this._activeGeometry = null;\n  }\n}\n/** @ignore */\nGlGeometrySystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem\n  ],\n  name: \"geometry\"\n};\n\nexport { GlGeometrySystem };\n//# sourceMappingURL=GlGeometrySystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { getAttributeInfoFromFormat } from '../../shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ensureAttributes } from '../shader/program/ensureAttributes';\nimport { getGlTypeFromFormat } from './utils/getGlTypeFromFormat';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { GlProgram } from '../shader/GlProgram';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\nconst topologyToGlMap = {\n    'point-list': 0x0000,\n    'line-list': 0x0001,\n    'line-strip': 0x0003,\n    'triangle-list': 0x0004,\n    'triangle-strip': 0x0005\n};\n\n/**\n * System plugin to the renderer to manage geometry.\n * @memberof rendering\n */\nexport class GlGeometrySystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'geometry',\n    } as const;\n\n    /**\n     * `true` if we has `*_vertex_array_object` extension.\n     * @readonly\n     */\n    public hasVao: boolean;\n\n    /**\n     * `true` if has `ANGLE_instanced_arrays` extension.\n     * @readonly\n     */\n    public hasInstance: boolean;\n\n    protected gl: GlRenderingContext;\n    protected _activeGeometry: Geometry;\n    protected _activeVao: WebGLVertexArrayObject;\n\n    protected _geometryVaoHash: Record<number, Record<string, WebGLVertexArrayObject>> = Object.create(null);\n\n    /** Renderer that owns this {@link GeometrySystem}. */\n    private _renderer: WebGLRenderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n        this._activeGeometry = null;\n        this._activeVao = null;\n\n        this.hasVao = true;\n        this.hasInstance = true;\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        const gl = this.gl = this._renderer.gl;\n\n        if (!this._renderer.context.supports.vertexArrayObject)\n        {\n            throw new Error('[PixiJS] Vertex Array Objects are not supported on this device');\n        }\n\n        const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;\n\n        if (nativeVaoExtension)\n        {\n            gl.createVertexArray = (): WebGLVertexArrayObject =>\n                nativeVaoExtension.createVertexArrayOES();\n\n            gl.bindVertexArray = (vao): void =>\n                nativeVaoExtension.bindVertexArrayOES(vao);\n\n            gl.deleteVertexArray = (vao): void =>\n                nativeVaoExtension.deleteVertexArrayOES(vao);\n        }\n\n        const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;\n\n        if (nativeInstancedExtension)\n        {\n            gl.drawArraysInstanced = (a, b, c, d): void =>\n            {\n                nativeInstancedExtension.drawArraysInstancedANGLE(a, b, c, d);\n            };\n\n            gl.drawElementsInstanced = (a, b, c, d, e): void =>\n            {\n                nativeInstancedExtension.drawElementsInstancedANGLE(a, b, c, d, e);\n            };\n\n            gl.vertexAttribDivisor = (a, b): void =>\n                nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);\n        }\n\n        this._activeGeometry = null;\n        this._activeVao = null;\n        this._geometryVaoHash = Object.create(null);\n    }\n\n    /**\n     * Binds geometry so that is can be drawn. Creating a Vao if required\n     * @param geometry - Instance of geometry to bind.\n     * @param program - Instance of program to use vao for.\n     */\n    public bind(geometry?: Geometry, program?: GlProgram): void\n    {\n        // shader = shader || this.renderer.shader.shader;\n\n        const gl = this.gl;\n\n        this._activeGeometry = geometry;\n\n        const vao = this.getVao(geometry, program);\n\n        if (this._activeVao !== vao)\n        {\n            this._activeVao = vao;\n\n            gl.bindVertexArray(vao);\n        }\n\n        this.updateBuffers();\n    }\n\n    /** Reset and unbind any active VAO and geometry. */\n    public reset(): void\n    {\n        this.unbind();\n    }\n\n    /** Update buffers of the currently bound geometry. */\n    public updateBuffers(): void\n    {\n        const geometry = this._activeGeometry;\n\n        const bufferSystem = this._renderer.buffer;\n\n        for (let i = 0; i < geometry.buffers.length; i++)\n        {\n            const buffer = geometry.buffers[i];\n\n            bufferSystem.updateBuffer(buffer);\n        }\n    }\n\n    /**\n     * Check compatibility between a geometry and a program\n     * @param geometry - Geometry instance.\n     * @param program - Program instance.\n     */\n    protected checkCompatibility(geometry: Geometry, program: GlProgram): void\n    {\n        // geometry must have at least all the attributes that the shader requires.\n        const geometryAttributes = geometry.attributes;\n        const shaderAttributes = program._attributeData;\n\n        for (const j in shaderAttributes)\n        {\n            if (!geometryAttributes[j])\n            {\n                throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n            }\n        }\n    }\n\n    /**\n     * Takes a geometry and program and generates a unique signature for them.\n     * @param geometry - To get signature from.\n     * @param program - To test geometry against.\n     * @returns - Unique signature of the geometry and program\n     */\n    protected getSignature(geometry: Geometry, program: GlProgram): string\n    {\n        const attribs = geometry.attributes;\n        const shaderAttributes = program._attributeData;\n\n        const strings = ['g', geometry.uid];\n\n        for (const i in attribs)\n        {\n            if (shaderAttributes[i])\n            {\n                strings.push(i, shaderAttributes[i].location);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    protected getVao(geometry: Geometry, program: GlProgram): WebGLVertexArrayObject\n    {\n        return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);\n    }\n\n    /**\n     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n     * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n     * attribute locations.\n     * @param geometry - Instance of geometry to to generate Vao for.\n     * @param program\n     * @param _incRefCount - Increment refCount of all geometry buffers.\n     */\n    protected initGeometryVao(geometry: Geometry, program: GlProgram, _incRefCount = true): WebGLVertexArrayObject\n    {\n        const gl = this._renderer.gl;\n        // const CONTEXT_UID = this.CONTEXT_UID;\n        const bufferSystem = this._renderer.buffer;\n\n        this._renderer.shader._getProgramData(program);\n\n        this.checkCompatibility(geometry, program);\n\n        const signature = this.getSignature(geometry, program);\n\n        if (!this._geometryVaoHash[geometry.uid])\n        {\n            this._geometryVaoHash[geometry.uid] = Object.create(null);\n\n            geometry.on('destroy', this.onGeometryDestroy, this);\n        }\n\n        const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n\n        let vao = vaoObjectHash[signature];\n\n        if (vao)\n        {\n            // this will give us easy access to the vao\n            vaoObjectHash[program._key] = vao;\n\n            return vao;\n        }\n\n        ensureAttributes(geometry, program._attributeData);\n\n        const buffers = geometry.buffers;\n\n        // @TODO: We don't know if VAO is supported.\n        vao = gl.createVertexArray();\n\n        gl.bindVertexArray(vao);\n\n        // first update - and create the buffers!\n        // only create a gl buffer if it actually gets\n        for (let i = 0; i < buffers.length; i++)\n        {\n            const buffer = buffers[i];\n\n            bufferSystem.bind(buffer);\n        }\n\n        // TODO - maybe make this a data object?\n        // lets wait to see if we need to first!\n\n        this.activateVao(geometry, program);\n\n        // add it to the cache!\n        vaoObjectHash[program._key] = vao;\n        vaoObjectHash[signature] = vao;\n\n        gl.bindVertexArray(null);\n\n        return vao;\n    }\n\n    /**\n     * Disposes geometry.\n     * @param geometry - Geometry with buffers. Only VAO will be disposed\n     * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    protected onGeometryDestroy(geometry: Geometry, contextLost?: boolean): void\n    {\n        const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n\n        const gl = this.gl;\n\n        if (vaoObjectHash)\n        {\n            if (contextLost)\n            {\n                for (const i in vaoObjectHash)\n                {\n                    if (this._activeVao !== vaoObjectHash[i])\n                    {\n                        this.unbind();\n                    }\n\n                    gl.deleteVertexArray(vaoObjectHash[i]);\n                }\n            }\n\n            this._geometryVaoHash[geometry.uid] = null;\n        }\n    }\n\n    /**\n     * Dispose all WebGL resources of all managed geometries.\n     * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n     */\n    public destroyAll(contextLost = false): void\n    {\n        const gl = this.gl;\n\n        for (const i in this._geometryVaoHash)\n        {\n            if (contextLost)\n            {\n                for (const j in this._geometryVaoHash[i])\n                {\n                    const vaoObjectHash = this._geometryVaoHash[i];\n\n                    if (this._activeVao !== vaoObjectHash)\n                    {\n                        this.unbind();\n                    }\n\n                    gl.deleteVertexArray(vaoObjectHash[j]);\n                }\n            }\n\n            this._geometryVaoHash[i] = null;\n        }\n    }\n\n    /**\n     * Activate vertex array object.\n     * @param geometry - Geometry instance.\n     * @param program - Shader program instance.\n     */\n    protected activateVao(geometry: Geometry, program: GlProgram): void\n    {\n        const gl = this._renderer.gl;\n\n        const bufferSystem = this._renderer.buffer;\n        const attributes = geometry.attributes;\n\n        if (geometry.indexBuffer)\n        {\n            // first update the index buffer if we have one..\n            bufferSystem.bind(geometry.indexBuffer);\n        }\n\n        let lastBuffer = null;\n\n        // add a new one!\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const buffer = attribute.buffer;\n            const glBuffer = bufferSystem.getGlBuffer(buffer);\n            const programAttrib = program._attributeData[j];\n\n            if (programAttrib)\n            {\n                if (lastBuffer !== glBuffer)\n                {\n                    bufferSystem.bind(buffer);\n\n                    lastBuffer = glBuffer;\n                }\n\n                const location = attribute.location;\n\n                // TODO introduce state again\n                // we can optimise this for older devices that have no VAOs\n                gl.enableVertexAttribArray(location);\n\n                const attributeInfo = getAttributeInfoFromFormat(attribute.format);\n\n                const type = getGlTypeFromFormat(attribute.format);\n\n                if (programAttrib.format?.substring(1, 4) === 'int')\n                {\n                    gl.vertexAttribIPointer(location,\n                        attributeInfo.size,\n                        type,\n                        attribute.stride,\n                        attribute.offset);\n                }\n                else\n                {\n                    gl.vertexAttribPointer(location,\n                        attributeInfo.size,\n                        type,\n                        attributeInfo.normalised,\n                        attribute.stride,\n                        attribute.offset);\n                }\n\n                if (attribute.instance)\n                {\n                    // TODO calculate instance count based of this...\n                    if (this.hasInstance)\n                    {\n                        gl.vertexAttribDivisor(location, 1);// attribute.divisor);\n                    }\n                    else\n                    {\n                        throw new Error('geometry error, GPU Instancing is not supported on this device');\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the currently bound geometry.\n     * @param topology - The type primitive to render.\n     * @param size - The number of elements to be rendered. If not specified, all vertices after the\n     *  starting vertex will be drawn.\n     * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n     *  all instances will be drawn.\n     */\n    public draw(topology?: Topology, size?: number, start?: number, instanceCount?: number): this\n    {\n        const { gl } = this._renderer;\n        const geometry = this._activeGeometry;\n\n        const glTopology = topologyToGlMap[geometry.topology || topology];\n\n        instanceCount ||= geometry.instanceCount;\n\n        if (geometry.indexBuffer)\n        {\n            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n            if (instanceCount > 1)\n            {\n                /* eslint-disable max-len */\n                gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);\n                /* eslint-enable max-len */\n            }\n            else\n            {\n                /* eslint-disable max-len */\n                gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n                /* eslint-enable max-len */\n            }\n        }\n        else if (instanceCount > 1)\n        {\n            // TODO need a better way to calculate size..\n            gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);\n        }\n        else\n        {\n            gl.drawArrays(glTopology, start || 0, size || geometry.getSize());\n        }\n\n        return this;\n    }\n\n    /** Unbind/reset everything. */\n    protected unbind(): void\n    {\n        this.gl.bindVertexArray(null);\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this.gl = null;\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n}\n","import { GL_TYPES } from '../../texture/const.mjs';\n\n\"use strict\";\nconst infoMap = {\n  uint8x2: GL_TYPES.UNSIGNED_BYTE,\n  uint8x4: GL_TYPES.UNSIGNED_BYTE,\n  sint8x2: GL_TYPES.BYTE,\n  sint8x4: GL_TYPES.BYTE,\n  unorm8x2: GL_TYPES.UNSIGNED_BYTE,\n  unorm8x4: GL_TYPES.UNSIGNED_BYTE,\n  snorm8x2: GL_TYPES.BYTE,\n  snorm8x4: GL_TYPES.BYTE,\n  uint16x2: GL_TYPES.UNSIGNED_SHORT,\n  uint16x4: GL_TYPES.UNSIGNED_SHORT,\n  sint16x2: GL_TYPES.SHORT,\n  sint16x4: GL_TYPES.SHORT,\n  unorm16x2: GL_TYPES.UNSIGNED_SHORT,\n  unorm16x4: GL_TYPES.UNSIGNED_SHORT,\n  snorm16x2: GL_TYPES.SHORT,\n  snorm16x4: GL_TYPES.SHORT,\n  float16x2: GL_TYPES.HALF_FLOAT,\n  float16x4: GL_TYPES.HALF_FLOAT,\n  float32: GL_TYPES.FLOAT,\n  float32x2: GL_TYPES.FLOAT,\n  float32x3: GL_TYPES.FLOAT,\n  float32x4: GL_TYPES.FLOAT,\n  uint32: GL_TYPES.UNSIGNED_INT,\n  uint32x2: GL_TYPES.UNSIGNED_INT,\n  uint32x3: GL_TYPES.UNSIGNED_INT,\n  uint32x4: GL_TYPES.UNSIGNED_INT,\n  sint32: GL_TYPES.INT,\n  sint32x2: GL_TYPES.INT,\n  sint32x3: GL_TYPES.INT,\n  sint32x4: GL_TYPES.INT\n};\nfunction getGlTypeFromFormat(format) {\n  return infoMap[format] ?? infoMap.float32;\n}\n\nexport { getGlTypeFromFormat };\n//# sourceMappingURL=getGlTypeFromFormat.mjs.map\n","import { GL_TYPES } from '../../texture/const';\n\nimport type { VertexFormat } from '../../../shared/geometry/const';\n\nconst infoMap = {\n    uint8x2: GL_TYPES.UNSIGNED_BYTE,\n    uint8x4: GL_TYPES.UNSIGNED_BYTE,\n    sint8x2: GL_TYPES.BYTE,\n    sint8x4: GL_TYPES.BYTE,\n    unorm8x2: GL_TYPES.UNSIGNED_BYTE,\n    unorm8x4: GL_TYPES.UNSIGNED_BYTE,\n    snorm8x2: GL_TYPES.BYTE,\n    snorm8x4: GL_TYPES.BYTE,\n    uint16x2: GL_TYPES.UNSIGNED_SHORT,\n    uint16x4: GL_TYPES.UNSIGNED_SHORT,\n    sint16x2: GL_TYPES.SHORT,\n    sint16x4: GL_TYPES.SHORT,\n    unorm16x2: GL_TYPES.UNSIGNED_SHORT,\n    unorm16x4: GL_TYPES.UNSIGNED_SHORT,\n    snorm16x2: GL_TYPES.SHORT,\n    snorm16x4: GL_TYPES.SHORT,\n    float16x2: GL_TYPES.HALF_FLOAT,\n    float16x4: GL_TYPES.HALF_FLOAT,\n    float32: GL_TYPES.FLOAT,\n    float32x2: GL_TYPES.FLOAT,\n    float32x3: GL_TYPES.FLOAT,\n    float32x4: GL_TYPES.FLOAT,\n    uint32: GL_TYPES.UNSIGNED_INT,\n    uint32x2: GL_TYPES.UNSIGNED_INT,\n    uint32x3: GL_TYPES.UNSIGNED_INT,\n    uint32x4: GL_TYPES.UNSIGNED_INT,\n    sint32: GL_TYPES.INT,\n    sint32x2: GL_TYPES.INT,\n    sint32x3: GL_TYPES.INT,\n    sint32x4: GL_TYPES.INT\n};\n\nexport function getGlTypeFromFormat(format: VertexFormat): number\n{\n    return infoMap[format] ?? infoMap.float32;\n}\n","\"use strict\";\nvar GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {\n  GL_FORMATS2[GL_FORMATS2[\"RGBA\"] = 6408] = \"RGBA\";\n  GL_FORMATS2[GL_FORMATS2[\"RGB\"] = 6407] = \"RGB\";\n  GL_FORMATS2[GL_FORMATS2[\"RG\"] = 33319] = \"RG\";\n  GL_FORMATS2[GL_FORMATS2[\"RED\"] = 6403] = \"RED\";\n  GL_FORMATS2[GL_FORMATS2[\"RGBA_INTEGER\"] = 36249] = \"RGBA_INTEGER\";\n  GL_FORMATS2[GL_FORMATS2[\"RGB_INTEGER\"] = 36248] = \"RGB_INTEGER\";\n  GL_FORMATS2[GL_FORMATS2[\"RG_INTEGER\"] = 33320] = \"RG_INTEGER\";\n  GL_FORMATS2[GL_FORMATS2[\"RED_INTEGER\"] = 36244] = \"RED_INTEGER\";\n  GL_FORMATS2[GL_FORMATS2[\"ALPHA\"] = 6406] = \"ALPHA\";\n  GL_FORMATS2[GL_FORMATS2[\"LUMINANCE\"] = 6409] = \"LUMINANCE\";\n  GL_FORMATS2[GL_FORMATS2[\"LUMINANCE_ALPHA\"] = 6410] = \"LUMINANCE_ALPHA\";\n  GL_FORMATS2[GL_FORMATS2[\"DEPTH_COMPONENT\"] = 6402] = \"DEPTH_COMPONENT\";\n  GL_FORMATS2[GL_FORMATS2[\"DEPTH_STENCIL\"] = 34041] = \"DEPTH_STENCIL\";\n  return GL_FORMATS2;\n})(GL_FORMATS || {});\nvar GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {\n  GL_TARGETS2[GL_TARGETS2[\"TEXTURE_2D\"] = 3553] = \"TEXTURE_2D\";\n  GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP\"] = 34067] = \"TEXTURE_CUBE_MAP\";\n  GL_TARGETS2[GL_TARGETS2[\"TEXTURE_2D_ARRAY\"] = 35866] = \"TEXTURE_2D_ARRAY\";\n  GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_X\"] = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\";\n  GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_X\"] = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\";\n  GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_Y\"] = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\";\n  GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_Y\"] = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\";\n  GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP_POSITIVE_Z\"] = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\";\n  GL_TARGETS2[GL_TARGETS2[\"TEXTURE_CUBE_MAP_NEGATIVE_Z\"] = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n  return GL_TARGETS2;\n})(GL_TARGETS || {});\nvar GL_WRAP_MODES = /* @__PURE__ */ ((GL_WRAP_MODES2) => {\n  GL_WRAP_MODES2[GL_WRAP_MODES2[\"CLAMP\"] = 33071] = \"CLAMP\";\n  GL_WRAP_MODES2[GL_WRAP_MODES2[\"REPEAT\"] = 10497] = \"REPEAT\";\n  GL_WRAP_MODES2[GL_WRAP_MODES2[\"MIRRORED_REPEAT\"] = 33648] = \"MIRRORED_REPEAT\";\n  return GL_WRAP_MODES2;\n})(GL_WRAP_MODES || {});\nvar GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_BYTE\"] = 5121] = \"UNSIGNED_BYTE\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_SHORT\"] = 5123] = \"UNSIGNED_SHORT\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_SHORT_5_6_5\"] = 33635] = \"UNSIGNED_SHORT_5_6_5\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_SHORT_4_4_4_4\"] = 32819] = \"UNSIGNED_SHORT_4_4_4_4\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_SHORT_5_5_5_1\"] = 32820] = \"UNSIGNED_SHORT_5_5_5_1\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT\"] = 5125] = \"UNSIGNED_INT\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT_10F_11F_11F_REV\"] = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT_2_10_10_10_REV\"] = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT_24_8\"] = 34042] = \"UNSIGNED_INT_24_8\";\n  GL_TYPES2[GL_TYPES2[\"UNSIGNED_INT_5_9_9_9_REV\"] = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\";\n  GL_TYPES2[GL_TYPES2[\"BYTE\"] = 5120] = \"BYTE\";\n  GL_TYPES2[GL_TYPES2[\"SHORT\"] = 5122] = \"SHORT\";\n  GL_TYPES2[GL_TYPES2[\"INT\"] = 5124] = \"INT\";\n  GL_TYPES2[GL_TYPES2[\"FLOAT\"] = 5126] = \"FLOAT\";\n  GL_TYPES2[GL_TYPES2[\"FLOAT_32_UNSIGNED_INT_24_8_REV\"] = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\";\n  GL_TYPES2[GL_TYPES2[\"HALF_FLOAT\"] = 36193] = \"HALF_FLOAT\";\n  return GL_TYPES2;\n})(GL_TYPES || {});\n\nexport { GL_FORMATS, GL_TARGETS, GL_TYPES, GL_WRAP_MODES };\n//# sourceMappingURL=const.mjs.map\n","/**\n * Various GL texture/resources formats.\n * @static\n * @name FORMATS\n * @enum {number}\n * @property {number} [RGBA=6408] -\n * @property {number} [RGB=6407] -\n * @property {number} [RG=33319] -\n * @property {number} [RED=6403] -\n * @property {number} [RGBA_INTEGER=36249] -\n * @property {number} [RGB_INTEGER=36248] -\n * @property {number} [RG_INTEGER=33320] -\n * @property {number} [RED_INTEGER=36244] -\n * @property {number} [ALPHA=6406] -\n * @property {number} [LUMINANCE=6409] -\n * @property {number} [LUMINANCE_ALPHA=6410] -\n * @property {number} [DEPTH_COMPONENT=6402] -\n * @property {number} [DEPTH_STENCIL=34041] -\n */\nexport enum GL_FORMATS\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    RGBA = 6408,\n    RGB = 6407,\n    RG = 33319,\n    RED = 6403,\n    RGBA_INTEGER = 36249,\n    RGB_INTEGER = 36248,\n    RG_INTEGER = 33320,\n    RED_INTEGER = 36244,\n    ALPHA = 6406,\n    LUMINANCE = 6409,\n    LUMINANCE_ALPHA = 6410,\n    DEPTH_COMPONENT = 6402,\n    DEPTH_STENCIL = 34041,\n}\n\n/**\n * Various GL target types.\n * @static\n * @name TARGETS\n * @enum {number}\n * @property {number} [TEXTURE_2D=3553] -\n * @property {number} [TEXTURE_CUBE_MAP=34067] -\n * @property {number} [TEXTURE_2D_ARRAY=35866] -\n * @property {number} [TEXTURE_CUBE_MAP_POSITIVE_X=34069] -\n * @property {number} [TEXTURE_CUBE_MAP_NEGATIVE_X=34070] -\n * @property {number} [TEXTURE_CUBE_MAP_POSITIVE_Y=34071] -\n * @property {number} [TEXTURE_CUBE_MAP_NEGATIVE_Y=34072] -\n * @property {number} [TEXTURE_CUBE_MAP_POSITIVE_Z=34073] -\n * @property {number} [TEXTURE_CUBE_MAP_NEGATIVE_Z=34074] -\n */\nexport enum GL_TARGETS\n    // eslint-disable-next-line @typescript-eslint/indent\n {\n    TEXTURE_2D = 3553,\n    TEXTURE_CUBE_MAP = 34067,\n    TEXTURE_2D_ARRAY = 35866,\n    TEXTURE_CUBE_MAP_POSITIVE_X = 34069,\n    TEXTURE_CUBE_MAP_NEGATIVE_X = 34070,\n    TEXTURE_CUBE_MAP_POSITIVE_Y = 34071,\n    TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072,\n    TEXTURE_CUBE_MAP_POSITIVE_Z = 34073,\n    TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074,\n}\n\n/**\n * The wrap modes that are supported by pixi.\n *\n * The {@link settings.WRAP_MODE} wrap mode affects the default wrapping mode of future operations.\n * It can be re-assigned to either CLAMP or REPEAT, depending upon suitability.\n * If the texture is non power of two then clamp will be used regardless as WebGL can\n * only use REPEAT if the texture is po2.\n *\n * This property only affects WebGL.\n * @name WRAP_MODES\n * @static\n * @enum {number}\n * @property {number} CLAMP - The textures uvs are clamped\n * @property {number} REPEAT - The texture uvs tile and repeat\n * @property {number} MIRRORED_REPEAT - The texture uvs tile and repeat with mirroring\n */\nexport enum GL_WRAP_MODES\n    // eslint-disable-next-line @typescript-eslint/indent\n {\n    CLAMP = 33071,\n    REPEAT = 10497,\n    MIRRORED_REPEAT = 33648,\n}\n\nexport enum GL_TYPES\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /**\n     * 8 bits per channel for gl.RGBA\n     * @default 5121\n     */\n    UNSIGNED_BYTE = 5121,\n    /**\n     * @default 5123\n     */\n    UNSIGNED_SHORT = 5123,\n    /**\n     * 5 red bits, 6 green bits, 5 blue bits.\n     * @default 33635\n     */\n    UNSIGNED_SHORT_5_6_5 = 33635,\n    /**\n     * 4 red bits, 4 green bits, 4 blue bits, 4 alpha bits.\n     * @default 32819\n     */\n    UNSIGNED_SHORT_4_4_4_4 = 32819,\n    /**\n     * 5 red bits, 5 green bits, 5 blue bits, 1 alpha bit.\n     * @default 32820\n     */\n    UNSIGNED_SHORT_5_5_5_1 = 32820,\n    /**\n     * @default 5125\n     */\n    UNSIGNED_INT = 5125,\n    /**\n     * @default 35899\n     */\n    UNSIGNED_INT_10F_11F_11F_REV = 35899,\n    /**\n     * @default 33640\n     */\n    UNSIGNED_INT_2_10_10_10_REV = 33640,\n    /**\n     * @default 34042\n     */\n    UNSIGNED_INT_24_8 = 34042,\n    /**\n     * @default 35902\n     */\n    UNSIGNED_INT_5_9_9_9_REV = 35902,\n    /**\n     * @default 5120\n     */\n    BYTE = 5120,\n    /**\n     * @default 5122\n     */\n    SHORT = 5122,\n    /**\n     * @default 5124\n     */\n    INT = 5124,\n    /**\n     * @default 5126\n     */\n    FLOAT = 5126,\n    /**\n     * @default 36269\n     */\n    FLOAT_32_UNSIGNED_INT_24_8_REV = 36269,\n    /**\n     * @default 36193\n     */\n    HALF_FLOAT = 36193,\n}\n\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\nimport { Geometry } from '../shared/geometry/Geometry.mjs';\nimport { Shader } from '../shared/shader/Shader.mjs';\nimport { State } from '../shared/state/State.mjs';\nimport { TextureSource } from '../shared/texture/sources/TextureSource.mjs';\nimport { Texture } from '../shared/texture/Texture.mjs';\nimport { GlProgram } from './shader/GlProgram.mjs';\n\n\"use strict\";\nconst bigTriangleGeometry = new Geometry({\n  attributes: {\n    aPosition: [\n      -1,\n      -1,\n      // Bottom left corner\n      3,\n      -1,\n      // Bottom right corner, extending beyond right edge\n      -1,\n      3\n      // Top left corner, extending beyond top edge\n    ]\n  }\n});\nconst _GlBackBufferSystem = class _GlBackBufferSystem {\n  constructor(renderer) {\n    /** if true, the back buffer is used */\n    this.useBackBuffer = false;\n    this._useBackBufferThisRender = false;\n    this._renderer = renderer;\n  }\n  init(options = {}) {\n    const { useBackBuffer, antialias } = { ..._GlBackBufferSystem.defaultOptions, ...options };\n    this.useBackBuffer = useBackBuffer;\n    this._antialias = antialias;\n    if (!this._renderer.context.supports.msaa) {\n      warn(\"antialiasing, is not supported on when using the back buffer\");\n      this._antialias = false;\n    }\n    this._state = State.for2d();\n    const bigTriangleProgram = new GlProgram({\n      vertex: `\n                attribute vec2 aPosition;\n                out vec2 vUv;\n\n                void main() {\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n\n                    vUv = (aPosition + 1.0) / 2.0;\n\n                    // flip dem UVs\n                    vUv.y = 1.0 - vUv.y;\n                }`,\n      fragment: `\n                in vec2 vUv;\n                out vec4 finalColor;\n\n                uniform sampler2D uTexture;\n\n                void main() {\n                    finalColor = texture(uTexture, vUv);\n                }`,\n      name: \"big-triangle\"\n    });\n    this._bigTriangleShader = new Shader({\n      glProgram: bigTriangleProgram,\n      resources: {\n        uTexture: Texture.WHITE.source\n      }\n    });\n  }\n  /**\n   * This is called before the RenderTargetSystem is started. This is where\n   * we replace the target with the back buffer if required.\n   * @param options - The options for this render.\n   */\n  renderStart(options) {\n    const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);\n    this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;\n    if (this._useBackBufferThisRender) {\n      const renderTarget2 = this._renderer.renderTarget.getRenderTarget(options.target);\n      this._targetTexture = renderTarget2.colorTexture;\n      options.target = this._getBackBufferTexture(renderTarget2.colorTexture);\n    }\n  }\n  renderEnd() {\n    this._presentBackBuffer();\n  }\n  _presentBackBuffer() {\n    const renderer = this._renderer;\n    renderer.renderTarget.finishRenderPass();\n    if (!this._useBackBufferThisRender)\n      return;\n    renderer.renderTarget.bind(this._targetTexture, false);\n    this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;\n    renderer.encoder.draw({\n      geometry: bigTriangleGeometry,\n      shader: this._bigTriangleShader,\n      state: this._state\n    });\n  }\n  _getBackBufferTexture(targetSourceTexture) {\n    this._backBufferTexture = this._backBufferTexture || new Texture({\n      source: new TextureSource({\n        width: targetSourceTexture.width,\n        height: targetSourceTexture.height,\n        resolution: targetSourceTexture._resolution,\n        antialias: this._antialias\n      })\n    });\n    this._backBufferTexture.source.resize(\n      targetSourceTexture.width,\n      targetSourceTexture.height,\n      targetSourceTexture._resolution\n    );\n    return this._backBufferTexture;\n  }\n  /** destroys the back buffer */\n  destroy() {\n    if (this._backBufferTexture) {\n      this._backBufferTexture.destroy();\n      this._backBufferTexture = null;\n    }\n  }\n};\n/** @ignore */\n_GlBackBufferSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem\n  ],\n  name: \"backBuffer\",\n  priority: 1\n};\n/** default options for the back buffer system */\n_GlBackBufferSystem.defaultOptions = {\n  /** if true will use the back buffer where required */\n  useBackBuffer: false\n};\nlet GlBackBufferSystem = _GlBackBufferSystem;\n\nexport { GlBackBufferSystem };\n//# sourceMappingURL=GlBackBufferSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { warn } from '../../../utils/logging/warn';\nimport { Geometry } from '../shared/geometry/Geometry';\nimport { Shader } from '../shared/shader/Shader';\nimport { State } from '../shared/state/State';\nimport { TextureSource } from '../shared/texture/sources/TextureSource';\nimport { Texture } from '../shared/texture/Texture';\nimport { GlProgram } from './shader/GlProgram';\n\nimport type { RenderOptions } from '../shared/system/AbstractRenderer';\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\nconst bigTriangleGeometry = new Geometry({\n    attributes: {\n        aPosition: [\n            -1.0, -1.0, // Bottom left corner\n            3.0, -1.0, // Bottom right corner, extending beyond right edge\n            -1.0, 3.0 // Top left corner, extending beyond top edge\n        ],\n    },\n});\n\n/**\n * The options for the back buffer system.\n * @memberof rendering\n * @property {boolean} [useBackBuffer=false] - if true will use the back buffer where required\n * @property {boolean} [antialias=false] - if true will ensure the texture is antialiased\n */\nexport interface GlBackBufferOptions\n{\n    /**\n     * if true will use the back buffer where required\n     * @default false\n     * @memberof rendering.WebGLOptions\n     */\n    useBackBuffer?: boolean;\n    /** if true will ensure the texture is antialiased */\n    antialias?: boolean;\n}\n\n/**\n * For blend modes you need to know what pixels you are actually drawing to. For this to be possible in WebGL\n * we need to render to a texture and then present that texture to the screen. This system manages that process.\n *\n * As the main scene is rendered to a texture, it means we can sample it anc copy its pixels,\n * something not possible on the main canvas.\n *\n * If antialiasing is set to to true and useBackBuffer is set to true, then the back buffer will be antialiased.\n * and the main gl context will not.\n *\n * You only need to activate this back buffer if you are using a blend mode that requires it.\n *\n * to activate is simple, you pass `useBackBuffer:true` to your render options\n * @memberof rendering\n */\nexport class GlBackBufferSystem implements System<GlBackBufferOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'backBuffer',\n        priority: 1\n    } as const;\n\n    /** default options for the back buffer system */\n    public static defaultOptions: GlBackBufferOptions = {\n        /** if true will use the back buffer where required */\n        useBackBuffer: false,\n    };\n\n    /** if true, the back buffer is used */\n    public useBackBuffer = false;\n\n    private _backBufferTexture: Texture;\n    private readonly _renderer: WebGLRenderer;\n    private _targetTexture: TextureSource;\n    private _useBackBufferThisRender = false;\n    private _antialias: boolean;\n    private _state: State;\n    private _bigTriangleShader: Shader;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public init(options: GlBackBufferOptions = {})\n    {\n        const { useBackBuffer, antialias } = { ...GlBackBufferSystem.defaultOptions, ...options };\n\n        this.useBackBuffer = useBackBuffer;\n\n        this._antialias = antialias;\n\n        if (!this._renderer.context.supports.msaa)\n        {\n            warn('antialiasing, is not supported on when using the back buffer');\n\n            this._antialias = false;\n        }\n\n        this._state = State.for2d();\n\n        const bigTriangleProgram = new GlProgram({\n            vertex: `\n                attribute vec2 aPosition;\n                out vec2 vUv;\n\n                void main() {\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n\n                    vUv = (aPosition + 1.0) / 2.0;\n\n                    // flip dem UVs\n                    vUv.y = 1.0 - vUv.y;\n                }`,\n            fragment: `\n                in vec2 vUv;\n                out vec4 finalColor;\n\n                uniform sampler2D uTexture;\n\n                void main() {\n                    finalColor = texture(uTexture, vUv);\n                }`,\n            name: 'big-triangle',\n        });\n\n        this._bigTriangleShader = new Shader({\n            glProgram: bigTriangleProgram,\n            resources: {\n                uTexture: Texture.WHITE.source,\n            },\n        });\n    }\n\n    /**\n     * This is called before the RenderTargetSystem is started. This is where\n     * we replace the target with the back buffer if required.\n     * @param options - The options for this render.\n     */\n    protected renderStart(options: RenderOptions)\n    {\n        const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);\n\n        this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;\n\n        if (this._useBackBufferThisRender)\n        {\n            const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);\n\n            this._targetTexture = renderTarget.colorTexture;\n\n            options.target = this._getBackBufferTexture(renderTarget.colorTexture);\n        }\n    }\n\n    protected renderEnd()\n    {\n        this._presentBackBuffer();\n    }\n\n    private _presentBackBuffer()\n    {\n        const renderer = this._renderer;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (!this._useBackBufferThisRender) return;\n\n        renderer.renderTarget.bind(this._targetTexture, false);\n\n        this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;\n\n        renderer.encoder.draw({\n            geometry: bigTriangleGeometry,\n            shader: this._bigTriangleShader,\n            state: this._state,\n        });\n    }\n\n    private _getBackBufferTexture(targetSourceTexture: TextureSource)\n    {\n        this._backBufferTexture = this._backBufferTexture || new Texture({\n            source: new TextureSource({\n                width: targetSourceTexture.width,\n                height: targetSourceTexture.height,\n                resolution: targetSourceTexture._resolution,\n                antialias: this._antialias,\n            }),\n        });\n\n        // this will not resize if its the same size already! No extra check required\n        this._backBufferTexture.source.resize(\n            targetSourceTexture.width,\n            targetSourceTexture.height,\n            targetSourceTexture._resolution,\n        );\n\n        return this._backBufferTexture;\n    }\n\n    /** destroys the back buffer */\n    public destroy()\n    {\n        if (this._backBufferTexture)\n        {\n            this._backBufferTexture.destroy();\n            this._backBufferTexture = null;\n        }\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GlColorMaskSystem {\n  constructor(renderer) {\n    this._colorMaskCache = 15;\n    this._renderer = renderer;\n  }\n  setMask(colorMask) {\n    if (this._colorMaskCache === colorMask)\n      return;\n    this._colorMaskCache = colorMask;\n    this._renderer.gl.colorMask(\n      !!(colorMask & 8),\n      !!(colorMask & 4),\n      !!(colorMask & 2),\n      !!(colorMask & 1)\n    );\n  }\n}\n/** @ignore */\nGlColorMaskSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem\n  ],\n  name: \"colorMask\"\n};\n\nexport { GlColorMaskSystem };\n//# sourceMappingURL=GlColorMaskSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\n/**\n * The system that handles color masking for the WebGL.\n * @memberof rendering\n */\nexport class GlColorMaskSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: WebGLRenderer;\n    private _colorMaskCache = 0b1111;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setMask(colorMask: number)\n    {\n        if (this._colorMaskCache === colorMask) return;\n        this._colorMaskCache = colorMask;\n\n        this._renderer.gl.colorMask(\n            !!(colorMask & 0b1000),\n            !!(colorMask & 0b0100),\n            !!(colorMask & 0b0010),\n            !!(colorMask & 0b0001)\n        );\n    }\n\n    public destroy?: () => void;\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GlEncoderSystem {\n  constructor(renderer) {\n    this.commandFinished = Promise.resolve();\n    this._renderer = renderer;\n  }\n  setGeometry(geometry, shader) {\n    this._renderer.geometry.bind(geometry, shader.glProgram);\n  }\n  finishRenderPass() {\n  }\n  draw(options) {\n    const renderer = this._renderer;\n    const { geometry, shader, state, skipSync, topology: type, size, start, instanceCount } = options;\n    renderer.shader.bind(shader, skipSync);\n    renderer.geometry.bind(geometry, renderer.shader._activeProgram);\n    if (state) {\n      renderer.state.set(state);\n    }\n    renderer.geometry.draw(type, size, start, instanceCount ?? geometry.instanceCount);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGlEncoderSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem\n  ],\n  name: \"encoder\"\n};\n\nexport { GlEncoderSystem };\n//# sourceMappingURL=GlEncoderSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Topology } from '../shared/geometry/const';\nimport type { Geometry } from '../shared/geometry/Geometry';\nimport type { Shader } from '../shared/shader/Shader';\nimport type { State } from '../shared/state/State';\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\n/**\n * The system that handles encoding commands for the WebGL.\n * @memberof rendering\n */\nexport class GlEncoderSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'encoder',\n    } as const;\n\n    public readonly commandFinished = Promise.resolve();\n    private readonly _renderer: WebGLRenderer;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setGeometry(geometry: Geometry, shader?: Shader)\n    {\n        this._renderer.geometry.bind(geometry, shader.glProgram);\n    }\n\n    public finishRenderPass()\n    {\n        // noop\n    }\n\n    public draw(options: {\n        geometry: Geometry,\n        shader: Shader,\n        state?: State,\n        topology?: Topology,\n        size?: number,\n        start?: number,\n        instanceCount?: number\n        skipSync?: boolean,\n    })\n    {\n        const renderer = this._renderer;\n        const { geometry, shader, state, skipSync, topology: type, size, start, instanceCount } = options;\n\n        renderer.shader.bind(shader, skipSync);\n\n        renderer.geometry.bind(geometry, renderer.shader._activeProgram);\n\n        if (state)\n        {\n            renderer.state.set(state);\n        }\n\n        renderer.geometry.draw(type, size, start, instanceCount ?? geometry.instanceCount);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { GpuStencilModesToPixi } from '../gpu/state/GpuStencilModesToPixi.mjs';\nimport { STENCIL_MODES } from '../shared/state/const.mjs';\n\n\"use strict\";\nclass GlStencilSystem {\n  constructor(renderer) {\n    this._stencilCache = {\n      enabled: false,\n      stencilReference: 0,\n      stencilMode: STENCIL_MODES.NONE\n    };\n    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);\n    renderer.renderTarget.onRenderTargetChange.add(this);\n  }\n  contextChange(gl) {\n    this._gl = gl;\n    this._comparisonFuncMapping = {\n      always: gl.ALWAYS,\n      never: gl.NEVER,\n      equal: gl.EQUAL,\n      \"not-equal\": gl.NOTEQUAL,\n      less: gl.LESS,\n      \"less-equal\": gl.LEQUAL,\n      greater: gl.GREATER,\n      \"greater-equal\": gl.GEQUAL\n    };\n    this._stencilOpsMapping = {\n      keep: gl.KEEP,\n      zero: gl.ZERO,\n      replace: gl.REPLACE,\n      invert: gl.INVERT,\n      \"increment-clamp\": gl.INCR,\n      \"decrement-clamp\": gl.DECR,\n      \"increment-wrap\": gl.INCR_WRAP,\n      \"decrement-wrap\": gl.DECR_WRAP\n    };\n    this._stencilCache.enabled = false;\n    this._stencilCache.stencilMode = STENCIL_MODES.NONE;\n    this._stencilCache.stencilReference = 0;\n  }\n  onRenderTargetChange(renderTarget) {\n    if (this._activeRenderTarget === renderTarget)\n      return;\n    this._activeRenderTarget = renderTarget;\n    let stencilState = this._renderTargetStencilState[renderTarget.uid];\n    if (!stencilState) {\n      stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n        stencilMode: STENCIL_MODES.DISABLED,\n        stencilReference: 0\n      };\n    }\n    this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n  }\n  setStencilMode(stencilMode, stencilReference) {\n    const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n    const gl = this._gl;\n    const mode = GpuStencilModesToPixi[stencilMode];\n    const _stencilCache = this._stencilCache;\n    stencilState.stencilMode = stencilMode;\n    stencilState.stencilReference = stencilReference;\n    if (stencilMode === STENCIL_MODES.DISABLED) {\n      if (this._stencilCache.enabled) {\n        this._stencilCache.enabled = false;\n        gl.disable(gl.STENCIL_TEST);\n      }\n      return;\n    }\n    if (!this._stencilCache.enabled) {\n      this._stencilCache.enabled = true;\n      gl.enable(gl.STENCIL_TEST);\n    }\n    if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {\n      _stencilCache.stencilMode = stencilMode;\n      _stencilCache.stencilReference = stencilReference;\n      gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);\n      gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);\n    }\n  }\n}\n/** @ignore */\nGlStencilSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem\n  ],\n  name: \"stencil\"\n};\n\nexport { GlStencilSystem };\n//# sourceMappingURL=GlStencilSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GpuStencilModesToPixi } from '../gpu/state/GpuStencilModesToPixi';\nimport { STENCIL_MODES } from '../shared/state/const';\n\nimport type { RenderTarget } from '../shared/renderTarget/RenderTarget';\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\n/**\n * This manages the stencil buffer. Used primarily for masking\n * @memberof rendering\n */\nexport class GlStencilSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'stencil',\n    } as const;\n\n    private _gl: WebGLRenderingContext;\n\n    private readonly _stencilCache = {\n        enabled: false,\n        stencilReference: 0,\n        stencilMode: STENCIL_MODES.NONE,\n    };\n\n    private _renderTargetStencilState: Record<number, {\n        stencilMode: STENCIL_MODES;\n        stencilReference: number;\n    }> = Object.create(null);\n\n    private _stencilOpsMapping: {\n        keep: number;\n        zero: number;\n        replace: number;\n        invert: number;\n        'increment-clamp': number;\n        'decrement-clamp': number;\n        'increment-wrap': number;\n        'decrement-wrap': number;\n    };\n\n    private _comparisonFuncMapping: {\n        always: number;\n        never: number;\n        equal: number;\n        'not-equal': number;\n        less: number;\n        'less-equal': number;\n        greater: number;\n        'greater-equal': number;\n    };\n\n    private _activeRenderTarget: RenderTarget;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n\n    protected contextChange(gl: WebGLRenderingContext)\n    {\n        // TODO - this could be declared in a gl const\n        // we know the numbers don't tend to change!\n        this._gl = gl;\n\n        this._comparisonFuncMapping = {\n            always: gl.ALWAYS,\n            never: gl.NEVER,\n            equal: gl.EQUAL,\n            'not-equal': gl.NOTEQUAL,\n            less: gl.LESS,\n            'less-equal': gl.LEQUAL,\n            greater: gl.GREATER,\n            'greater-equal': gl.GEQUAL,\n        };\n\n        this._stencilOpsMapping = {\n            keep: gl.KEEP,\n            zero: gl.ZERO,\n            replace: gl.REPLACE,\n            invert: gl.INVERT,\n            'increment-clamp': gl.INCR,\n            'decrement-clamp': gl.DECR,\n            'increment-wrap': gl.INCR_WRAP,\n            'decrement-wrap': gl.DECR_WRAP,\n        };\n\n        // reset stencil cache\n        this._stencilCache.enabled = false;\n        this._stencilCache.stencilMode = STENCIL_MODES.NONE;\n        this._stencilCache.stencilReference = 0;\n    }\n\n    protected onRenderTargetChange(renderTarget: RenderTarget)\n    {\n        if (this._activeRenderTarget === renderTarget) return;\n\n        this._activeRenderTarget = renderTarget;\n\n        let stencilState = this._renderTargetStencilState[renderTarget.uid];\n\n        if (!stencilState)\n        {\n            stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n                stencilMode: STENCIL_MODES.DISABLED,\n                stencilReference: 0,\n            };\n        }\n\n        // restore the current render targets stencil state..\n        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES, stencilReference: number)\n    {\n        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n\n        const gl = this._gl;\n        const mode = GpuStencilModesToPixi[stencilMode];\n\n        const _stencilCache = this._stencilCache;\n\n        // store the stencil state for restoration later, if a render target changes\n        stencilState.stencilMode = stencilMode;\n        stencilState.stencilReference = stencilReference;\n\n        if (stencilMode === STENCIL_MODES.DISABLED)\n        {\n            if (this._stencilCache.enabled)\n            {\n                this._stencilCache.enabled = false;\n\n                gl.disable(gl.STENCIL_TEST);\n            }\n\n            return;\n        }\n\n        if (!this._stencilCache.enabled)\n        {\n            this._stencilCache.enabled = true;\n            gl.enable(gl.STENCIL_TEST);\n        }\n\n        if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference)\n        {\n            _stencilCache.stencilMode = stencilMode;\n            _stencilCache.stencilReference = stencilReference;\n\n            // this is pretty simple mapping.\n            // will work for pixi's simple mask cases.\n            // although a true mapping of the GPU state to webGL state should be done\n            gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 0xFF);\n            gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);\n        }\n    }\n\n    public destroy?: () => void;\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { UboSystem } from '../shared/shader/UboSystem.mjs';\nimport { createUboElementsSTD40 } from './shader/utils/createUboElementsSTD40.mjs';\nimport { createUboSyncFunctionSTD40 } from './shader/utils/createUboSyncSTD40.mjs';\n\n\"use strict\";\nclass GlUboSystem extends UboSystem {\n  constructor() {\n    super({\n      createUboElements: createUboElementsSTD40,\n      generateUboSync: createUboSyncFunctionSTD40\n    });\n  }\n}\n/** @ignore */\nGlUboSystem.extension = {\n  type: [ExtensionType.WebGLSystem],\n  name: \"ubo\"\n};\n\nexport { GlUboSystem };\n//# sourceMappingURL=GlUboSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { UboSystem } from '../shared/shader/UboSystem';\nimport { createUboElementsSTD40 } from './shader/utils/createUboElementsSTD40';\nimport { createUboSyncFunctionSTD40 } from './shader/utils/createUboSyncSTD40';\n\n/**\n * System plugin to the renderer to manage uniform buffers. But with an WGSL adaptor.\n * @memberof rendering\n */\nexport class GlUboSystem extends UboSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGLSystem],\n        name: 'ubo',\n    } as const;\n\n    constructor()\n    {\n        super({\n            createUboElements: createUboElementsSTD40,\n            generateUboSync: createUboSyncFunctionSTD40,\n        });\n    }\n}\n","\"use strict\";\nconst WGSL_TO_STD40_SIZE = {\n  f32: 4,\n  \"vec2<f32>\": 8,\n  \"vec3<f32>\": 12,\n  \"vec4<f32>\": 16,\n  \"mat2x2<f32>\": 16 * 2,\n  \"mat3x3<f32>\": 16 * 3,\n  \"mat4x4<f32>\": 16 * 4\n  // TODO - not essential for now but support these in the future\n  // int:      4,\n  // ivec2:    8,\n  // ivec3:    12,\n  // ivec4:    16,\n  // uint:     4,\n  // uvec2:    8,\n  // uvec3:    12,\n  // uvec4:    16,\n  // bool:     4,\n  // bvec2:    8,\n  // bvec3:    12,\n  // bvec4:    16,\n  // mat2:     16 * 2,\n  // mat3:     16 * 3,\n  // mat4:     16 * 4,\n};\nfunction createUboElementsSTD40(uniformData) {\n  const uboElements = uniformData.map((data) => ({\n    data,\n    offset: 0,\n    size: 0\n  }));\n  let size = 0;\n  let chunkSize = 0;\n  let offset = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    size = WGSL_TO_STD40_SIZE[uboElement.data.type];\n    if (!size) {\n      throw new Error(`Unknown type ${uboElement.data.type}`);\n    }\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, 16) * uboElement.data.size;\n    }\n    uboElement.size = size;\n    if (chunkSize % size !== 0 && chunkSize < 16) {\n      const lineUpValue = chunkSize % size % 16;\n      chunkSize += lineUpValue;\n      offset += lineUpValue;\n    }\n    if (chunkSize + size > 16) {\n      offset = Math.ceil(offset / 16) * 16;\n      uboElement.offset = offset;\n      offset += size;\n      chunkSize = size;\n    } else {\n      uboElement.offset = offset;\n      chunkSize += size;\n      offset += size;\n    }\n  }\n  offset = Math.ceil(offset / 16) * 16;\n  return { uboElements, size: offset };\n}\n\nexport { WGSL_TO_STD40_SIZE, createUboElementsSTD40 };\n//# sourceMappingURL=createUboElementsSTD40.mjs.map\n","import type { UboElement, UboLayout, UniformData } from '../../../shared/shader/types';\n\nexport const WGSL_TO_STD40_SIZE: Record<string, number> = {\n    f32: 4,\n    'vec2<f32>': 8,\n    'vec3<f32>': 12,\n    'vec4<f32>': 16,\n\n    'mat2x2<f32>': 16 * 2,\n    'mat3x3<f32>': 16 * 3,\n    'mat4x4<f32>': 16 * 4,\n\n    // TODO - not essential for now but support these in the future\n    // int:      4,\n    // ivec2:    8,\n    // ivec3:    12,\n    // ivec4:    16,\n\n    // uint:     4,\n    // uvec2:    8,\n    // uvec3:    12,\n    // uvec4:    16,\n\n    // bool:     4,\n    // bvec2:    8,\n    // bvec3:    12,\n    // bvec4:    16,\n\n    // mat2:     16 * 2,\n    // mat3:     16 * 3,\n    // mat4:     16 * 4,\n};\n\nexport function createUboElementsSTD40(uniformData: UniformData[]): UboLayout\n{\n    const uboElements: UboElement[] = uniformData.map((data: UniformData) =>\n        ({\n            data,\n            offset: 0,\n            size: 0,\n        }));\n\n    let size = 0;\n    let chunkSize = 0;\n    let offset = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        size = WGSL_TO_STD40_SIZE[uboElement.data.type];\n\n        if (!size)\n        {\n            throw new Error(`Unknown type ${uboElement.data.type}`);\n        }\n\n        if (uboElement.data.size > 1)\n        {\n            size = Math.max(size, 16) * uboElement.data.size;\n        }\n\n        uboElement.size = size;\n\n        // add some size offset..\n        // must align to the nearest 16 bytes or internally nearest round size\n        if (chunkSize % size !== 0 && chunkSize < 16)\n        {\n            // diff required to line up..\n            const lineUpValue = (chunkSize % size) % 16;\n\n            chunkSize += lineUpValue;\n            offset += lineUpValue;\n        }\n\n        if ((chunkSize + size) > 16)\n        {\n            offset = Math.ceil(offset / 16) * 16;\n            uboElement.offset = offset;\n            offset += size;\n            chunkSize = size;\n        }\n        else\n        {\n            uboElement.offset = offset;\n            chunkSize += size;\n            offset += size;\n        }\n    }\n\n    offset = Math.ceil(offset / 16) * 16;\n\n    return { uboElements, size: offset };\n}\n\n","import { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction.mjs';\nimport { uboSyncFunctionsSTD40 } from '../../../shared/shader/utils/uboSyncFunctions.mjs';\nimport { generateArraySyncSTD40 } from './generateArraySyncSTD40.mjs';\n\n\"use strict\";\nfunction createUboSyncFunctionSTD40(uboElements) {\n  return createUboSyncFunction(\n    uboElements,\n    \"uboStd40\",\n    generateArraySyncSTD40,\n    uboSyncFunctionsSTD40\n  );\n}\n\nexport { createUboSyncFunctionSTD40 };\n//# sourceMappingURL=createUboSyncSTD40.mjs.map\n","/* eslint-disable quote-props */\n\nimport { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction';\nimport { uboSyncFunctionsSTD40 } from '../../../shared/shader/utils/uboSyncFunctions';\nimport { generateArraySyncSTD40 } from './generateArraySyncSTD40';\n\nimport type { UboElement, UniformsSyncCallback } from '../../../shared/shader/types';\n\nexport function createUboSyncFunctionSTD40(\n    uboElements: UboElement[],\n): UniformsSyncCallback\n{\n    return createUboSyncFunction(\n        uboElements,\n        'uboStd40',\n        generateArraySyncSTD40,\n        uboSyncFunctionsSTD40,\n    );\n}\n","import { WGSL_TO_STD40_SIZE } from './createUboElementsSTD40.mjs';\n\n\"use strict\";\nfunction generateArraySyncSTD40(uboElement, offsetToAdd) {\n  const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n  const elementSize = uboElement.data.value.length / uboElement.data.size;\n  const remainder = (4 - elementSize % 4) % 4;\n  return `\n        v = uv.${uboElement.data.name};\n        offset += ${offsetToAdd};\n\n        arrayOffset = offset;\n\n        t = 0;\n\n        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)\n        {\n            for(var j = 0; j < ${elementSize}; j++)\n            {\n                data[arrayOffset++] = v[t++];\n            }\n            ${remainder !== 0 ? `arrayOffset += ${remainder};` : \"\"}\n        }\n    `;\n}\n\nexport { generateArraySyncSTD40 };\n//# sourceMappingURL=generateArraySyncSTD40.mjs.map\n","import { WGSL_TO_STD40_SIZE } from './createUboElementsSTD40';\n\nimport type { UboElement } from '../../../shared/shader/types';\n\n/**\n * This generates a function that will sync an array to the uniform buffer\n * following the std140 layout\n * @param uboElement - the element to generate the array sync for\n * @param offsetToAdd - the offset to append at the start of the code\n * @returns - the generated code\n */\nexport function generateArraySyncSTD40(uboElement: UboElement, offsetToAdd: number): string\n{\n    const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n    const elementSize = (uboElement.data.value as Array<number>).length / uboElement.data.size;// size / rowSize;\n\n    const remainder = (4 - (elementSize % 4)) % 4;\n\n    return `\n        v = uv.${uboElement.data.name};\n        offset += ${offsetToAdd};\n\n        arrayOffset = offset;\n\n        t = 0;\n\n        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)\n        {\n            for(var j = 0; j < ${elementSize}; j++)\n            {\n                data[arrayOffset++] = v[t++];\n            }\n            ${remainder !== 0 ? `arrayOffset += ${remainder};` : ''}\n        }\n    `;\n}\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem.mjs';\nimport { GlRenderTargetAdaptor } from './GlRenderTargetAdaptor.mjs';\n\n\"use strict\";\nclass GlRenderTargetSystem extends RenderTargetSystem {\n  constructor(renderer) {\n    super(renderer);\n    this.adaptor = new GlRenderTargetAdaptor();\n    this.adaptor.init(renderer, this);\n  }\n}\n/** @ignore */\nGlRenderTargetSystem.extension = {\n  type: [ExtensionType.WebGLSystem],\n  name: \"renderTarget\"\n};\n\nexport { GlRenderTargetSystem };\n//# sourceMappingURL=GlRenderTargetSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport { GlRenderTargetAdaptor } from './GlRenderTargetAdaptor';\n\nimport type { GlRenderTarget } from '../GlRenderTarget';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGl renderer\n * @memberof rendering\n */\nexport class GlRenderTargetSystem extends RenderTargetSystem<GlRenderTarget>\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGLSystem],\n        name: 'renderTarget',\n    } as const;\n\n    public adaptor = new GlRenderTargetAdaptor();\n\n    constructor(renderer: WebGLRenderer)\n    {\n        super(renderer);\n\n        this.adaptor.init(renderer, this);\n    }\n}\n","import { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource.mjs';\nimport { CLEAR } from '../const.mjs';\nimport { GlRenderTarget } from '../GlRenderTarget.mjs';\n\n\"use strict\";\nclass GlRenderTargetAdaptor {\n  constructor() {\n    this._clearColorCache = [0, 0, 0, 0];\n    this._viewPortCache = new Rectangle();\n  }\n  init(renderer, renderTargetSystem) {\n    this._renderer = renderer;\n    this._renderTargetSystem = renderTargetSystem;\n    renderer.runners.contextChange.add(this);\n  }\n  contextChange() {\n    this._clearColorCache = [0, 0, 0, 0];\n    this._viewPortCache = new Rectangle();\n  }\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const renderer = this._renderer;\n    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);\n    const gl = renderer.gl;\n    this.finishRenderPass(sourceRenderSurfaceTexture);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n    renderer.texture.bind(destinationTexture, 0);\n    gl.copyTexSubImage2D(\n      gl.TEXTURE_2D,\n      0,\n      originDest.x,\n      originDest.y,\n      originSrc.x,\n      originSrc.y,\n      size.width,\n      size.height\n    );\n    return destinationTexture;\n  }\n  startRenderPass(renderTarget, clear = true, clearColor, viewport) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const source = renderTarget.colorTexture;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    let viewPortY = viewport.y;\n    if (renderTarget.isRoot) {\n      viewPortY = source.pixelHeight - viewport.height;\n    }\n    renderTarget.colorTextures.forEach((texture) => {\n      this._renderer.texture.unbind(texture);\n    });\n    const gl = this._renderer.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);\n    const viewPortCache = this._viewPortCache;\n    if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {\n      viewPortCache.x = viewport.x;\n      viewPortCache.y = viewPortY;\n      viewPortCache.width = viewport.width;\n      viewPortCache.height = viewport.height;\n      gl.viewport(\n        viewport.x,\n        viewPortY,\n        viewport.width,\n        viewport.height\n      );\n    }\n    if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth)) {\n      this._initStencil(gpuRenderTarget);\n    }\n    this.clear(renderTarget, clear, clearColor);\n  }\n  finishRenderPass(renderTarget) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (!glRenderTarget.msaa)\n      return;\n    const gl = this._renderer.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);\n    gl.blitFramebuffer(\n      0,\n      0,\n      glRenderTarget.width,\n      glRenderTarget.height,\n      0,\n      0,\n      glRenderTarget.width,\n      glRenderTarget.height,\n      gl.COLOR_BUFFER_BIT,\n      gl.NEAREST\n    );\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);\n  }\n  initGpuRenderTarget(renderTarget) {\n    const renderer = this._renderer;\n    const gl = renderer.gl;\n    const glRenderTarget = new GlRenderTarget();\n    if (CanvasSource.test(renderTarget.colorTexture.resource)) {\n      glRenderTarget.framebuffer = null;\n      return glRenderTarget;\n    }\n    this._initColor(renderTarget, glRenderTarget);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    return glRenderTarget;\n  }\n  clear(_renderTarget, clear, clearColor) {\n    if (!clear)\n      return;\n    const renderTargetSystem = this._renderTargetSystem;\n    if (typeof clear === \"boolean\") {\n      clear = clear ? CLEAR.ALL : CLEAR.NONE;\n    }\n    const gl = this._renderer.gl;\n    if (clear & CLEAR.COLOR) {\n      clearColor ?? (clearColor = renderTargetSystem.defaultClearColor);\n      const clearColorCache = this._clearColorCache;\n      const clearColorArray = clearColor;\n      if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {\n        clearColorCache[0] = clearColorArray[0];\n        clearColorCache[1] = clearColorArray[1];\n        clearColorCache[2] = clearColorArray[2];\n        clearColorCache[3] = clearColorArray[3];\n        gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);\n      }\n    }\n    gl.clear(clear);\n  }\n  resizeGpuRenderTarget(renderTarget) {\n    if (renderTarget.isRoot)\n      return;\n    const renderTargetSystem = this._renderTargetSystem;\n    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    this._resizeColor(renderTarget, glRenderTarget);\n    if (renderTarget.stencil) {\n      this._resizeStencil(glRenderTarget);\n    }\n  }\n  _initColor(renderTarget, glRenderTarget) {\n    const renderer = this._renderer;\n    const gl = renderer.gl;\n    const resolveTargetFramebuffer = gl.createFramebuffer();\n    glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);\n    glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;\n    glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      const source = colorTexture.source;\n      if (source.antialias) {\n        if (renderer.context.supports.msaa) {\n          glRenderTarget.msaa = true;\n        } else {\n          warn(\"[RenderTexture] Antialiasing on textures is not supported in WebGL1\");\n        }\n      }\n      renderer.texture.bindSource(source, 0);\n      const glSource = renderer.texture.getGlSource(source);\n      const glTexture = glSource.texture;\n      gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.COLOR_ATTACHMENT0 + i,\n        3553,\n        // texture.target,\n        glTexture,\n        0\n      );\n    });\n    if (glRenderTarget.msaa) {\n      const viewFramebuffer = gl.createFramebuffer();\n      glRenderTarget.framebuffer = viewFramebuffer;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n      renderTarget.colorTextures.forEach((_, i) => {\n        const msaaRenderBuffer = gl.createRenderbuffer();\n        glRenderTarget.msaaRenderBuffer[i] = msaaRenderBuffer;\n      });\n    } else {\n      glRenderTarget.framebuffer = resolveTargetFramebuffer;\n    }\n    this._resizeColor(renderTarget, glRenderTarget);\n  }\n  _resizeColor(renderTarget, glRenderTarget) {\n    const source = renderTarget.colorTexture.source;\n    glRenderTarget.width = source.pixelWidth;\n    glRenderTarget.height = source.pixelHeight;\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      if (i === 0)\n        return;\n      colorTexture.source.resize(source.width, source.height, source._resolution);\n    });\n    if (glRenderTarget.msaa) {\n      const renderer = this._renderer;\n      const gl = renderer.gl;\n      const viewFramebuffer = glRenderTarget.framebuffer;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n      renderTarget.colorTextures.forEach((colorTexture, i) => {\n        const source2 = colorTexture.source;\n        renderer.texture.bindSource(source2, 0);\n        const glSource = renderer.texture.getGlSource(source2);\n        const glInternalFormat = glSource.internalFormat;\n        const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i];\n        gl.bindRenderbuffer(\n          gl.RENDERBUFFER,\n          msaaRenderBuffer\n        );\n        gl.renderbufferStorageMultisample(\n          gl.RENDERBUFFER,\n          4,\n          glInternalFormat,\n          source2.pixelWidth,\n          source2.pixelHeight\n        );\n        gl.framebufferRenderbuffer(\n          gl.FRAMEBUFFER,\n          gl.COLOR_ATTACHMENT0 + i,\n          gl.RENDERBUFFER,\n          msaaRenderBuffer\n        );\n      });\n    }\n  }\n  _initStencil(glRenderTarget) {\n    if (glRenderTarget.framebuffer === null)\n      return;\n    const gl = this._renderer.gl;\n    const depthStencilRenderBuffer = gl.createRenderbuffer();\n    glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;\n    gl.bindRenderbuffer(\n      gl.RENDERBUFFER,\n      depthStencilRenderBuffer\n    );\n    gl.framebufferRenderbuffer(\n      gl.FRAMEBUFFER,\n      gl.DEPTH_STENCIL_ATTACHMENT,\n      gl.RENDERBUFFER,\n      depthStencilRenderBuffer\n    );\n    this._resizeStencil(glRenderTarget);\n  }\n  _resizeStencil(glRenderTarget) {\n    const gl = this._renderer.gl;\n    gl.bindRenderbuffer(\n      gl.RENDERBUFFER,\n      glRenderTarget.depthStencilRenderBuffer\n    );\n    if (glRenderTarget.msaa) {\n      gl.renderbufferStorageMultisample(\n        gl.RENDERBUFFER,\n        4,\n        gl.DEPTH24_STENCIL8,\n        glRenderTarget.width,\n        glRenderTarget.height\n      );\n    } else {\n      gl.renderbufferStorage(\n        gl.RENDERBUFFER,\n        this._renderer.context.webGLVersion === 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,\n        glRenderTarget.width,\n        glRenderTarget.height\n      );\n    }\n  }\n}\n\nexport { GlRenderTargetAdaptor };\n//# sourceMappingURL=GlRenderTargetAdaptor.mjs.map\n","import { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { warn } from '../../../../utils/logging/warn';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource';\nimport { CLEAR } from '../const';\nimport { GlRenderTarget } from '../GlRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { CLEAR_OR_BOOL } from '../const';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGL renderer\n * @memberof rendering\n * @ignore\n */\nexport class GlRenderTargetAdaptor implements RenderTargetAdaptor<GlRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GlRenderTarget>;\n    private _renderer: WebGLRenderer<HTMLCanvasElement>;\n    private _clearColorCache: RgbaArray = [0, 0, 0, 0];\n    private _viewPortCache: Rectangle = new Rectangle();\n\n    public init(renderer: WebGLRenderer, renderTargetSystem: RenderTargetSystem<GlRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n\n        renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._clearColorCache = [0, 0, 0, 0];\n        this._viewPortCache = new Rectangle();\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const renderer = this._renderer;\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);\n        const gl = renderer.gl;\n\n        this.finishRenderPass(sourceRenderSurfaceTexture);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n\n        renderer.texture.bind(destinationTexture, 0);\n\n        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0,\n            originDest.x, originDest.y,\n            originSrc.x,\n            originSrc.y,\n            size.width,\n            size.height\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const source = renderTarget.colorTexture;\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        let viewPortY = viewport.y;\n\n        if (renderTarget.isRoot)\n        {\n            // /TODO this is the same logic?\n            viewPortY = source.pixelHeight - viewport.height;\n        }\n\n        // unbind the current render texture..\n        renderTarget.colorTextures.forEach((texture) =>\n        {\n            this._renderer.texture.unbind(texture);\n        });\n\n        const gl = this._renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);\n\n        const viewPortCache = this._viewPortCache;\n\n        if (viewPortCache.x !== viewport.x\n            || viewPortCache.y !== viewPortY\n            || viewPortCache.width !== viewport.width\n            || viewPortCache.height !== viewport.height)\n        {\n            viewPortCache.x = viewport.x;\n            viewPortCache.y = viewPortY;\n            viewPortCache.width = viewport.width;\n            viewPortCache.height = viewport.height;\n\n            gl.viewport(\n                viewport.x,\n                viewPortY,\n                viewport.width,\n                viewport.height,\n            );\n        }\n\n        // if the stencil buffer has been requested, we need to create a stencil buffer\n        if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth))\n        {\n            this._initStencil(gpuRenderTarget);\n        }\n\n        this.clear(renderTarget, clear, clearColor);\n    }\n\n    public finishRenderPass(renderTarget?: RenderTarget)\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (!glRenderTarget.msaa) return;\n\n        const gl = this._renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);\n\n        gl.blitFramebuffer(\n            0, 0, glRenderTarget.width, glRenderTarget.height,\n            0, 0, glRenderTarget.width, glRenderTarget.height,\n            gl.COLOR_BUFFER_BIT, gl.NEAREST,\n        );\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);\n\n        // dont think we need this anymore? keeping around just in case the wheels fall off\n        // gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GlRenderTarget\n    {\n        const renderer = this._renderer;\n\n        const gl = renderer.gl;\n\n        // do single...\n\n        const glRenderTarget = new GlRenderTarget();\n\n        // we are rendering to a canvas..\n        if (CanvasSource.test(renderTarget.colorTexture.resource))\n        {\n            glRenderTarget.framebuffer = null;\n\n            return glRenderTarget;\n        }\n\n        this._initColor(renderTarget, glRenderTarget);\n\n        // set up a depth texture..\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        return glRenderTarget;\n    }\n\n    public clear(_renderTarget: RenderTarget, clear: CLEAR_OR_BOOL, clearColor?: RgbaArray)\n    {\n        if (!clear) return;\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        // if clear is boolean..\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const gl = this._renderer.gl;\n\n        if (clear & CLEAR.COLOR)\n        {\n            clearColor ??= renderTargetSystem.defaultClearColor;\n\n            const clearColorCache = this._clearColorCache;\n            const clearColorArray = clearColor as number[];\n\n            if (clearColorCache[0] !== clearColorArray[0]\n                || clearColorCache[1] !== clearColorArray[1]\n                || clearColorCache[2] !== clearColorArray[2]\n                || clearColorCache[3] !== clearColorArray[3])\n            {\n                clearColorCache[0] = clearColorArray[0];\n                clearColorCache[1] = clearColorArray[1];\n                clearColorCache[2] = clearColorArray[2];\n                clearColorCache[3] = clearColorArray[3];\n\n                gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);\n            }\n        }\n\n        gl.clear(clear);\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        if (renderTarget.isRoot) return;\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        this._resizeColor(renderTarget, glRenderTarget);\n\n        if (renderTarget.stencil)\n        {\n            this._resizeStencil(glRenderTarget);\n        }\n    }\n\n    private _initColor(renderTarget: RenderTarget, glRenderTarget: GlRenderTarget)\n    {\n        const renderer = this._renderer;\n\n        const gl = renderer.gl;\n        // deal with our outputs..\n        const resolveTargetFramebuffer = gl.createFramebuffer();\n\n        glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;\n\n        // set up the texture..\n        gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);\n\n        glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;\n        glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;\n\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            const source = colorTexture.source;\n\n            if (source.antialias)\n            {\n                if (renderer.context.supports.msaa)\n                {\n                    glRenderTarget.msaa = true;\n                }\n                else\n                {\n                    warn('[RenderTexture] Antialiasing on textures is not supported in WebGL1');\n                }\n            }\n\n            // TODO bindSource could return the glTexture\n            renderer.texture.bindSource(source, 0);\n            const glSource = renderer.texture.getGlSource(source);\n\n            const glTexture = glSource.texture;\n\n            gl.framebufferTexture2D(gl.FRAMEBUFFER,\n                gl.COLOR_ATTACHMENT0 + i,\n                3553, // texture.target,\n                glTexture,\n                0);// mipLevel);\n        });\n\n        if (glRenderTarget.msaa)\n        {\n            const viewFramebuffer = gl.createFramebuffer();\n\n            glRenderTarget.framebuffer = viewFramebuffer;\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n\n            renderTarget.colorTextures.forEach((_, i) =>\n            {\n                const msaaRenderBuffer = gl.createRenderbuffer();\n\n                glRenderTarget.msaaRenderBuffer[i] = msaaRenderBuffer;\n            });\n        }\n        else\n        {\n            glRenderTarget.framebuffer = resolveTargetFramebuffer;\n        }\n\n        this._resizeColor(renderTarget, glRenderTarget);\n    }\n\n    private _resizeColor(renderTarget: RenderTarget, glRenderTarget: GlRenderTarget)\n    {\n        const source = renderTarget.colorTexture.source;\n\n        glRenderTarget.width = source.pixelWidth;\n        glRenderTarget.height = source.pixelHeight;\n\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            // nno need to resize the first texture..\n            if (i === 0) return;\n\n            colorTexture.source.resize(source.width, source.height, source._resolution);\n        });\n\n        if (glRenderTarget.msaa)\n        {\n            const renderer = this._renderer;\n            const gl = renderer.gl;\n\n            const viewFramebuffer = glRenderTarget.framebuffer;\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const source = colorTexture.source;\n\n                renderer.texture.bindSource(source, 0);\n                const glSource = renderer.texture.getGlSource(source);\n\n                const glInternalFormat = glSource.internalFormat;\n\n                const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i];\n\n                gl.bindRenderbuffer(\n                    gl.RENDERBUFFER,\n                    msaaRenderBuffer\n                );\n\n                gl.renderbufferStorageMultisample(\n                    gl.RENDERBUFFER,\n                    4,\n                    glInternalFormat,\n                    source.pixelWidth,\n                    source.pixelHeight\n                );\n\n                gl.framebufferRenderbuffer(\n                    gl.FRAMEBUFFER,\n                    gl.COLOR_ATTACHMENT0 + i,\n                    gl.RENDERBUFFER,\n                    msaaRenderBuffer\n                );\n            });\n        }\n    }\n\n    private _initStencil(glRenderTarget: GlRenderTarget)\n    {\n        // this already exists on the default screen\n        if (glRenderTarget.framebuffer === null) return;\n\n        const gl = this._renderer.gl;\n\n        const depthStencilRenderBuffer = gl.createRenderbuffer();\n\n        glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;\n\n        gl.bindRenderbuffer(\n            gl.RENDERBUFFER,\n            depthStencilRenderBuffer\n        );\n\n        gl.framebufferRenderbuffer(\n            gl.FRAMEBUFFER,\n            gl.DEPTH_STENCIL_ATTACHMENT,\n            gl.RENDERBUFFER,\n            depthStencilRenderBuffer\n        );\n\n        // TDO DO>>\n        this._resizeStencil(glRenderTarget);\n    }\n\n    private _resizeStencil(glRenderTarget: GlRenderTarget)\n    {\n        const gl = this._renderer.gl;\n\n        gl.bindRenderbuffer(\n            gl.RENDERBUFFER,\n            glRenderTarget.depthStencilRenderBuffer\n        );\n\n        if (glRenderTarget.msaa)\n        {\n            gl.renderbufferStorageMultisample(\n                gl.RENDERBUFFER,\n                4,\n                gl.DEPTH24_STENCIL8,\n                glRenderTarget.width,\n                glRenderTarget.height\n            );\n        }\n        else\n        {\n            gl.renderbufferStorage(\n                gl.RENDERBUFFER,\n                this._renderer.context.webGLVersion === 2\n                    ? gl.DEPTH24_STENCIL8\n                    : gl.DEPTH_STENCIL,\n                glRenderTarget.width,\n                glRenderTarget.height\n            );\n        }\n    }\n}\n","\"use strict\";\nclass GlRenderTarget {\n  constructor() {\n    this.width = -1;\n    this.height = -1;\n    this.msaa = false;\n    this.msaaRenderBuffer = [];\n  }\n}\n\nexport { GlRenderTarget };\n//# sourceMappingURL=GlRenderTarget.mjs.map\n","/**\n * Represents a render target.\n * @memberof rendering\n * @ignore\n */\nexport class GlRenderTarget\n{\n    public width = -1;\n    public height = -1;\n    public msaa = false;\n    public framebuffer: WebGLFramebuffer;\n    public resolveTargetFramebuffer: WebGLFramebuffer;\n    public msaaRenderBuffer: WebGLRenderbuffer[] = [];\n    public depthStencilRenderBuffer: WebGLRenderbuffer;\n}\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { generateShaderSyncCode } from './GenerateShaderSyncCode.mjs';\nimport { generateProgram } from './program/generateProgram.mjs';\n\n\"use strict\";\nconst defaultSyncData = {\n  textureCount: 0,\n  blockIndex: 0\n};\nclass GlShaderSystem {\n  constructor(renderer) {\n    /**\n     * @internal\n     * @private\n     */\n    this._activeProgram = null;\n    this._programDataHash = /* @__PURE__ */ Object.create(null);\n    this._nextIndex = 0;\n    this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null);\n    this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null);\n    this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  contextChange(gl) {\n    this._gl = gl;\n    this._maxBindings = gl.MAX_UNIFORM_BUFFER_BINDINGS ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;\n    this._programDataHash = /* @__PURE__ */ Object.create(null);\n    this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null);\n    this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null);\n    this._activeProgram = null;\n  }\n  /**\n   * Changes the current shader to the one given in parameter.\n   * @param shader - the new shader\n   * @param skipSync - false if the shader should automatically sync its uniforms.\n   * @returns the glProgram that belongs to the shader.\n   */\n  bind(shader, skipSync) {\n    this._setProgram(shader.glProgram);\n    if (skipSync)\n      return;\n    defaultSyncData.textureCount = 0;\n    defaultSyncData.blockIndex = 0;\n    let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];\n    if (!syncFunction) {\n      syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);\n    }\n    syncFunction(this._renderer, shader, defaultSyncData);\n  }\n  /**\n   * Updates the uniform group.\n   * @param uniformGroup - the uniform group to update\n   */\n  updateUniformGroup(uniformGroup) {\n    this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);\n  }\n  /**\n   * Binds a uniform block to the shader.\n   * @param uniformGroup - the uniform group to bind\n   * @param name - the name of the uniform block\n   * @param index - the index of the uniform block\n   */\n  bindUniformBlock(uniformGroup, name, index = 0) {\n    const bufferSystem = this._renderer.buffer;\n    const programData = this._getProgramData(this._activeProgram);\n    const isBufferResource = uniformGroup._bufferResource;\n    if (isBufferResource) {\n      this._renderer.ubo.updateUniformGroup(uniformGroup);\n    }\n    bufferSystem.updateBuffer(uniformGroup.buffer);\n    let boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid];\n    if (boundIndex === void 0) {\n      const nextIndex = this._nextIndex++ % this._maxBindings;\n      const currentBoundUniformGroup = this._boundIndexToUniformsHash[nextIndex];\n      if (currentBoundUniformGroup) {\n        this._boundUniformsIdsToIndexHash[currentBoundUniformGroup.uid] = void 0;\n      }\n      boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid] = nextIndex;\n      this._boundIndexToUniformsHash[nextIndex] = uniformGroup;\n      if (isBufferResource) {\n        bufferSystem.bindBufferRange(uniformGroup.buffer, nextIndex, uniformGroup.offset);\n      } else {\n        bufferSystem.bindBufferBase(uniformGroup.buffer, nextIndex);\n      }\n    }\n    const gl = this._gl;\n    const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;\n    if (programData.uniformBlockBindings[index] === boundIndex)\n      return;\n    programData.uniformBlockBindings[index] = boundIndex;\n    gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundIndex);\n  }\n  _setProgram(program) {\n    if (this._activeProgram === program)\n      return;\n    this._activeProgram = program;\n    const programData = this._getProgramData(program);\n    this._gl.useProgram(programData.program);\n  }\n  /**\n   * @param program - the program to get the data for\n   * @internal\n   * @private\n   */\n  _getProgramData(program) {\n    return this._programDataHash[program._key] || this._createProgramData(program);\n  }\n  _createProgramData(program) {\n    const key = program._key;\n    this._programDataHash[key] = generateProgram(this._gl, program);\n    return this._programDataHash[key];\n  }\n  destroy() {\n    for (const key of Object.keys(this._programDataHash)) {\n      const programData = this._programDataHash[key];\n      programData.destroy();\n      this._programDataHash[key] = null;\n    }\n    this._programDataHash = null;\n    this._boundUniformsIdsToIndexHash = null;\n  }\n  /**\n   * Creates a function that can be executed that will sync the shader as efficiently as possible.\n   * Overridden by the unsafe eval package if you don't want eval used in your project.\n   * @param shader - the shader to generate the sync function for\n   * @param shaderSystem - the shader system to use\n   * @returns - the generated sync function\n   * @ignore\n   */\n  _generateShaderSync(shader, shaderSystem) {\n    return generateShaderSyncCode(shader, shaderSystem);\n  }\n}\n/** @ignore */\nGlShaderSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem\n  ],\n  name: \"shader\"\n};\n\nexport { GlShaderSystem };\n//# sourceMappingURL=GlShaderSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { generateShaderSyncCode } from './GenerateShaderSyncCode';\nimport { generateProgram } from './program/generateProgram';\n\nimport type { BufferResource } from '../../shared/buffer/BufferResource';\nimport type { Shader } from '../../shared/shader/Shader';\nimport type { UniformGroup } from '../../shared/shader/UniformGroup';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GlProgram } from './GlProgram';\nimport type { GlProgramData } from './GlProgramData';\n\nexport interface ShaderSyncData\n{\n    textureCount: number;\n    blockIndex: number;\n}\n\nexport type ShaderSyncFunction = (renderer: WebGLRenderer, shader: Shader, syncData: ShaderSyncData) => void;\n\n// default sync data so we don't create a new one each time!\nconst defaultSyncData: ShaderSyncData = {\n    textureCount: 0,\n    blockIndex: 0,\n};\n\n/**\n * System plugin to the renderer to manage the shaders for WebGL.\n * @memberof rendering\n */\nexport class GlShaderSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'shader',\n    } as const;\n\n    /**\n     * @internal\n     * @private\n     */\n    public _activeProgram: GlProgram = null;\n\n    private _programDataHash: Record<string, GlProgramData> = Object.create(null);\n    private readonly _renderer: WebGLRenderer;\n    public _gl: WebGL2RenderingContext;\n    private _maxBindings: number;\n    private _nextIndex = 0;\n    private _boundUniformsIdsToIndexHash: Record<number, number> = Object.create(null);\n    private _boundIndexToUniformsHash: Record<number, UniformGroup | BufferResource> = Object.create(null);\n    private _shaderSyncFunctions: Record<string, ShaderSyncFunction> = Object.create(null);\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this._gl = gl;\n\n        this._maxBindings = gl.MAX_UNIFORM_BUFFER_BINDINGS ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;\n\n        this._programDataHash = Object.create(null);\n        this._boundUniformsIdsToIndexHash = Object.create(null);\n        this._boundIndexToUniformsHash = Object.create(null);\n        this._activeProgram = null;\n    }\n\n    /**\n     * Changes the current shader to the one given in parameter.\n     * @param shader - the new shader\n     * @param skipSync - false if the shader should automatically sync its uniforms.\n     * @returns the glProgram that belongs to the shader.\n     */\n    public bind(shader: Shader, skipSync?: boolean): void\n    {\n        this._setProgram(shader.glProgram);\n\n        if (skipSync) return;\n\n        defaultSyncData.textureCount = 0;\n        defaultSyncData.blockIndex = 0;\n\n        let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];\n\n        if (!syncFunction)\n        {\n            syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);\n        }\n\n        syncFunction(this._renderer, shader, defaultSyncData);\n    }\n\n    /**\n     * Updates the uniform group.\n     * @param uniformGroup - the uniform group to update\n     */\n    public updateUniformGroup(uniformGroup: UniformGroup): void\n    {\n        this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);\n    }\n\n    /**\n     * Binds a uniform block to the shader.\n     * @param uniformGroup - the uniform group to bind\n     * @param name - the name of the uniform block\n     * @param index - the index of the uniform block\n     */\n    public bindUniformBlock(uniformGroup: UniformGroup | BufferResource, name: string, index = 0): void\n    {\n        const bufferSystem = this._renderer.buffer;\n        const programData = this._getProgramData(this._activeProgram);\n\n        const isBufferResource = (uniformGroup as BufferResource)._bufferResource;\n\n        if (isBufferResource)\n        {\n            this._renderer.ubo.updateUniformGroup(uniformGroup as UniformGroup);\n        }\n\n        bufferSystem.updateBuffer(uniformGroup.buffer);\n\n        let boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid];\n\n        // check if it is already bound..\n        if (boundIndex === undefined)\n        {\n            const nextIndex = this._nextIndex++ % this._maxBindings;\n\n            const currentBoundUniformGroup = this._boundIndexToUniformsHash[nextIndex];\n\n            if (currentBoundUniformGroup)\n            {\n                this._boundUniformsIdsToIndexHash[currentBoundUniformGroup.uid] = undefined;\n            }\n\n            // find a free slot..\n            boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid] = nextIndex;\n            this._boundIndexToUniformsHash[nextIndex] = uniformGroup;\n\n            if (isBufferResource)\n            {\n                bufferSystem.bindBufferRange(uniformGroup.buffer, nextIndex, (uniformGroup as BufferResource).offset);\n            }\n            else\n            {\n                bufferSystem.bindBufferBase(uniformGroup.buffer, nextIndex);\n            }\n        }\n\n        const gl = this._gl;\n\n        const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;\n\n        if (programData.uniformBlockBindings[index] === boundIndex) return;\n        programData.uniformBlockBindings[index] = boundIndex;\n\n        gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundIndex);\n    }\n\n    private _setProgram(program: GlProgram)\n    {\n        if (this._activeProgram === program) return;\n\n        this._activeProgram = program;\n\n        const programData = this._getProgramData(program);\n\n        this._gl.useProgram(programData.program);\n    }\n\n    /**\n     * @param program - the program to get the data for\n     * @internal\n     * @private\n     */\n    public _getProgramData(program: GlProgram): GlProgramData\n    {\n        return this._programDataHash[program._key] || this._createProgramData(program);\n    }\n\n    private _createProgramData(program: GlProgram): GlProgramData\n    {\n        const key = program._key;\n\n        this._programDataHash[key] = generateProgram(this._gl, program);\n\n        return this._programDataHash[key];\n    }\n\n    public destroy(): void\n    {\n        for (const key of Object.keys(this._programDataHash))\n        {\n            const programData = this._programDataHash[key];\n\n            programData.destroy();\n            this._programDataHash[key] = null;\n        }\n\n        this._programDataHash = null;\n        this._boundUniformsIdsToIndexHash = null;\n    }\n\n    /**\n     * Creates a function that can be executed that will sync the shader as efficiently as possible.\n     * Overridden by the unsafe eval package if you don't want eval used in your project.\n     * @param shader - the shader to generate the sync function for\n     * @param shaderSystem - the shader system to use\n     * @returns - the generated sync function\n     * @ignore\n     */\n    public _generateShaderSync(shader: Shader, shaderSystem: GlShaderSystem): ShaderSyncFunction\n    {\n        return generateShaderSyncCode(shader, shaderSystem);\n    }\n}\n","import { BufferResource } from '../../shared/buffer/BufferResource.mjs';\nimport { UniformGroup } from '../../shared/shader/UniformGroup.mjs';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource.mjs';\n\n\"use strict\";\nfunction generateShaderSyncCode(shader, shaderSystem) {\n  const funcFragments = [];\n  const headerFragments = [`\n        var g = s.groups;\n        var sS = r.shader;\n        var p = s.glProgram;\n        var ugS = r.uniformGroup;\n        var resources;\n    `];\n  let addedTextreSystem = false;\n  let blockIndex = 0;\n  let textureCount = 0;\n  const programData = shaderSystem._getProgramData(shader.glProgram);\n  for (const i in shader.groups) {\n    const group = shader.groups[i];\n    funcFragments.push(`\n            resources = g[${i}].resources;\n        `);\n    for (const j in group.resources) {\n      const resource = group.resources[j];\n      if (resource instanceof UniformGroup) {\n        if (resource.ubo) {\n          funcFragments.push(`\n                        sS.bindUniformBlock(\n                            resources[${j}],\n                            sS._uniformBindMap[${i}[${j}],\n                            ${blockIndex++}\n                        );\n                    `);\n        } else {\n          funcFragments.push(`\n                        ugS.updateUniformGroup(resources[${j}], p, sD);\n                    `);\n        }\n      } else if (resource instanceof BufferResource) {\n        funcFragments.push(`\n                    sS.bindUniformBlock(\n                        resources[${j}],\n                        sS._uniformBindMap[${i}[${j}],\n                        ${blockIndex++}\n                    );\n                `);\n      } else if (resource instanceof TextureSource) {\n        const uniformName = shader._uniformBindMap[i][j];\n        const uniformData = programData.uniformData[uniformName];\n        if (uniformData) {\n          if (!addedTextreSystem) {\n            addedTextreSystem = true;\n            headerFragments.push(`\n                        var tS = r.texture;\n                        `);\n          }\n          shaderSystem._gl.uniform1i(uniformData.location, textureCount);\n          funcFragments.push(`\n                        tS.bind(resources[${j}], ${textureCount});\n                    `);\n          textureCount++;\n        }\n      }\n    }\n  }\n  const functionSource = [...headerFragments, ...funcFragments].join(\"\\n\");\n  return new Function(\"r\", \"s\", \"sD\", functionSource);\n}\n\nexport { generateShaderSyncCode };\n//# sourceMappingURL=GenerateShaderSyncCode.mjs.map\n","import { BufferResource } from '../../shared/buffer/BufferResource';\nimport { UniformGroup } from '../../shared/shader/UniformGroup';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource';\n\nimport type { Shader } from '../../shared/shader/Shader';\nimport type { GlShaderSystem, ShaderSyncFunction } from './GlShaderSystem';\n\n/**\n * Generates the a function that will efficiantly sync shader resources with the GPU.\n * @param shader - The shader to generate the code for\n * @param shaderSystem - An instance of the shader system\n */\nexport function generateShaderSyncCode(shader: Shader, shaderSystem: GlShaderSystem): ShaderSyncFunction\n{\n    const funcFragments: string[] = [];\n\n    /**\n     * rS = renderer.shader\n     * sS = shaderSystem\n     * sD = shaderData\n     * g = shader.groups\n     * s = shader\n     * r = renderer\n     * ugS = renderer.uniformGroupSystem\n     */\n    const headerFragments: string[] = [`\n        var g = s.groups;\n        var sS = r.shader;\n        var p = s.glProgram;\n        var ugS = r.uniformGroup;\n        var resources;\n    `];\n\n    let addedTextreSystem = false;\n    let blockIndex = 0;\n    let textureCount = 0;\n\n    const programData = shaderSystem._getProgramData(shader.glProgram);\n\n    for (const i in shader.groups)\n    {\n        const group = shader.groups[i];\n\n        funcFragments.push(`\n            resources = g[${i}].resources;\n        `);\n\n        for (const j in group.resources)\n        {\n            const resource = group.resources[j];\n\n            if (resource instanceof UniformGroup)\n            {\n                if (resource.ubo)\n                {\n                    funcFragments.push(`\n                        sS.bindUniformBlock(\n                            resources[${j}],\n                            sS._uniformBindMap[${i}[${j}],\n                            ${blockIndex++}\n                        );\n                    `);\n                }\n                else\n                {\n                    funcFragments.push(`\n                        ugS.updateUniformGroup(resources[${j}], p, sD);\n                    `);\n                }\n            }\n            else if (resource instanceof BufferResource)\n            {\n                funcFragments.push(`\n                    sS.bindUniformBlock(\n                        resources[${j}],\n                        sS._uniformBindMap[${i}[${j}],\n                        ${blockIndex++}\n                    );\n                `);\n            }\n            else if (resource instanceof TextureSource)\n            {\n                const uniformName = shader._uniformBindMap[i as unknown as number][j as unknown as number];\n\n                const uniformData = programData.uniformData[uniformName];\n\n                if (uniformData)\n                {\n                    if (!addedTextreSystem)\n                    {\n                        addedTextreSystem = true;\n                        headerFragments.push(`\n                        var tS = r.texture;\n                        `);\n                    }\n\n                    shaderSystem._gl.uniform1i(uniformData.location, textureCount);\n\n                    funcFragments.push(`\n                        tS.bind(resources[${j}], ${textureCount});\n                    `);\n\n                    textureCount++;\n                }\n            }\n        }\n    }\n\n    const functionSource = [...headerFragments, ...funcFragments].join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('r', 's', 'sD', functionSource) as ShaderSyncFunction;\n}\n","import { warn } from '../../../../../utils/logging/warn.mjs';\nimport { GlProgramData } from '../GlProgramData.mjs';\nimport { compileShader } from './compileShader.mjs';\nimport { defaultValue } from './defaultValue.mjs';\nimport { extractAttributesFromGlProgram } from './extractAttributesFromGlProgram.mjs';\nimport { getUboData } from './getUboData.mjs';\nimport { getUniformData } from './getUniformData.mjs';\nimport { logProgramError } from './logProgramError.mjs';\n\n\"use strict\";\nfunction generateProgram(gl, program) {\n  const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);\n  const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);\n  const webGLProgram = gl.createProgram();\n  gl.attachShader(webGLProgram, glVertShader);\n  gl.attachShader(webGLProgram, glFragShader);\n  const transformFeedbackVaryings = program.transformFeedbackVaryings;\n  if (transformFeedbackVaryings) {\n    if (typeof gl.transformFeedbackVaryings !== \"function\") {\n      warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);\n    } else {\n      gl.transformFeedbackVaryings(\n        webGLProgram,\n        transformFeedbackVaryings.names,\n        transformFeedbackVaryings.bufferMode === \"separate\" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS\n      );\n    }\n  }\n  gl.linkProgram(webGLProgram);\n  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {\n    logProgramError(gl, webGLProgram, glVertShader, glFragShader);\n  }\n  program._attributeData = extractAttributesFromGlProgram(\n    webGLProgram,\n    gl,\n    !/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m.test(program.vertex)\n  );\n  program._uniformData = getUniformData(webGLProgram, gl);\n  program._uniformBlockData = getUboData(webGLProgram, gl);\n  gl.deleteShader(glVertShader);\n  gl.deleteShader(glFragShader);\n  const uniformData = {};\n  for (const i in program._uniformData) {\n    const data = program._uniformData[i];\n    uniformData[i] = {\n      location: gl.getUniformLocation(webGLProgram, i),\n      value: defaultValue(data.type, data.size)\n    };\n  }\n  const glProgram = new GlProgramData(webGLProgram, uniformData);\n  return glProgram;\n}\n\nexport { generateProgram };\n//# sourceMappingURL=generateProgram.mjs.map\n","import { warn } from '../../../../../utils/logging/warn';\nimport { GlProgramData } from '../GlProgramData';\nimport { compileShader } from './compileShader';\nimport { defaultValue } from './defaultValue';\nimport { extractAttributesFromGlProgram } from './extractAttributesFromGlProgram';\nimport { getUboData } from './getUboData';\nimport { getUniformData } from './getUniformData';\nimport { logProgramError } from './logProgramError';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlProgram } from '../GlProgram';\nimport type { IGLUniformData } from '../GlProgramData';\n\n/**\n * generates a WebGL Program object from a high level Pixi Program.\n * @param gl - a rendering context on which to generate the program\n * @param program - the high level Pixi Program.\n * @private\n */\nexport function generateProgram(gl: GlRenderingContext, program: GlProgram): GlProgramData\n{\n    const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);\n    const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);\n\n    const webGLProgram = gl.createProgram();\n\n    gl.attachShader(webGLProgram, glVertShader);\n    gl.attachShader(webGLProgram, glFragShader);\n\n    const transformFeedbackVaryings = program.transformFeedbackVaryings;\n\n    if (transformFeedbackVaryings)\n    {\n        if (typeof gl.transformFeedbackVaryings !== 'function')\n        {\n            // #if _DEBUG\n            warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);\n            // #endif\n        }\n        else\n        {\n            gl.transformFeedbackVaryings(\n                webGLProgram,\n                transformFeedbackVaryings.names,\n                transformFeedbackVaryings.bufferMode === 'separate'\n                    ? gl.SEPARATE_ATTRIBS\n                    : gl.INTERLEAVED_ATTRIBS\n            );\n        }\n    }\n\n    gl.linkProgram(webGLProgram);\n\n    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS))\n    {\n        logProgramError(gl, webGLProgram, glVertShader, glFragShader);\n    }\n\n    // GLSL 1.00: bind attributes sorted by name in ascending order\n    // GLSL 3.00: don't change the attribute locations that where chosen by the compiler\n    //            or assigned by the layout specifier in the shader source code\n    program._attributeData = extractAttributesFromGlProgram(\n        webGLProgram,\n        gl,\n        !(/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m).test(program.vertex)\n    );\n\n    program._uniformData = getUniformData(webGLProgram, gl);\n    program._uniformBlockData = getUboData(webGLProgram, gl);\n\n    gl.deleteShader(glVertShader);\n    gl.deleteShader(glFragShader);\n\n    const uniformData: {[key: string]: IGLUniformData} = {};\n\n    for (const i in program._uniformData)\n    {\n        const data = program._uniformData[i];\n\n        uniformData[i] = {\n            location: gl.getUniformLocation(webGLProgram, i),\n            value: defaultValue(data.type, data.size),\n        };\n    }\n\n    const glProgram = new GlProgramData(webGLProgram, uniformData);\n\n    return glProgram;\n}\n","\"use strict\";\nclass IGLUniformData {\n}\nclass GlProgramData {\n  /**\n   * Makes a new Pixi program.\n   * @param program - webgl program\n   * @param uniformData - uniforms\n   */\n  constructor(program, uniformData) {\n    this.program = program;\n    this.uniformData = uniformData;\n    this.uniformGroups = {};\n    this.uniformDirtyGroups = {};\n    this.uniformBlockBindings = {};\n  }\n  /** Destroys this program. */\n  destroy() {\n    this.uniformData = null;\n    this.uniformGroups = null;\n    this.uniformDirtyGroups = null;\n    this.uniformBlockBindings = null;\n    this.program = null;\n  }\n}\n\nexport { GlProgramData, IGLUniformData };\n//# sourceMappingURL=GlProgramData.mjs.map\n","/**\n * @private\n */\nexport class IGLUniformData\n{\n    public location: WebGLUniformLocation;\n    public value: number | boolean | Float32Array | Int32Array | Uint32Array | boolean[];\n}\n\n/**\n * Helper class to create a WebGL Program\n * @private\n */\nexport class GlProgramData\n{\n    /** The shader program. */\n    public program: WebGLProgram;\n\n    /**\n     * Holds the uniform data which contains uniform locations\n     * and current uniform values used for caching and preventing unneeded GPU commands.\n     */\n    public uniformData: Record<string, any>;\n\n    /**\n     * UniformGroups holds the various upload functions for the shader. Each uniform group\n     * and program have a unique upload function generated.\n     */\n    public uniformGroups: Record<string, any>;\n\n    /** A hash that stores where UBOs are bound to on the program. */\n    public uniformBlockBindings: Record<string, any>;\n\n    /** A hash for lazily-generated uniform uploading functions. */\n    public uniformSync: Record<string, any>;\n\n    /**\n     * A place where dirty ticks are stored for groups\n     * If a tick here does not match with the Higher level Programs tick, it means\n     * we should re upload the data.\n     */\n    public uniformDirtyGroups: Record<string, any>;\n\n    /**\n     * Makes a new Pixi program.\n     * @param program - webgl program\n     * @param uniformData - uniforms\n     */\n    constructor(program: WebGLProgram, uniformData: {[key: string]: IGLUniformData})\n    {\n        this.program = program;\n        this.uniformData = uniformData;\n        this.uniformGroups = {};\n        this.uniformDirtyGroups = {};\n        this.uniformBlockBindings = {};\n    }\n\n    /** Destroys this program. */\n    public destroy(): void\n    {\n        this.uniformData = null;\n        this.uniformGroups = null;\n        this.uniformDirtyGroups = null;\n        this.uniformBlockBindings = null;\n        this.program = null;\n    }\n}\n","\"use strict\";\nfunction compileShader(gl, type, src) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, src);\n  gl.compileShader(shader);\n  return shader;\n}\n\nexport { compileShader };\n//# sourceMappingURL=compileShader.mjs.map\n","/**\n * @private\n * @param {WebGLRenderingContext} gl - The current WebGL context {WebGLProgram}\n * @param {number} type - the type, can be either VERTEX_SHADER or FRAGMENT_SHADER\n * @param {string} src - The vertex shader source as an array of strings.\n * @returns {WebGLShader} the shader\n */\nexport function compileShader(gl: WebGLRenderingContextBase, type: number, src: string): WebGLShader\n{\n    const shader = gl.createShader(type);\n\n    gl.shaderSource(shader, src);\n    gl.compileShader(shader);\n\n    return shader;\n}\n","\"use strict\";\nfunction booleanArray(size) {\n  const array = new Array(size);\n  for (let i = 0; i < array.length; i++) {\n    array[i] = false;\n  }\n  return array;\n}\nfunction defaultValue(type, size) {\n  switch (type) {\n    case \"float\":\n      return 0;\n    case \"vec2\":\n      return new Float32Array(2 * size);\n    case \"vec3\":\n      return new Float32Array(3 * size);\n    case \"vec4\":\n      return new Float32Array(4 * size);\n    case \"int\":\n    case \"uint\":\n    case \"sampler2D\":\n    case \"sampler2DArray\":\n      return 0;\n    case \"ivec2\":\n      return new Int32Array(2 * size);\n    case \"ivec3\":\n      return new Int32Array(3 * size);\n    case \"ivec4\":\n      return new Int32Array(4 * size);\n    case \"uvec2\":\n      return new Uint32Array(2 * size);\n    case \"uvec3\":\n      return new Uint32Array(3 * size);\n    case \"uvec4\":\n      return new Uint32Array(4 * size);\n    case \"bool\":\n      return false;\n    case \"bvec2\":\n      return booleanArray(2 * size);\n    case \"bvec3\":\n      return booleanArray(3 * size);\n    case \"bvec4\":\n      return booleanArray(4 * size);\n    case \"mat2\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case \"mat3\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case \"mat4\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\n\nexport { defaultValue };\n//# sourceMappingURL=defaultValue.mjs.map\n","function booleanArray(size: number): Array<boolean>\n{\n    const array = new Array(size);\n\n    for (let i = 0; i < array.length; i++)\n    {\n        array[i] = false;\n    }\n\n    return array;\n}\n\n/**\n * @method defaultValue\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function defaultValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'float':\n            return 0;\n\n        case 'vec2':\n            return new Float32Array(2 * size);\n\n        case 'vec3':\n            return new Float32Array(3 * size);\n\n        case 'vec4':\n            return new Float32Array(4 * size);\n\n        case 'int':\n        case 'uint':\n        case 'sampler2D':\n        case 'sampler2DArray':\n            return 0;\n\n        case 'ivec2':\n            return new Int32Array(2 * size);\n\n        case 'ivec3':\n            return new Int32Array(3 * size);\n\n        case 'ivec4':\n            return new Int32Array(4 * size);\n\n        case 'uvec2':\n            return new Uint32Array(2 * size);\n\n        case 'uvec3':\n            return new Uint32Array(3 * size);\n\n        case 'uvec4':\n            return new Uint32Array(4 * size);\n\n        case 'bool':\n            return false;\n\n        case 'bvec2':\n\n            return booleanArray(2 * size);\n\n        case 'bvec3':\n            return booleanArray(3 * size);\n\n        case 'bvec4':\n            return booleanArray(4 * size);\n\n        case 'mat2':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n","import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\nimport { mapGlToVertexFormat } from './mapType.mjs';\n\n\"use strict\";\nfunction extractAttributesFromGlProgram(program, gl, sortAttributes = false) {\n  const attributes = {};\n  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n  for (let i = 0; i < totalAttributes; i++) {\n    const attribData = gl.getActiveAttrib(program, i);\n    if (attribData.name.startsWith(\"gl_\")) {\n      continue;\n    }\n    const format = mapGlToVertexFormat(gl, attribData.type);\n    attributes[attribData.name] = {\n      location: 0,\n      // set further down..\n      format,\n      stride: getAttributeInfoFromFormat(format).stride,\n      offset: 0,\n      instance: false,\n      start: 0\n    };\n  }\n  const keys = Object.keys(attributes);\n  if (sortAttributes) {\n    keys.sort((a, b) => a > b ? 1 : -1);\n    for (let i = 0; i < keys.length; i++) {\n      attributes[keys[i]].location = i;\n      gl.bindAttribLocation(program, i, keys[i]);\n    }\n    gl.linkProgram(program);\n  } else {\n    for (let i = 0; i < keys.length; i++) {\n      attributes[keys[i]].location = gl.getAttribLocation(program, keys[i]);\n    }\n  }\n  return attributes;\n}\n\nexport { extractAttributesFromGlProgram };\n//# sourceMappingURL=extractAttributesFromGlProgram.mjs.map\n","import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\nimport { mapGlToVertexFormat } from './mapType';\n\nimport type { Attribute } from '../../../shared/geometry/Geometry';\n\nexport type ExtractedAttributeData = Omit<Attribute, 'buffer'>;\n\n/**\n * returns the attribute data from the program\n * @private\n * @param {WebGLProgram} [program] - the WebGL program\n * @param {WebGLRenderingContext} [gl] - the WebGL context\n * @returns {object} the attribute data for this program\n */\n\nexport function extractAttributesFromGlProgram(\n    program: WebGLProgram,\n    gl: WebGLRenderingContextBase,\n    sortAttributes = false\n): Record<string, ExtractedAttributeData>\n{\n    const attributes: {[key: string]: ExtractedAttributeData} = {};\n\n    const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\n    for (let i = 0; i < totalAttributes; i++)\n    {\n        const attribData = gl.getActiveAttrib(program, i);\n\n        // ignore the default ones!\n        if (attribData.name.startsWith('gl_'))\n        {\n            continue;\n        }\n\n        const format = mapGlToVertexFormat(gl, attribData.type);\n\n        attributes[attribData.name] = {\n            location: 0, // set further down..\n            format,\n            stride: getAttributeInfoFromFormat(format).stride,\n            offset: 0,\n            instance: false,\n            start: 0,\n        };\n    }\n\n    const keys = Object.keys(attributes);\n\n    if (sortAttributes)\n    {\n        keys.sort((a, b) => (a > b) ? 1 : -1); // eslint-disable-line no-confusing-arrow\n\n        for (let i = 0; i < keys.length; i++)\n        {\n            attributes[keys[i]].location = i;\n\n            gl.bindAttribLocation(program, i, keys[i]);\n        }\n\n        gl.linkProgram(program);\n    }\n    else\n    {\n        for (let i = 0; i < keys.length; i++)\n        {\n            attributes[keys[i]].location = gl.getAttribLocation(program, keys[i]);\n        }\n    }\n\n    return attributes;\n}\n","\"use strict\";\nlet GL_TABLE = null;\nconst GL_TO_GLSL_TYPES = {\n  FLOAT: \"float\",\n  FLOAT_VEC2: \"vec2\",\n  FLOAT_VEC3: \"vec3\",\n  FLOAT_VEC4: \"vec4\",\n  INT: \"int\",\n  INT_VEC2: \"ivec2\",\n  INT_VEC3: \"ivec3\",\n  INT_VEC4: \"ivec4\",\n  UNSIGNED_INT: \"uint\",\n  UNSIGNED_INT_VEC2: \"uvec2\",\n  UNSIGNED_INT_VEC3: \"uvec3\",\n  UNSIGNED_INT_VEC4: \"uvec4\",\n  BOOL: \"bool\",\n  BOOL_VEC2: \"bvec2\",\n  BOOL_VEC3: \"bvec3\",\n  BOOL_VEC4: \"bvec4\",\n  FLOAT_MAT2: \"mat2\",\n  FLOAT_MAT3: \"mat3\",\n  FLOAT_MAT4: \"mat4\",\n  SAMPLER_2D: \"sampler2D\",\n  INT_SAMPLER_2D: \"sampler2D\",\n  UNSIGNED_INT_SAMPLER_2D: \"sampler2D\",\n  SAMPLER_CUBE: \"samplerCube\",\n  INT_SAMPLER_CUBE: \"samplerCube\",\n  UNSIGNED_INT_SAMPLER_CUBE: \"samplerCube\",\n  SAMPLER_2D_ARRAY: \"sampler2DArray\",\n  INT_SAMPLER_2D_ARRAY: \"sampler2DArray\",\n  UNSIGNED_INT_SAMPLER_2D_ARRAY: \"sampler2DArray\"\n};\nconst GLSL_TO_VERTEX_TYPES = {\n  float: \"float32\",\n  vec2: \"float32x2\",\n  vec3: \"float32x3\",\n  vec4: \"float32x4\",\n  int: \"sint32\",\n  ivec2: \"sint32x2\",\n  ivec3: \"sint32x3\",\n  ivec4: \"sint32x4\",\n  uint: \"uint32\",\n  uvec2: \"uint32x2\",\n  uvec3: \"uint32x3\",\n  uvec4: \"uint32x4\",\n  bool: \"uint32\",\n  bvec2: \"uint32x2\",\n  bvec3: \"uint32x3\",\n  bvec4: \"uint32x4\"\n};\nfunction mapType(gl, type) {\n  if (!GL_TABLE) {\n    const typeNames = Object.keys(GL_TO_GLSL_TYPES);\n    GL_TABLE = {};\n    for (let i = 0; i < typeNames.length; ++i) {\n      const tn = typeNames[i];\n      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];\n    }\n  }\n  return GL_TABLE[type];\n}\nfunction mapGlToVertexFormat(gl, type) {\n  const typeValue = mapType(gl, type);\n  return GLSL_TO_VERTEX_TYPES[typeValue] || \"float32\";\n}\n\nexport { mapGlToVertexFormat, mapType };\n//# sourceMappingURL=mapType.mjs.map\n","import type { Dict } from '../../../../../utils/types';\nimport type { VertexFormat } from '../../../shared/geometry/const';\n\nlet GL_TABLE: Dict<string> = null;\n\nconst GL_TO_GLSL_TYPES: Dict<string> = {\n    FLOAT:       'float',\n    FLOAT_VEC2:  'vec2',\n    FLOAT_VEC3:  'vec3',\n    FLOAT_VEC4:  'vec4',\n\n    INT:         'int',\n    INT_VEC2:    'ivec2',\n    INT_VEC3:    'ivec3',\n    INT_VEC4:    'ivec4',\n\n    UNSIGNED_INT:         'uint',\n    UNSIGNED_INT_VEC2:    'uvec2',\n    UNSIGNED_INT_VEC3:    'uvec3',\n    UNSIGNED_INT_VEC4:    'uvec4',\n\n    BOOL:        'bool',\n    BOOL_VEC2:   'bvec2',\n    BOOL_VEC3:   'bvec3',\n    BOOL_VEC4:   'bvec4',\n\n    FLOAT_MAT2:  'mat2',\n    FLOAT_MAT3:  'mat3',\n    FLOAT_MAT4:  'mat4',\n\n    SAMPLER_2D:              'sampler2D',\n    INT_SAMPLER_2D:          'sampler2D',\n    UNSIGNED_INT_SAMPLER_2D: 'sampler2D',\n    SAMPLER_CUBE:              'samplerCube',\n    INT_SAMPLER_CUBE:          'samplerCube',\n    UNSIGNED_INT_SAMPLER_CUBE: 'samplerCube',\n    SAMPLER_2D_ARRAY:              'sampler2DArray',\n    INT_SAMPLER_2D_ARRAY:          'sampler2DArray',\n    UNSIGNED_INT_SAMPLER_2D_ARRAY: 'sampler2DArray',\n};\n\nconst GLSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    float: 'float32',\n    vec2: 'float32x2',\n    vec3: 'float32x3',\n    vec4: 'float32x4',\n\n    int: 'sint32',\n    ivec2: 'sint32x2',\n    ivec3: 'sint32x3',\n    ivec4: 'sint32x4',\n\n    uint: 'uint32',\n    uvec2: 'uint32x2',\n    uvec3: 'uint32x3',\n    uvec4: 'uint32x4',\n\n    bool: 'uint32',\n    bvec2: 'uint32x2',\n    bvec3: 'uint32x3',\n    bvec4: 'uint32x4',\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\nexport function mapType(gl: any, type: number): string\n{\n    if (!GL_TABLE)\n    {\n        const typeNames = Object.keys(GL_TO_GLSL_TYPES);\n\n        GL_TABLE = {};\n\n        for (let i = 0; i < typeNames.length; ++i)\n        {\n            const tn = typeNames[i];\n\n            GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];\n        }\n    }\n\n    return GL_TABLE[type];\n}\n\nexport function mapGlToVertexFormat(gl: any, type: number): VertexFormat\n{\n    const typeValue = mapType(gl, type);\n\n    return GLSL_TO_VERTEX_TYPES[typeValue] || 'float32';\n}\n","\"use strict\";\nfunction getUboData(program, gl) {\n  if (!gl.ACTIVE_UNIFORM_BLOCKS)\n    return {};\n  const uniformBlocks = {};\n  const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);\n  for (let i = 0; i < totalUniformsBlocks; i++) {\n    const name = gl.getActiveUniformBlockName(program, i);\n    const uniformBlockIndex = gl.getUniformBlockIndex(program, name);\n    const size = gl.getActiveUniformBlockParameter(program, i, gl.UNIFORM_BLOCK_DATA_SIZE);\n    uniformBlocks[name] = {\n      name,\n      index: uniformBlockIndex,\n      size\n    };\n  }\n  return uniformBlocks;\n}\n\nexport { getUboData };\n//# sourceMappingURL=getUboData.mjs.map\n","import type { GlUniformBlockData } from '../GlProgram';\n\n/**\n * returns the uniform block data from the program\n * @private\n * @param program - the webgl program\n * @param gl - the WebGL context\n * @returns {object} the uniform data for this program\n */\nexport function getUboData(program: WebGLProgram, gl: WebGL2RenderingContext): Record<string, GlUniformBlockData>\n{\n    // if uniform buffer data is not supported, early out\n    if (!gl.ACTIVE_UNIFORM_BLOCKS) return {};\n\n    const uniformBlocks: Record<string, GlUniformBlockData> = {};\n\n    // const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n    const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);\n\n    for (let i = 0; i < totalUniformsBlocks; i++)\n    {\n        const name = gl.getActiveUniformBlockName(program, i);\n        const uniformBlockIndex = gl.getUniformBlockIndex(program, name);\n\n        const size = gl.getActiveUniformBlockParameter(program, i, gl.UNIFORM_BLOCK_DATA_SIZE);\n\n        uniformBlocks[name] = {\n            name,\n            index: uniformBlockIndex,\n            size,\n        };\n    }\n\n    return uniformBlocks;\n}\n","import { defaultValue } from './defaultValue.mjs';\nimport { mapType } from './mapType.mjs';\n\n\"use strict\";\nfunction getUniformData(program, gl) {\n  const uniforms = {};\n  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n  for (let i = 0; i < totalUniforms; i++) {\n    const uniformData = gl.getActiveUniform(program, i);\n    const name = uniformData.name.replace(/\\[.*?\\]$/, \"\");\n    const isArray = !!uniformData.name.match(/\\[.*?\\]$/);\n    const type = mapType(gl, uniformData.type);\n    uniforms[name] = {\n      name,\n      index: i,\n      type,\n      size: uniformData.size,\n      isArray,\n      value: defaultValue(type, uniformData.size)\n    };\n  }\n  return uniforms;\n}\n\nexport { getUniformData };\n//# sourceMappingURL=getUniformData.mjs.map\n","import { defaultValue } from './defaultValue';\nimport { mapType } from './mapType';\n\nimport type { GlUniformData } from '../GlProgram';\n\n/**\n * returns the uniform data from the program\n * @private\n * @param program - the webgl program\n * @param gl - the WebGL context\n * @returns {object} the uniform data for this program\n */\nexport function getUniformData(program: WebGLProgram, gl: WebGLRenderingContextBase): {[key: string]: GlUniformData}\n{\n    const uniforms: {[key: string]: GlUniformData} = {};\n\n    const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n    for (let i = 0; i < totalUniforms; i++)\n    {\n        const uniformData = gl.getActiveUniform(program, i);\n        const name = uniformData.name.replace(/\\[.*?\\]$/, '');\n\n        const isArray = !!(uniformData.name.match(/\\[.*?\\]$/));\n\n        const type = mapType(gl, uniformData.type);\n\n        uniforms[name] = {\n            name,\n            index: i,\n            type,\n            size: uniformData.size,\n            isArray,\n            value: defaultValue(type, uniformData.size),\n        };\n    }\n\n    return uniforms;\n}\n","\"use strict\";\nfunction logPrettyShaderError(gl, shader) {\n  const shaderSrc = gl.getShaderSource(shader).split(\"\\n\").map((line, index) => `${index}: ${line}`);\n  const shaderLog = gl.getShaderInfoLog(shader);\n  const splitShader = shaderLog.split(\"\\n\");\n  const dedupe = {};\n  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\\: 0\\:([\\d]+)\\:.*$/, \"$1\"))).filter((n) => {\n    if (n && !dedupe[n]) {\n      dedupe[n] = true;\n      return true;\n    }\n    return false;\n  });\n  const logArgs = [\"\"];\n  lineNumbers.forEach((number) => {\n    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;\n    logArgs.push(\"background: #FF0000; color:#FFFFFF; font-size: 10px\", \"font-size: 10px\");\n  });\n  const fragmentSourceToLog = shaderSrc.join(\"\\n\");\n  logArgs[0] = fragmentSourceToLog;\n  console.error(shaderLog);\n  console.groupCollapsed(\"click to view full shader code\");\n  console.warn(...logArgs);\n  console.groupEnd();\n}\nfunction logProgramError(gl, program, vertexShader, fragmentShader) {\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      logPrettyShaderError(gl, vertexShader);\n    }\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      logPrettyShaderError(gl, fragmentShader);\n    }\n    console.error(\"PixiJS Error: Could not initialize shader.\");\n    if (gl.getProgramInfoLog(program) !== \"\") {\n      console.warn(\"PixiJS Warning: gl.getProgramInfoLog()\", gl.getProgramInfoLog(program));\n    }\n  }\n}\n\nexport { logProgramError };\n//# sourceMappingURL=logProgramError.mjs.map\n","/**\n * will log a shader error highlighting the lines with the error\n * also will add numbers along the side.\n * @param gl - the WebGLContext\n * @param shader - the shader to log errors for\n */\nfunction logPrettyShaderError(gl: WebGLRenderingContext, shader: WebGLShader): void\n{\n    const shaderSrc = gl.getShaderSource(shader)\n        .split('\\n')\n        .map((line, index) => `${index}: ${line}`);\n\n    const shaderLog = gl.getShaderInfoLog(shader);\n    const splitShader = shaderLog.split('\\n');\n\n    const dedupe: Record<number, boolean> = {};\n\n    const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\\: 0\\:([\\d]+)\\:.*$/, '$1')))\n        .filter((n) =>\n        {\n            if (n && !dedupe[n])\n            {\n                dedupe[n] = true;\n\n                return true;\n            }\n\n            return false;\n        });\n\n    const logArgs = [''];\n\n    lineNumbers.forEach((number) =>\n    {\n        shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;\n        logArgs.push('background: #FF0000; color:#FFFFFF; font-size: 10px', 'font-size: 10px');\n    });\n\n    const fragmentSourceToLog = shaderSrc\n        .join('\\n');\n\n    logArgs[0] = fragmentSourceToLog;\n\n    console.error(shaderLog);\n\n    // eslint-disable-next-line no-console\n    console.groupCollapsed('click to view full shader code');\n    console.warn(...logArgs);\n    // eslint-disable-next-line no-console\n    console.groupEnd();\n}\n\n/**\n *\n * logs out any program errors\n * @param gl - The current WebGL context\n * @param program - the WebGL program to display errors for\n * @param vertexShader  - the fragment WebGL shader program\n * @param fragmentShader - the vertex WebGL shader program\n * @private\n */\nexport function logProgramError(\n    gl: WebGLRenderingContext,\n    program: WebGLProgram,\n    vertexShader: WebGLShader,\n    fragmentShader: WebGLShader\n): void\n{\n    // if linking fails, then log and cleanup\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS))\n    {\n        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS))\n        {\n            logPrettyShaderError(gl, vertexShader);\n        }\n\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS))\n        {\n            logPrettyShaderError(gl, fragmentShader);\n        }\n\n        console.error('PixiJS Error: Could not initialize shader.');\n\n        // if there is a program info log, log it\n        if (gl.getProgramInfoLog(program) !== '')\n        {\n            console.warn('PixiJS Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));\n        }\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { generateUniformsSync } from './utils/generateUniformsSync.mjs';\n\n\"use strict\";\nclass GlUniformGroupSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    /** Cache to holds the generated functions. Stored against UniformObjects unique signature. */\n    this._cache = {};\n    this._uniformGroupSyncHash = {};\n    this._renderer = renderer;\n    this.gl = null;\n    this._cache = {};\n  }\n  contextChange(gl) {\n    this.gl = gl;\n  }\n  /**\n   * Uploads the uniforms values to the currently bound shader.\n   * @param group - the uniforms values that be applied to the current shader\n   * @param program\n   * @param syncData\n   * @param syncData.textureCount\n   */\n  updateUniformGroup(group, program, syncData) {\n    const programData = this._renderer.shader._getProgramData(program);\n    if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid]) {\n      programData.uniformDirtyGroups[group.uid] = group._dirtyId;\n      const syncFunc = this._getUniformSyncFunction(group, program);\n      syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);\n    }\n  }\n  /**\n   * Overrideable by the pixi.js/unsafe-eval package to use static syncUniforms instead.\n   * @param group\n   * @param program\n   */\n  _getUniformSyncFunction(group, program) {\n    return this._uniformGroupSyncHash[group._signature]?.[program._key] || this._createUniformSyncFunction(group, program);\n  }\n  _createUniformSyncFunction(group, program) {\n    const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature] || (this._uniformGroupSyncHash[group._signature] = {});\n    const id = this._getSignature(group, program._uniformData, \"u\");\n    if (!this._cache[id]) {\n      this._cache[id] = this._generateUniformsSync(group, program._uniformData);\n    }\n    uniformGroupSyncHash[program._key] = this._cache[id];\n    return uniformGroupSyncHash[program._key];\n  }\n  _generateUniformsSync(group, uniformData) {\n    return generateUniformsSync(group, uniformData);\n  }\n  /**\n   * Takes a uniform group and data and generates a unique signature for them.\n   * @param group - The uniform group to get signature of\n   * @param group.uniforms\n   * @param uniformData - Uniform information generated by the shader\n   * @param preFix\n   * @returns Unique signature of the uniform group\n   */\n  _getSignature(group, uniformData, preFix) {\n    const uniforms = group.uniforms;\n    const strings = [`${preFix}-`];\n    for (const i in uniforms) {\n      strings.push(i);\n      if (uniformData[i]) {\n        strings.push(uniformData[i].type);\n      }\n    }\n    return strings.join(\"-\");\n  }\n  /** Destroys this System and removes all its textures. */\n  destroy() {\n    this._renderer = null;\n    this._cache = null;\n  }\n}\n/** @ignore */\nGlUniformGroupSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem\n  ],\n  name: \"uniformGroup\"\n};\n\nexport { GlUniformGroupSystem };\n//# sourceMappingURL=GlUniformGroupSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { generateUniformsSync } from './utils/generateUniformsSync';\n\nimport type { UniformsSyncCallback } from '../../shared/shader/types';\nimport type { UniformGroup } from '../../shared/shader/UniformGroup';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GlProgram, GlUniformData } from './GlProgram';\n\n/**\n * System plugin to the renderer to manage shaders.\n * @memberof rendering\n */\nexport class GlUniformGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'uniformGroup',\n    } as const;\n\n    /**\n     * The current WebGL rendering context.\n     * @member {WebGLRenderingContext}\n     */\n    protected gl: GlRenderingContext;\n\n    /** Cache to holds the generated functions. Stored against UniformObjects unique signature. */\n    private _cache: Record<string, UniformsSyncCallback> = {};\n    private _renderer: WebGLRenderer;\n\n    private _uniformGroupSyncHash: Record<string, Record<string, UniformsSyncCallback>> = {};\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n\n        this.gl = null;\n        this._cache = {};\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this.gl = gl;\n    }\n\n    /**\n     * Uploads the uniforms values to the currently bound shader.\n     * @param group - the uniforms values that be applied to the current shader\n     * @param program\n     * @param syncData\n     * @param syncData.textureCount\n     */\n    public updateUniformGroup(group: UniformGroup, program: GlProgram, syncData: { textureCount: number }): void\n    {\n        const programData = this._renderer.shader._getProgramData(program);\n\n        if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid])\n        {\n            programData.uniformDirtyGroups[group.uid] = group._dirtyId;\n\n            const syncFunc = this._getUniformSyncFunction(group, program);\n\n            syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);\n        }\n    }\n\n    /**\n     * Overrideable by the pixi.js/unsafe-eval package to use static syncUniforms instead.\n     * @param group\n     * @param program\n     */\n    private _getUniformSyncFunction(group: UniformGroup, program: GlProgram): UniformsSyncCallback\n    {\n        return this._uniformGroupSyncHash[group._signature]?.[program._key]\n            || this._createUniformSyncFunction(group, program);\n    }\n\n    private _createUniformSyncFunction(group: UniformGroup, program: GlProgram): UniformsSyncCallback\n    {\n        const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature]\n            || (this._uniformGroupSyncHash[group._signature] = {});\n\n        const id = this._getSignature(group, program._uniformData, 'u');\n\n        if (!this._cache[id])\n        {\n            this._cache[id] = this._generateUniformsSync(group, program._uniformData);\n        }\n\n        uniformGroupSyncHash[program._key] = this._cache[id];\n\n        return uniformGroupSyncHash[program._key];\n    }\n\n    private _generateUniformsSync(group: UniformGroup, uniformData: Record<string, GlUniformData>): UniformsSyncCallback\n    {\n        return generateUniformsSync(group, uniformData);\n    }\n\n    /**\n     * Takes a uniform group and data and generates a unique signature for them.\n     * @param group - The uniform group to get signature of\n     * @param group.uniforms\n     * @param uniformData - Uniform information generated by the shader\n     * @param preFix\n     * @returns Unique signature of the uniform group\n     */\n    private _getSignature(group: UniformGroup, uniformData: Record<string, any>, preFix: string): string\n    {\n        const uniforms = group.uniforms;\n\n        const strings = [`${preFix}-`];\n\n        for (const i in uniforms)\n        {\n            strings.push(i);\n\n            if (uniformData[i])\n            {\n                strings.push(uniformData[i].type);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    /** Destroys this System and removes all its textures. */\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._cache = null;\n    }\n}\n","import { BufferResource } from '../../../shared/buffer/BufferResource.mjs';\nimport { UniformGroup } from '../../../shared/shader/UniformGroup.mjs';\nimport { uniformParsers } from '../../../shared/shader/utils/uniformParsers.mjs';\nimport { UNIFORM_TO_SINGLE_SETTERS, UNIFORM_TO_ARRAY_SETTERS } from './generateUniformsSyncTypes.mjs';\n\n\"use strict\";\nfunction generateUniformsSync(group, uniformData) {\n  const funcFragments = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n        var name = null;\n    `];\n  for (const i in group.uniforms) {\n    if (!uniformData[i]) {\n      if (group.uniforms[i] instanceof UniformGroup) {\n        if (group.uniforms[i].ubo) {\n          funcFragments.push(`\n                        renderer.shader.bindUniformBlock(uv.${i}, \"${i}\");\n                    `);\n        } else {\n          funcFragments.push(`\n                        renderer.shader.updateUniformGroup(uv.${i});\n                    `);\n        }\n      } else if (group.uniforms[i] instanceof BufferResource) {\n        funcFragments.push(`\n                        renderer.shader.bindBufferResource(uv.${i}, \"${i}\");\n                    `);\n      }\n      continue;\n    }\n    const uniform = group.uniformStructures[i];\n    let parsed = false;\n    for (let j = 0; j < uniformParsers.length; j++) {\n      const parser = uniformParsers[j];\n      if (uniform.type === parser.type && parser.test(uniform)) {\n        funcFragments.push(`name = \"${i}\";`, uniformParsers[j].uniform);\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;\n      const template = templateType[uniform.type].replace(\"location\", `ud[\"${i}\"].location`);\n      funcFragments.push(`\n            cu = ud[\"${i}\"];\n            cv = cu.value;\n            v = uv[\"${i}\"];\n            ${template};`);\n    }\n  }\n  return new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", funcFragments.join(\"\\n\"));\n}\n\nexport { generateUniformsSync };\n//# sourceMappingURL=generateUniformsSync.mjs.map\n","// cu = Cached value's uniform data field\n// cv = Cached value\n// v = value to upload\n// ud = uniformData\n// uv = uniformValue\n\nimport { BufferResource } from '../../../shared/buffer/BufferResource';\nimport { UniformGroup } from '../../../shared/shader/UniformGroup';\nimport { uniformParsers } from '../../../shared/shader/utils/uniformParsers';\nimport { UNIFORM_TO_ARRAY_SETTERS, UNIFORM_TO_SINGLE_SETTERS } from './generateUniformsSyncTypes';\n\nimport type { UniformsSyncCallback } from '../../../shared/shader/types';\n\nexport function generateUniformsSync(group: UniformGroup, uniformData: Record<string, any>): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n        var name = null;\n    `];\n\n    for (const i in group.uniforms)\n    {\n        if (!uniformData[i])\n        {\n            if (group.uniforms[i] instanceof UniformGroup)\n            {\n                if ((group.uniforms[i] as UniformGroup).ubo)\n                {\n                    funcFragments.push(`\n                        renderer.shader.bindUniformBlock(uv.${i}, \"${i}\");\n                    `);\n                }\n                else\n                {\n                    funcFragments.push(`\n                        renderer.shader.updateUniformGroup(uv.${i});\n                    `);\n                }\n            }\n            else if (group.uniforms[i] instanceof BufferResource)\n            {\n                funcFragments.push(`\n                        renderer.shader.bindBufferResource(uv.${i}, \"${i}\");\n                    `);\n            }\n\n            continue;\n        }\n\n        const uniform = group.uniformStructures[i];\n\n        let parsed = false;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const parser = uniformParsers[j];\n\n            if (uniform.type === parser.type && parser.test(uniform))\n            {\n                funcFragments.push(`name = \"${i}\";`, uniformParsers[j].uniform);\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;\n\n            const template = templateType[uniform.type].replace('location', `ud[\"${i}\"].location`);\n\n            funcFragments.push(`\n            cu = ud[\"${i}\"];\n            cv = cu.value;\n            v = uv[\"${i}\"];\n            ${template};`);\n        }\n    }\n\n    /*\n     * the introduction of syncData is to solve an issue where textures in uniform groups are not set correctly\n     * the texture count was always starting from 0 in each group. This needs to increment each time a texture is used\n     * no matter which group is being used\n     *\n     */\n    // eslint-disable-next-line no-new-func\n    return new Function('ud', 'uv', 'renderer', 'syncData', funcFragments.join('\\n')) as UniformsSyncCallback;\n}\n","\"use strict\";\nconst UNIFORM_TO_SINGLE_SETTERS = {\n  f32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1f(location, v);\n        }`,\n  \"vec2<f32>\": `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2f(location, v[0], v[1]);\n        }`,\n  \"vec3<f32>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3f(location, v[0], v[1], v[2]);\n        }`,\n  \"vec4<f32>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n        }`,\n  i32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }`,\n  \"vec2<i32>\": `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }`,\n  \"vec3<i32>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }`,\n  \"vec4<i32>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }`,\n  u32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1ui(location, v);\n        }`,\n  \"vec2<u32>\": `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2ui(location, v[0], v[1]);\n        }`,\n  \"vec3<u32>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3ui(location, v[0], v[1], v[2]);\n        }`,\n  \"vec4<u32>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n        }`,\n  bool: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }`,\n  \"vec2<bool>\": `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }`,\n  \"vec3<bool>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }`,\n  \"vec4<bool>\": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }`,\n  \"mat2x2<f32>\": `gl.uniformMatrix2fv(location, false, v);`,\n  \"mat3x3<f32>\": `gl.uniformMatrix3fv(location, false, v);`,\n  \"mat4x4<f32>\": `gl.uniformMatrix4fv(location, false, v);`\n};\nconst UNIFORM_TO_ARRAY_SETTERS = {\n  f32: `gl.uniform1fv(location, v);`,\n  \"vec2<f32>\": `gl.uniform2fv(location, v);`,\n  \"vec3<f32>\": `gl.uniform3fv(location, v);`,\n  \"vec4<f32>\": `gl.uniform4fv(location, v);`,\n  \"mat2x2<f32>\": `gl.uniformMatrix2fv(location, false, v);`,\n  \"mat3x3<f32>\": `gl.uniformMatrix3fv(location, false, v);`,\n  \"mat4x4<f32>\": `gl.uniformMatrix4fv(location, false, v);`,\n  i32: `gl.uniform1iv(location, v);`,\n  \"vec2<i32>\": `gl.uniform2iv(location, v);`,\n  \"vec3<i32>\": `gl.uniform3iv(location, v);`,\n  \"vec4<i32>\": `gl.uniform4iv(location, v);`,\n  u32: `gl.uniform1iv(location, v);`,\n  \"vec2<u32>\": `gl.uniform2iv(location, v);`,\n  \"vec3<u32>\": `gl.uniform3iv(location, v);`,\n  \"vec4<u32>\": `gl.uniform4iv(location, v);`,\n  bool: `gl.uniform1iv(location, v);`,\n  \"vec2<bool>\": `gl.uniform2iv(location, v);`,\n  \"vec3<bool>\": `gl.uniform3iv(location, v);`,\n  \"vec4<bool>\": `gl.uniform4iv(location, v);`\n};\n\nexport { UNIFORM_TO_ARRAY_SETTERS, UNIFORM_TO_SINGLE_SETTERS };\n//# sourceMappingURL=generateUniformsSyncTypes.mjs.map\n","// cu = Cached value's uniform data field\n// cv = Cached value\n// v = value to upload\n// ud = uniformData\n// uv = uniformValue\n\nimport type { UNIFORM_TYPES } from '../../../shared/shader/types';\n\nexport type ArraySetterFunction = (v: any, location: WebGLUniformLocation, gl: any) => void;\n\nexport const UNIFORM_TO_SINGLE_SETTERS: Record<UNIFORM_TYPES | string, string> = {\n    f32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1f(location, v);\n        }`,\n    'vec2<f32>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2f(location, v[0], v[1]);\n        }`,\n    'vec3<f32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3f(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<f32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n        }`,\n    i32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }`,\n    'vec2<i32>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }`,\n    'vec3<i32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<i32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }`,\n    u32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1ui(location, v);\n        }`,\n    'vec2<u32>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2ui(location, v[0], v[1]);\n        }`,\n    'vec3<u32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3ui(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<u32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n        }`,\n    bool: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }`,\n    'vec2<bool>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }`,\n    'vec3<bool>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<bool>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }`,\n    'mat2x2<f32>': `gl.uniformMatrix2fv(location, false, v);`,\n    'mat3x3<f32>': `gl.uniformMatrix3fv(location, false, v);`,\n    'mat4x4<f32>': `gl.uniformMatrix4fv(location, false, v);`,\n};\n\nexport const UNIFORM_TO_ARRAY_SETTERS: Record<UNIFORM_TYPES | string, string> = {\n    f32: `gl.uniform1fv(location, v);`,\n    'vec2<f32>': `gl.uniform2fv(location, v);`,\n    'vec3<f32>': `gl.uniform3fv(location, v);`,\n    'vec4<f32>': `gl.uniform4fv(location, v);`,\n    'mat2x2<f32>': `gl.uniformMatrix2fv(location, false, v);`,\n    'mat3x3<f32>': `gl.uniformMatrix3fv(location, false, v);`,\n    'mat4x4<f32>': `gl.uniformMatrix4fv(location, false, v);`,\n    i32: `gl.uniform1iv(location, v);`,\n    'vec2<i32>': `gl.uniform2iv(location, v);`,\n    'vec3<i32>': `gl.uniform3iv(location, v);`,\n    'vec4<i32>': `gl.uniform4iv(location, v);`,\n    u32: `gl.uniform1iv(location, v);`,\n    'vec2<u32>': `gl.uniform2iv(location, v);`,\n    'vec3<u32>': `gl.uniform3iv(location, v);`,\n    'vec4<u32>': `gl.uniform4iv(location, v);`,\n    bool: `gl.uniform1iv(location, v);`,\n    'vec2<bool>': `gl.uniform2iv(location, v);`,\n    'vec3<bool>': `gl.uniform3iv(location, v);`,\n    'vec4<bool>': `gl.uniform4iv(location, v);`,\n};\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { State } from '../../shared/state/State.mjs';\nimport { mapWebGLBlendModesToPixi } from './mapWebGLBlendModesToPixi.mjs';\n\n\"use strict\";\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _GlStateSystem = class _GlStateSystem {\n  constructor() {\n    this.gl = null;\n    this.stateId = 0;\n    this.polygonOffset = 0;\n    this.blendMode = \"none\";\n    this._blendEq = false;\n    this.map = [];\n    this.map[BLEND] = this.setBlend;\n    this.map[OFFSET] = this.setOffset;\n    this.map[CULLING] = this.setCullFace;\n    this.map[DEPTH_TEST] = this.setDepthTest;\n    this.map[WINDING] = this.setFrontFace;\n    this.map[DEPTH_MASK] = this.setDepthMask;\n    this.checks = [];\n    this.defaultState = State.for2d();\n  }\n  contextChange(gl) {\n    this.gl = gl;\n    this.blendModesMap = mapWebGLBlendModesToPixi(gl);\n    this.reset();\n  }\n  /**\n   * Sets the current state\n   * @param {*} state - The state to set.\n   */\n  set(state) {\n    state = state || this.defaultState;\n    if (this.stateId !== state.data) {\n      let diff = this.stateId ^ state.data;\n      let i = 0;\n      while (diff) {\n        if (diff & 1) {\n          this.map[i].call(this, !!(state.data & 1 << i));\n        }\n        diff = diff >> 1;\n        i++;\n      }\n      this.stateId = state.data;\n    }\n    for (let i = 0; i < this.checks.length; i++) {\n      this.checks[i](this, state);\n    }\n  }\n  /**\n   * Sets the state, when previous state is unknown.\n   * @param {*} state - The state to set\n   */\n  forceState(state) {\n    state = state || this.defaultState;\n    for (let i = 0; i < this.map.length; i++) {\n      this.map[i].call(this, !!(state.data & 1 << i));\n    }\n    for (let i = 0; i < this.checks.length; i++) {\n      this.checks[i](this, state);\n    }\n    this.stateId = state.data;\n  }\n  /**\n   * Sets whether to enable or disable blending.\n   * @param value - Turn on or off WebGl blending.\n   */\n  setBlend(value) {\n    this._updateCheck(_GlStateSystem._checkBlendMode, value);\n    this.gl[value ? \"enable\" : \"disable\"](this.gl.BLEND);\n  }\n  /**\n   * Sets whether to enable or disable polygon offset fill.\n   * @param value - Turn on or off webgl polygon offset testing.\n   */\n  setOffset(value) {\n    this._updateCheck(_GlStateSystem._checkPolygonOffset, value);\n    this.gl[value ? \"enable\" : \"disable\"](this.gl.POLYGON_OFFSET_FILL);\n  }\n  /**\n   * Sets whether to enable or disable depth test.\n   * @param value - Turn on or off webgl depth testing.\n   */\n  setDepthTest(value) {\n    this.gl[value ? \"enable\" : \"disable\"](this.gl.DEPTH_TEST);\n  }\n  /**\n   * Sets whether to enable or disable depth mask.\n   * @param value - Turn on or off webgl depth mask.\n   */\n  setDepthMask(value) {\n    this.gl.depthMask(value);\n  }\n  /**\n   * Sets whether to enable or disable cull face.\n   * @param {boolean} value - Turn on or off webgl cull face.\n   */\n  setCullFace(value) {\n    this.gl[value ? \"enable\" : \"disable\"](this.gl.CULL_FACE);\n  }\n  /**\n   * Sets the gl front face.\n   * @param {boolean} value - true is clockwise and false is counter-clockwise\n   */\n  setFrontFace(value) {\n    this.gl.frontFace(this.gl[value ? \"CW\" : \"CCW\"]);\n  }\n  /**\n   * Sets the blend mode.\n   * @param {number} value - The blend mode to set to.\n   */\n  setBlendMode(value) {\n    if (!this.blendModesMap[value]) {\n      value = \"normal\";\n    }\n    if (value === this.blendMode) {\n      return;\n    }\n    this.blendMode = value;\n    const mode = this.blendModesMap[value];\n    const gl = this.gl;\n    if (mode.length === 2) {\n      gl.blendFunc(mode[0], mode[1]);\n    } else {\n      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);\n    }\n    if (mode.length === 6) {\n      this._blendEq = true;\n      gl.blendEquationSeparate(mode[4], mode[5]);\n    } else if (this._blendEq) {\n      this._blendEq = false;\n      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n    }\n  }\n  /**\n   * Sets the polygon offset.\n   * @param {number} value - the polygon offset\n   * @param {number} scale - the polygon offset scale\n   */\n  setPolygonOffset(value, scale) {\n    this.gl.polygonOffset(value, scale);\n  }\n  // used\n  /** Resets all the logic and disables the VAOs. */\n  reset() {\n    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);\n    this.forceState(this.defaultState);\n    this._blendEq = true;\n    this.blendMode = \"\";\n    this.setBlendMode(\"normal\");\n  }\n  /**\n   * Checks to see which updates should be checked based on which settings have been activated.\n   *\n   * For example, if blend is enabled then we should check the blend modes each time the state is changed\n   * or if polygon fill is activated then we need to check if the polygon offset changes.\n   * The idea is that we only check what we have too.\n   * @param func - the checking function to add or remove\n   * @param value - should the check function be added or removed.\n   */\n  _updateCheck(func, value) {\n    const index = this.checks.indexOf(func);\n    if (value && index === -1) {\n      this.checks.push(func);\n    } else if (!value && index !== -1) {\n      this.checks.splice(index, 1);\n    }\n  }\n  /**\n   * A private little wrapper function that we call to check the blend mode.\n   * @param system - the System to perform the state check on\n   * @param state - the state that the blendMode will pulled from\n   */\n  static _checkBlendMode(system, state) {\n    system.setBlendMode(state.blendMode);\n  }\n  /**\n   * A private little wrapper function that we call to check the polygon offset.\n   * @param system - the System to perform the state check on\n   * @param state - the state that the blendMode will pulled from\n   */\n  static _checkPolygonOffset(system, state) {\n    system.setPolygonOffset(1, state.polygonOffset);\n  }\n  /**\n   * @ignore\n   */\n  destroy() {\n    this.gl = null;\n    this.checks.length = 0;\n  }\n};\n/** @ignore */\n_GlStateSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem\n  ],\n  name: \"state\"\n};\nlet GlStateSystem = _GlStateSystem;\n\nexport { GlStateSystem };\n//# sourceMappingURL=GlStateSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { State } from '../../shared/state/State';\nimport { mapWebGLBlendModesToPixi } from './mapWebGLBlendModesToPixi';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\n\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * System plugin to the renderer to manage WebGL state machines\n * @memberof rendering\n */\nexport class GlStateSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'state',\n    } as const;\n\n    /**\n     * State ID\n     * @readonly\n     */\n    public stateId: number;\n\n    /**\n     * Polygon offset\n     * @readonly\n     */\n    public polygonOffset: number;\n\n    /**\n     * Blend mode\n     * @default 'none'\n     * @readonly\n     */\n    public blendMode: BLEND_MODES;\n\n    /** Whether current blend equation is different */\n    protected _blendEq: boolean;\n\n    /**\n     * GL context\n     * @member {WebGLRenderingContext}\n     * @readonly\n     */\n    protected gl: GlRenderingContext;\n\n    protected blendModesMap: Record<BLEND_MODES, number[]>;\n\n    /**\n     * Collection of calls\n     * @member {Function[]}\n     */\n    protected readonly map: ((value: boolean) => void)[];\n\n    /**\n     * Collection of check calls\n     * @member {Function[]}\n     */\n    protected readonly checks: ((system: this, state: State) => void)[];\n\n    /**\n     * Default WebGL State\n     * @readonly\n     */\n    protected defaultState: State;\n\n    constructor()\n    {\n        this.gl = null;\n\n        this.stateId = 0;\n        this.polygonOffset = 0;\n        this.blendMode = 'none';\n\n        this._blendEq = false;\n\n        // map functions for when we set state..\n        this.map = [];\n        this.map[BLEND] = this.setBlend;\n        this.map[OFFSET] = this.setOffset;\n        this.map[CULLING] = this.setCullFace;\n        this.map[DEPTH_TEST] = this.setDepthTest;\n        this.map[WINDING] = this.setFrontFace;\n        this.map[DEPTH_MASK] = this.setDepthMask;\n\n        this.checks = [];\n\n        this.defaultState = State.for2d();\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this.gl = gl;\n\n        this.blendModesMap = mapWebGLBlendModesToPixi(gl);\n\n        this.reset();\n    }\n\n    /**\n     * Sets the current state\n     * @param {*} state - The state to set.\n     */\n    public set(state: State): void\n    {\n        state = state || this.defaultState;\n\n        // TODO maybe to an object check? ( this.state === state )?\n        if (this.stateId !== state.data)\n        {\n            let diff = this.stateId ^ state.data;\n            let i = 0;\n\n            // order from least to most common\n            while (diff)\n            {\n                if (diff & 1)\n                {\n                    // state change!\n                    this.map[i].call(this, !!(state.data & (1 << i)));\n                }\n\n                diff = diff >> 1;\n                i++;\n            }\n\n            this.stateId = state.data;\n        }\n\n        // based on the above settings we check for specific modes..\n        // for example if blend is active we check and set the blend modes\n        // or of polygon offset is active we check the poly depth.\n        for (let i = 0; i < this.checks.length; i++)\n        {\n            this.checks[i](this, state);\n        }\n    }\n\n    /**\n     * Sets the state, when previous state is unknown.\n     * @param {*} state - The state to set\n     */\n    public forceState(state: State): void\n    {\n        state = state || this.defaultState;\n        for (let i = 0; i < this.map.length; i++)\n        {\n            this.map[i].call(this, !!(state.data & (1 << i)));\n        }\n        for (let i = 0; i < this.checks.length; i++)\n        {\n            this.checks[i](this, state);\n        }\n\n        this.stateId = state.data;\n    }\n\n    /**\n     * Sets whether to enable or disable blending.\n     * @param value - Turn on or off WebGl blending.\n     */\n    public setBlend(value: boolean): void\n    {\n        this._updateCheck(GlStateSystem._checkBlendMode, value);\n\n        this.gl[value ? 'enable' : 'disable'](this.gl.BLEND);\n    }\n\n    /**\n     * Sets whether to enable or disable polygon offset fill.\n     * @param value - Turn on or off webgl polygon offset testing.\n     */\n    public setOffset(value: boolean): void\n    {\n        this._updateCheck(GlStateSystem._checkPolygonOffset, value);\n\n        this.gl[value ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL);\n    }\n\n    /**\n     * Sets whether to enable or disable depth test.\n     * @param value - Turn on or off webgl depth testing.\n     */\n    public setDepthTest(value: boolean): void\n    {\n        this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST);\n    }\n\n    /**\n     * Sets whether to enable or disable depth mask.\n     * @param value - Turn on or off webgl depth mask.\n     */\n    public setDepthMask(value: boolean): void\n    {\n        this.gl.depthMask(value);\n    }\n\n    /**\n     * Sets whether to enable or disable cull face.\n     * @param {boolean} value - Turn on or off webgl cull face.\n     */\n    public setCullFace(value: boolean): void\n    {\n        this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);\n    }\n\n    /**\n     * Sets the gl front face.\n     * @param {boolean} value - true is clockwise and false is counter-clockwise\n     */\n    public setFrontFace(value: boolean): void\n    {\n        this.gl.frontFace(this.gl[value ? 'CW' : 'CCW']);\n    }\n\n    /**\n     * Sets the blend mode.\n     * @param {number} value - The blend mode to set to.\n     */\n    public setBlendMode(value: BLEND_MODES): void\n    {\n        if (!this.blendModesMap[value])\n        {\n            value = 'normal';\n        }\n\n        if (value === this.blendMode)\n        {\n            return;\n        }\n\n        this.blendMode = value;\n\n        const mode = this.blendModesMap[value];\n        const gl = this.gl;\n\n        if (mode.length === 2)\n        {\n            gl.blendFunc(mode[0], mode[1]);\n        }\n        else\n        {\n            gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);\n        }\n\n        if (mode.length === 6)\n        {\n            this._blendEq = true;\n            gl.blendEquationSeparate(mode[4], mode[5]);\n        }\n        else if (this._blendEq)\n        {\n            this._blendEq = false;\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n        }\n    }\n\n    /**\n     * Sets the polygon offset.\n     * @param {number} value - the polygon offset\n     * @param {number} scale - the polygon offset scale\n     */\n    public setPolygonOffset(value: number, scale: number): void\n    {\n        this.gl.polygonOffset(value, scale);\n    }\n\n    // used\n    /** Resets all the logic and disables the VAOs. */\n    public reset(): void\n    {\n        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);\n\n        this.forceState(this.defaultState);\n\n        this._blendEq = true;\n        // setting to '' means the blend mode will be set as soon as we set the first blend mode when rendering!\n        this.blendMode = '' as BLEND_MODES;\n        this.setBlendMode('normal');\n    }\n\n    /**\n     * Checks to see which updates should be checked based on which settings have been activated.\n     *\n     * For example, if blend is enabled then we should check the blend modes each time the state is changed\n     * or if polygon fill is activated then we need to check if the polygon offset changes.\n     * The idea is that we only check what we have too.\n     * @param func - the checking function to add or remove\n     * @param value - should the check function be added or removed.\n     */\n    private _updateCheck(func: (system: this, state: State) => void, value: boolean): void\n    {\n        const index = this.checks.indexOf(func);\n\n        if (value && index === -1)\n        {\n            this.checks.push(func);\n        }\n        else if (!value && index !== -1)\n        {\n            this.checks.splice(index, 1);\n        }\n    }\n\n    /**\n     * A private little wrapper function that we call to check the blend mode.\n     * @param system - the System to perform the state check on\n     * @param state - the state that the blendMode will pulled from\n     */\n    private static _checkBlendMode(system: GlStateSystem, state: State): void\n    {\n        system.setBlendMode(state.blendMode);\n    }\n\n    /**\n     * A private little wrapper function that we call to check the polygon offset.\n     * @param system - the System to perform the state check on\n     * @param state - the state that the blendMode will pulled from\n     */\n    private static _checkPolygonOffset(system: GlStateSystem, state: State): void\n    {\n        system.setPolygonOffset(1, state.polygonOffset);\n    }\n\n    /**\n     * @ignore\n     */\n    public destroy(): void\n    {\n        this.gl = null;\n        this.checks.length = 0;\n    }\n}\n","\"use strict\";\nfunction mapWebGLBlendModesToPixi(gl) {\n  const blendMap = {};\n  blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  blendMap.add = [gl.ONE, gl.ONE];\n  blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  blendMap.none = [0, 0];\n  blendMap[\"normal-npm\"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  blendMap[\"add-npm\"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];\n  blendMap[\"screen-npm\"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n  blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];\n  return blendMap;\n}\n\nexport { mapWebGLBlendModesToPixi };\n//# sourceMappingURL=mapWebGLBlendModesToPixi.mjs.map\n","import type { BLEND_MODES } from '../../shared/state/const';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\n\n/**\n * Maps gl blend combinations to WebGL.\n * @param gl\n * @returns {object} Map of gl blend combinations to WebGL.\n */\nexport function mapWebGLBlendModesToPixi(gl: GlRenderingContext): Record<BLEND_MODES, number[]>\n{\n    const blendMap: Partial<Record<BLEND_MODES, number[]>> = {};\n\n    // TODO - premultiply alpha would be different.\n    // add a boolean for that!\n    blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap.add = [gl.ONE, gl.ONE];\n    blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap.none = [0, 0];\n\n    // not-premultiplied blend modes\n    blendMap['normal-npm'] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap['add-npm'] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];\n    blendMap['screen-npm'] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n\n    blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];\n    // TODO - implement if requested!\n    // composite operations\n    // array[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];\n    // array[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];\n    // array[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\n    // array[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];\n    // array[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];\n    // array[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];\n    // array[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];\n    // array[BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\n    // SUBTRACT from flash\n    // array[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];\n\n    return blendMap as Record<BLEND_MODES, number[]>;\n}\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Texture } from '../../shared/texture/Texture.mjs';\nimport { GlTexture } from './GlTexture.mjs';\nimport { glUploadBufferImageResource } from './uploaders/glUploadBufferImageResource.mjs';\nimport { glUploadCompressedTextureResource } from './uploaders/glUploadCompressedTextureResource.mjs';\nimport { glUploadImageResource } from './uploaders/glUploadImageResource.mjs';\nimport { glUploadVideoResource } from './uploaders/glUploadVideoResource.mjs';\nimport { applyStyleParams } from './utils/applyStyleParams.mjs';\nimport { mapFormatToGlFormat } from './utils/mapFormatToGlFormat.mjs';\nimport { mapFormatToGlInternalFormat } from './utils/mapFormatToGlInternalFormat.mjs';\nimport { mapFormatToGlType } from './utils/mapFormatToGlType.mjs';\nimport './utils/unpremultiplyAlpha.mjs';\n\n\"use strict\";\nconst BYTES_PER_PIXEL = 4;\nclass GlTextureSystem {\n  constructor(renderer) {\n    this.managedTextures = [];\n    this._glTextures = /* @__PURE__ */ Object.create(null);\n    this._glSamplers = /* @__PURE__ */ Object.create(null);\n    this._boundTextures = [];\n    this._activeTextureLocation = -1;\n    this._boundSamplers = /* @__PURE__ */ Object.create(null);\n    this._uploads = {\n      image: glUploadImageResource,\n      buffer: glUploadBufferImageResource,\n      video: glUploadVideoResource,\n      compressed: glUploadCompressedTextureResource\n    };\n    // TODO - separate samplers will be a cool thing to add, but not right now!\n    this._useSeparateSamplers = false;\n    this._renderer = renderer;\n  }\n  contextChange(gl) {\n    this._gl = gl;\n    if (!this._mapFormatToInternalFormat) {\n      this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);\n      this._mapFormatToType = mapFormatToGlType(gl);\n      this._mapFormatToFormat = mapFormatToGlFormat(gl);\n    }\n    this._glTextures = /* @__PURE__ */ Object.create(null);\n    this._glSamplers = /* @__PURE__ */ Object.create(null);\n    this._boundSamplers = /* @__PURE__ */ Object.create(null);\n    for (let i = 0; i < 16; i++) {\n      this.bind(Texture.EMPTY, i);\n    }\n  }\n  initSource(source) {\n    this.bind(source);\n  }\n  bind(texture, location = 0) {\n    const source = texture.source;\n    if (texture) {\n      this.bindSource(source, location);\n      if (this._useSeparateSamplers) {\n        this._bindSampler(source.style, location);\n      }\n    } else {\n      this.bindSource(null, location);\n      if (this._useSeparateSamplers) {\n        this._bindSampler(null, location);\n      }\n    }\n  }\n  bindSource(source, location = 0) {\n    const gl = this._gl;\n    source._touched = this._renderer.textureGC.count;\n    if (this._boundTextures[location] !== source) {\n      this._boundTextures[location] = source;\n      this._activateLocation(location);\n      source = source || Texture.EMPTY.source;\n      const glTexture = this.getGlSource(source);\n      gl.bindTexture(glTexture.target, glTexture.texture);\n    }\n  }\n  _bindSampler(style, location = 0) {\n    const gl = this._gl;\n    if (!style) {\n      this._boundSamplers[location] = null;\n      gl.bindSampler(location, null);\n      return;\n    }\n    const sampler = this._getGlSampler(style);\n    if (this._boundSamplers[location] !== sampler) {\n      this._boundSamplers[location] = sampler;\n      gl.bindSampler(location, sampler);\n    }\n  }\n  unbind(texture) {\n    const source = texture.source;\n    const boundTextures = this._boundTextures;\n    const gl = this._gl;\n    for (let i = 0; i < boundTextures.length; i++) {\n      if (boundTextures[i] === source) {\n        this._activateLocation(i);\n        const glTexture = this.getGlSource(source);\n        gl.bindTexture(glTexture.target, null);\n        boundTextures[i] = null;\n      }\n    }\n  }\n  _activateLocation(location) {\n    if (this._activeTextureLocation !== location) {\n      this._activeTextureLocation = location;\n      this._gl.activeTexture(this._gl.TEXTURE0 + location);\n    }\n  }\n  _initSource(source) {\n    const gl = this._gl;\n    const glTexture = new GlTexture(gl.createTexture());\n    glTexture.type = this._mapFormatToType[source.format];\n    glTexture.internalFormat = this._mapFormatToInternalFormat[source.format];\n    glTexture.format = this._mapFormatToFormat[source.format];\n    if (source.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source.isPowerOfTwo)) {\n      const biggestDimension = Math.max(source.width, source.height);\n      source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n    }\n    this._glTextures[source.uid] = glTexture;\n    if (!this.managedTextures.includes(source)) {\n      source.on(\"update\", this.onSourceUpdate, this);\n      source.on(\"resize\", this.onSourceUpdate, this);\n      source.on(\"styleChange\", this.onStyleChange, this);\n      source.on(\"destroy\", this.onSourceDestroy, this);\n      source.on(\"unload\", this.onSourceUnload, this);\n      source.on(\"updateMipmaps\", this.onUpdateMipmaps, this);\n      this.managedTextures.push(source);\n    }\n    this.onSourceUpdate(source);\n    this.updateStyle(source, false);\n    return glTexture;\n  }\n  onStyleChange(source) {\n    this.updateStyle(source, false);\n  }\n  updateStyle(source, firstCreation) {\n    const gl = this._gl;\n    const glTexture = this.getGlSource(source);\n    gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n    this._boundTextures[this._activeTextureLocation] = source;\n    applyStyleParams(\n      source.style,\n      gl,\n      source.mipLevelCount > 1,\n      this._renderer.context.extensions.anisotropicFiltering,\n      \"texParameteri\",\n      gl.TEXTURE_2D,\n      // will force a clamp to edge if the texture is not a power of two\n      !this._renderer.context.supports.nonPowOf2wrapping && !source.isPowerOfTwo,\n      firstCreation\n    );\n  }\n  onSourceUnload(source) {\n    const glTexture = this._glTextures[source.uid];\n    if (!glTexture)\n      return;\n    this.unbind(source);\n    this._glTextures[source.uid] = null;\n    this._gl.deleteTexture(glTexture.texture);\n  }\n  onSourceUpdate(source) {\n    const gl = this._gl;\n    const glTexture = this.getGlSource(source);\n    gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n    this._boundTextures[this._activeTextureLocation] = source;\n    if (this._uploads[source.uploadMethodId]) {\n      this._uploads[source.uploadMethodId].upload(source, glTexture, gl, this._renderer.context.webGLVersion);\n    } else {\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.pixelWidth, source.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    }\n    if (source.autoGenerateMipmaps && source.mipLevelCount > 1) {\n      this.onUpdateMipmaps(source, false);\n    }\n  }\n  onUpdateMipmaps(source, bind = true) {\n    if (bind)\n      this.bindSource(source, 0);\n    const glTexture = this.getGlSource(source);\n    this._gl.generateMipmap(glTexture.target);\n  }\n  onSourceDestroy(source) {\n    source.off(\"destroy\", this.onSourceDestroy, this);\n    source.off(\"update\", this.onSourceUpdate, this);\n    source.off(\"resize\", this.onSourceUpdate, this);\n    source.off(\"unload\", this.onSourceUnload, this);\n    source.off(\"styleChange\", this.onStyleChange, this);\n    source.off(\"updateMipmaps\", this.onUpdateMipmaps, this);\n    this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n    this.onSourceUnload(source);\n  }\n  _initSampler(style) {\n    const gl = this._gl;\n    const glSampler = this._gl.createSampler();\n    this._glSamplers[style._resourceId] = glSampler;\n    applyStyleParams(\n      style,\n      gl,\n      this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,\n      this._renderer.context.extensions.anisotropicFiltering,\n      \"samplerParameteri\",\n      glSampler,\n      false,\n      true\n    );\n    return this._glSamplers[style._resourceId];\n  }\n  _getGlSampler(sampler) {\n    return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);\n  }\n  getGlSource(source) {\n    return this._glTextures[source.uid] || this._initSource(source);\n  }\n  generateCanvas(texture) {\n    const { pixels, width, height } = this.getPixels(texture);\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext(\"2d\");\n    if (ctx) {\n      const imageData = ctx.createImageData(width, height);\n      imageData.data.set(pixels);\n      ctx.putImageData(imageData, 0, 0);\n    }\n    return canvas;\n  }\n  getPixels(texture) {\n    const resolution = texture.source.resolution;\n    const frame = texture.frame;\n    const width = Math.max(Math.round(frame.width * resolution), 1);\n    const height = Math.max(Math.round(frame.height * resolution), 1);\n    const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n    const renderer = this._renderer;\n    const renderTarget = renderer.renderTarget.getRenderTarget(texture);\n    const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);\n    const gl = renderer.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);\n    gl.readPixels(\n      Math.round(frame.x * resolution),\n      Math.round(frame.y * resolution),\n      width,\n      height,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixels\n    );\n    if (false) {\n      unpremultiplyAlpha(pixels);\n    }\n    return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };\n  }\n  destroy() {\n    this.managedTextures.slice().forEach((source) => this.onSourceDestroy(source));\n    this.managedTextures = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGlTextureSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem\n  ],\n  name: \"texture\"\n};\n\nexport { GlTextureSystem };\n//# sourceMappingURL=GlTextureSystem.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Texture } from '../../shared/texture/Texture';\nimport { GlTexture } from './GlTexture';\nimport { glUploadBufferImageResource } from './uploaders/glUploadBufferImageResource';\nimport { glUploadCompressedTextureResource } from './uploaders/glUploadCompressedTextureResource';\nimport { glUploadImageResource } from './uploaders/glUploadImageResource';\nimport { glUploadVideoResource } from './uploaders/glUploadVideoResource';\nimport { applyStyleParams } from './utils/applyStyleParams';\nimport { mapFormatToGlFormat } from './utils/mapFormatToGlFormat';\nimport { mapFormatToGlInternalFormat } from './utils/mapFormatToGlInternalFormat';\nimport { mapFormatToGlType } from './utils/mapFormatToGlType';\nimport { unpremultiplyAlpha } from './utils/unpremultiplyAlpha';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { CanvasGenerator, GetPixelsOutput } from '../../shared/texture/GenerateCanvas';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { BindableTexture } from '../../shared/texture/Texture';\nimport type { TextureStyle } from '../../shared/texture/TextureStyle';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GLTextureUploader } from './uploaders/GLTextureUploader';\n\nconst BYTES_PER_PIXEL = 4;\n\n/**\n * The system for managing textures in WebGL.\n * @memberof rendering\n */\nexport class GlTextureSystem implements System, CanvasGenerator\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'texture',\n    } as const;\n\n    public readonly managedTextures: TextureSource[] = [];\n\n    private readonly _renderer: WebGLRenderer;\n\n    private _glTextures: Record<number, GlTexture> = Object.create(null);\n    private _glSamplers: Record<string, WebGLSampler> = Object.create(null);\n\n    private _boundTextures: TextureSource[] = [];\n    private _activeTextureLocation = -1;\n\n    private _boundSamplers: Record<number, WebGLSampler> = Object.create(null);\n\n    private readonly _uploads: Record<string, GLTextureUploader> = {\n        image: glUploadImageResource,\n        buffer: glUploadBufferImageResource,\n        video: glUploadVideoResource,\n        compressed: glUploadCompressedTextureResource,\n    };\n\n    private _gl: GlRenderingContext;\n    private _mapFormatToInternalFormat: Record<string, number>;\n    private _mapFormatToType: Record<string, number>;\n    private _mapFormatToFormat: Record<string, number>;\n\n    // TODO - separate samplers will be a cool thing to add, but not right now!\n    private readonly _useSeparateSamplers = false;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this._gl = gl;\n\n        if (!this._mapFormatToInternalFormat)\n        {\n            this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);\n\n            this._mapFormatToType = mapFormatToGlType(gl);\n            this._mapFormatToFormat = mapFormatToGlFormat(gl);\n        }\n\n        this._glTextures = Object.create(null);\n        this._glSamplers = Object.create(null);\n        this._boundSamplers = Object.create(null);\n\n        for (let i = 0; i < 16; i++)\n        {\n            this.bind(Texture.EMPTY, i);\n        }\n    }\n\n    public initSource(source: TextureSource)\n    {\n        this.bind(source);\n    }\n\n    public bind(texture: BindableTexture, location = 0)\n    {\n        const source = texture.source;\n\n        if (texture)\n        {\n            this.bindSource(source, location);\n\n            if (this._useSeparateSamplers)\n            {\n                this._bindSampler(source.style, location);\n            }\n        }\n        else\n        {\n            this.bindSource(null, location);\n\n            if (this._useSeparateSamplers)\n            {\n                this._bindSampler(null, location);\n            }\n        }\n    }\n\n    public bindSource(source: TextureSource, location = 0): void\n    {\n        const gl = this._gl;\n\n        source._touched = this._renderer.textureGC.count;\n\n        if (this._boundTextures[location] !== source)\n        {\n            this._boundTextures[location] = source;\n            this._activateLocation(location);\n\n            source = source || Texture.EMPTY.source;\n\n            // bind texture and source!\n            const glTexture = this.getGlSource(source);\n\n            gl.bindTexture(glTexture.target, glTexture.texture);\n        }\n    }\n\n    private _bindSampler(style: TextureStyle, location = 0): void\n    {\n        const gl = this._gl;\n\n        if (!style)\n        {\n            this._boundSamplers[location] = null;\n            gl.bindSampler(location, null);\n\n            return;\n        }\n\n        const sampler = this._getGlSampler(style);\n\n        if (this._boundSamplers[location] !== sampler)\n        {\n            this._boundSamplers[location] = sampler;\n            gl.bindSampler(location, sampler);\n        }\n    }\n\n    public unbind(texture: BindableTexture): void\n    {\n        const source = texture.source;\n        const boundTextures = this._boundTextures;\n        const gl = this._gl;\n\n        for (let i = 0; i < boundTextures.length; i++)\n        {\n            if (boundTextures[i] === source)\n            {\n                this._activateLocation(i);\n\n                const glTexture = this.getGlSource(source);\n\n                gl.bindTexture(glTexture.target, null);\n                boundTextures[i] = null;\n            }\n        }\n    }\n\n    private _activateLocation(location: number): void\n    {\n        if (this._activeTextureLocation !== location)\n        {\n            this._activeTextureLocation = location;\n            this._gl.activeTexture(this._gl.TEXTURE0 + location);\n        }\n    }\n\n    private _initSource(source: TextureSource): GlTexture\n    {\n        const gl = this._gl;\n\n        const glTexture = new GlTexture(gl.createTexture());\n\n        glTexture.type = this._mapFormatToType[source.format];\n        glTexture.internalFormat = this._mapFormatToInternalFormat[source.format];\n        glTexture.format = this._mapFormatToFormat[source.format];\n\n        if (source.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source.isPowerOfTwo))\n        {\n            const biggestDimension = Math.max(source.width, source.height);\n\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n\n        this._glTextures[source.uid] = glTexture;\n\n        if (!this.managedTextures.includes(source))\n        {\n            source.on('update', this.onSourceUpdate, this);\n            source.on('resize', this.onSourceUpdate, this);\n            source.on('styleChange', this.onStyleChange, this);\n            source.on('destroy', this.onSourceDestroy, this);\n            source.on('unload', this.onSourceUnload, this);\n            source.on('updateMipmaps', this.onUpdateMipmaps, this);\n\n            this.managedTextures.push(source);\n        }\n\n        this.onSourceUpdate(source);\n        this.updateStyle(source, false);\n\n        return glTexture;\n    }\n\n    protected onStyleChange(source: TextureSource): void\n    {\n        this.updateStyle(source, false);\n    }\n\n    protected updateStyle(source: TextureSource, firstCreation: boolean): void\n    {\n        const gl = this._gl;\n\n        const glTexture = this.getGlSource(source);\n\n        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n\n        this._boundTextures[this._activeTextureLocation] = source;\n\n        applyStyleParams(\n            source.style,\n            gl,\n            source.mipLevelCount > 1,\n            this._renderer.context.extensions.anisotropicFiltering,\n            'texParameteri',\n            gl.TEXTURE_2D,\n            // will force a clamp to edge if the texture is not a power of two\n            !this._renderer.context.supports.nonPowOf2wrapping && !source.isPowerOfTwo,\n            firstCreation,\n        );\n    }\n\n    protected onSourceUnload(source: TextureSource): void\n    {\n        const glTexture = this._glTextures[source.uid];\n\n        if (!glTexture) return;\n\n        this.unbind(source);\n        this._glTextures[source.uid] = null;\n\n        this._gl.deleteTexture(glTexture.texture);\n    }\n\n    protected onSourceUpdate(source: TextureSource): void\n    {\n        const gl = this._gl;\n\n        const glTexture = this.getGlSource(source);\n\n        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n\n        this._boundTextures[this._activeTextureLocation] = source;\n\n        if (this._uploads[source.uploadMethodId])\n        {\n            this._uploads[source.uploadMethodId].upload(source, glTexture, gl, this._renderer.context.webGLVersion);\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.pixelWidth, source.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        }\n\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1)\n        {\n            this.onUpdateMipmaps(source, false);\n        }\n    }\n\n    protected onUpdateMipmaps(source: TextureSource, bind = true): void\n    {\n        if (bind) this.bindSource(source, 0);\n\n        const glTexture = this.getGlSource(source);\n\n        this._gl.generateMipmap(glTexture.target);\n    }\n\n    protected onSourceDestroy(source: TextureSource): void\n    {\n        source.off('destroy', this.onSourceDestroy, this);\n        source.off('update', this.onSourceUpdate, this);\n        source.off('resize', this.onSourceUpdate, this);\n        source.off('unload', this.onSourceUnload, this);\n        source.off('styleChange', this.onStyleChange, this);\n        source.off('updateMipmaps', this.onUpdateMipmaps, this);\n\n        this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n\n        this.onSourceUnload(source);\n    }\n\n    private _initSampler(style: TextureStyle): WebGLSampler\n    {\n        const gl = this._gl;\n\n        const glSampler = this._gl.createSampler();\n\n        this._glSamplers[style._resourceId] = glSampler;\n\n        applyStyleParams(\n            style,\n            gl,\n            this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,\n            this._renderer.context.extensions.anisotropicFiltering,\n            'samplerParameteri',\n            glSampler,\n            false,\n            true,\n        );\n\n        return this._glSamplers[style._resourceId];\n    }\n\n    private _getGlSampler(sampler: TextureStyle): WebGLSampler\n    {\n        return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n\n    public getGlSource(source: TextureSource): GlTexture\n    {\n        return this._glTextures[source.uid] || this._initSource(source);\n    }\n\n    public generateCanvas(texture: Texture): ICanvas\n    {\n        const { pixels, width, height } = this.getPixels(texture);\n\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = width;\n        canvas.height = height;\n\n        const ctx = canvas.getContext('2d');\n\n        if (ctx)\n        {\n            const imageData = ctx.createImageData(width, height);\n\n            imageData.data.set(pixels);\n            ctx.putImageData(imageData, 0, 0);\n        }\n\n        return canvas;\n    }\n\n    public getPixels(texture: Texture): GetPixelsOutput\n    {\n        const resolution = texture.source.resolution;\n        const frame = texture.frame;\n\n        const width = Math.max(Math.round(frame.width * resolution), 1);\n        const height = Math.max(Math.round(frame.height * resolution), 1);\n        const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n        const renderer = this._renderer;\n\n        const renderTarget = renderer.renderTarget.getRenderTarget(texture);\n        const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);\n\n        const gl = renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);\n\n        gl.readPixels(\n            Math.round(frame.x * resolution),\n            Math.round(frame.y * resolution),\n            width,\n            height,\n            gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            pixels\n        );\n\n        // if (texture.source.premultiplyAlpha > 0)\n        // TODO - premultiplied alpha does not exist right now, need to add that back in!\n        // eslint-disable-next-line no-constant-condition\n        if (false)\n        {\n            unpremultiplyAlpha(pixels);\n        }\n\n        return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };\n    }\n\n    public destroy(): void\n    {\n        // we copy the array as the array with a slice as onSourceDestroy\n        // will remove the source from the real managedTextures array\n        this.managedTextures\n            .slice()\n            .forEach((source) => this.onSourceDestroy(source));\n\n        (this.managedTextures as null) = null;\n\n        (this._renderer as null) = null;\n    }\n}\n\n","import { GL_TARGETS, GL_TYPES, GL_FORMATS } from './const.mjs';\n\n\"use strict\";\nclass GlTexture {\n  constructor(texture) {\n    this.target = GL_TARGETS.TEXTURE_2D;\n    this.texture = texture;\n    this.width = -1;\n    this.height = -1;\n    this.type = GL_TYPES.UNSIGNED_BYTE;\n    this.internalFormat = GL_FORMATS.RGBA;\n    this.format = GL_FORMATS.RGBA;\n    this.samplerType = 0;\n  }\n}\n\nexport { GlTexture };\n//# sourceMappingURL=GlTexture.mjs.map\n","import { GL_FORMATS, GL_TARGETS, GL_TYPES } from './const';\n\n/**\n * Internal texture for WebGL context\n * @memberof rendering\n * @ignore\n */\nexport class GlTexture\n{\n    public target: GL_TARGETS = GL_TARGETS.TEXTURE_2D;\n\n    /** The WebGL texture. */\n    public texture: WebGLTexture;\n\n    /** Width of texture that was used in texImage2D. */\n    public width: number;\n\n    /** Height of texture that was used in texImage2D. */\n    public height: number;\n\n    /** Whether mip levels has to be generated. */\n    public mipmap: boolean;\n\n    /** Type copied from texture source. */\n    public type: number;\n\n    /** Type copied from texture source. */\n    public internalFormat: number;\n\n    /** Type of sampler corresponding to this texture. See {@link SAMPLER_TYPES} */\n    public samplerType: number;\n\n    public format: GL_FORMATS;\n\n    constructor(texture: WebGLTexture)\n    {\n        this.texture = texture;\n        this.width = -1;\n        this.height = -1;\n        this.type = GL_TYPES.UNSIGNED_BYTE;\n        this.internalFormat = GL_FORMATS.RGBA;\n        this.format = GL_FORMATS.RGBA;\n        this.samplerType = 0;\n    }\n}\n","\"use strict\";\nconst glUploadBufferImageResource = {\n  id: \"image\",\n  upload(source, glTexture, gl) {\n    if (glTexture.width === source.width || glTexture.height === source.height) {\n      gl.texSubImage2D(\n        gl.TEXTURE_2D,\n        0,\n        0,\n        0,\n        glTexture.format,\n        glTexture.type,\n        source.resource\n      );\n    } else {\n      gl.texImage2D(\n        glTexture.target,\n        0,\n        glTexture.internalFormat,\n        source.width,\n        source.height,\n        0,\n        glTexture.format,\n        glTexture.type,\n        source.resource\n      );\n    }\n    glTexture.width = source.width;\n    glTexture.height = source.height;\n  }\n};\n\nexport { glUploadBufferImageResource };\n//# sourceMappingURL=glUploadBufferImageResource.mjs.map\n","import type { TextureSource } from '../../../shared/texture/sources/TextureSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\nexport const glUploadBufferImageResource = {\n\n    id: 'image',\n\n    upload(source: TextureSource, glTexture: GlTexture, gl: GlRenderingContext)\n    {\n        if (glTexture.width === source.width || glTexture.height === source.height)\n        {\n            gl.texSubImage2D(\n                gl.TEXTURE_2D,\n                0,\n                0,\n                0,\n                glTexture.format,\n                glTexture.type,\n                source.resource\n            );\n        }\n        else\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                source.width,\n                source.height,\n                0,\n                glTexture.format,\n                glTexture.type,\n                source.resource\n            );\n        }\n\n        glTexture.width = source.width;\n        glTexture.height = source.height;\n    }\n} as GLTextureUploader;\n\n","\"use strict\";\nconst compressedFormatMap = {\n  \"bc1-rgba-unorm\": true,\n  \"bc1-rgba-unorm-srgb\": true,\n  \"bc2-rgba-unorm\": true,\n  \"bc2-rgba-unorm-srgb\": true,\n  \"bc3-rgba-unorm\": true,\n  \"bc3-rgba-unorm-srgb\": true,\n  \"bc4-r-unorm\": true,\n  \"bc4-r-snorm\": true,\n  \"bc5-rg-unorm\": true,\n  \"bc5-rg-snorm\": true,\n  \"bc6h-rgb-ufloat\": true,\n  \"bc6h-rgb-float\": true,\n  \"bc7-rgba-unorm\": true,\n  \"bc7-rgba-unorm-srgb\": true,\n  // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\n  // supported by the device/user agent and enabled in requestDevice.\n  \"etc2-rgb8unorm\": true,\n  \"etc2-rgb8unorm-srgb\": true,\n  \"etc2-rgb8a1unorm\": true,\n  \"etc2-rgb8a1unorm-srgb\": true,\n  \"etc2-rgba8unorm\": true,\n  \"etc2-rgba8unorm-srgb\": true,\n  \"eac-r11unorm\": true,\n  \"eac-r11snorm\": true,\n  \"eac-rg11unorm\": true,\n  \"eac-rg11snorm\": true,\n  // ASTC compressed formats usable if \"texture-compression-astc\" is both\n  // supported by the device/user agent and enabled in requestDevice.\n  \"astc-4x4-unorm\": true,\n  \"astc-4x4-unorm-srgb\": true,\n  \"astc-5x4-unorm\": true,\n  \"astc-5x4-unorm-srgb\": true,\n  \"astc-5x5-unorm\": true,\n  \"astc-5x5-unorm-srgb\": true,\n  \"astc-6x5-unorm\": true,\n  \"astc-6x5-unorm-srgb\": true,\n  \"astc-6x6-unorm\": true,\n  \"astc-6x6-unorm-srgb\": true,\n  \"astc-8x5-unorm\": true,\n  \"astc-8x5-unorm-srgb\": true,\n  \"astc-8x6-unorm\": true,\n  \"astc-8x6-unorm-srgb\": true,\n  \"astc-8x8-unorm\": true,\n  \"astc-8x8-unorm-srgb\": true,\n  \"astc-10x5-unorm\": true,\n  \"astc-10x5-unorm-srgb\": true,\n  \"astc-10x6-unorm\": true,\n  \"astc-10x6-unorm-srgb\": true,\n  \"astc-10x8-unorm\": true,\n  \"astc-10x8-unorm-srgb\": true,\n  \"astc-10x10-unorm\": true,\n  \"astc-10x10-unorm-srgb\": true,\n  \"astc-12x10-unorm\": true,\n  \"astc-12x10-unorm-srgb\": true,\n  \"astc-12x12-unorm\": true,\n  \"astc-12x12-unorm-srgb\": true\n};\nconst glUploadCompressedTextureResource = {\n  id: \"compressed\",\n  upload(source, glTexture, gl) {\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n    let mipWidth = source.pixelWidth;\n    let mipHeight = source.pixelHeight;\n    const compressed = !!compressedFormatMap[source.format];\n    for (let i = 0; i < source.resource.length; i++) {\n      const levelBuffer = source.resource[i];\n      if (compressed) {\n        gl.compressedTexImage2D(\n          gl.TEXTURE_2D,\n          i,\n          glTexture.internalFormat,\n          mipWidth,\n          mipHeight,\n          0,\n          levelBuffer\n        );\n      } else {\n        gl.texImage2D(\n          gl.TEXTURE_2D,\n          i,\n          glTexture.internalFormat,\n          mipWidth,\n          mipHeight,\n          0,\n          glTexture.format,\n          glTexture.type,\n          levelBuffer\n        );\n      }\n      mipWidth = Math.max(mipWidth >> 1, 1);\n      mipHeight = Math.max(mipHeight >> 1, 1);\n    }\n  }\n};\n\nexport { glUploadCompressedTextureResource };\n//# sourceMappingURL=glUploadCompressedTextureResource.mjs.map\n","import type { CompressedSource } from '../../../shared/texture/sources/CompressedSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\nconst compressedFormatMap: Record<string, boolean> = {\n    'bc1-rgba-unorm': true,\n    'bc1-rgba-unorm-srgb': true,\n    'bc2-rgba-unorm': true,\n    'bc2-rgba-unorm-srgb': true,\n    'bc3-rgba-unorm': true,\n    'bc3-rgba-unorm-srgb': true,\n    'bc4-r-unorm': true,\n    'bc4-r-snorm': true,\n    'bc5-rg-unorm': true,\n    'bc5-rg-snorm': true,\n    'bc6h-rgb-ufloat': true,\n    'bc6h-rgb-float': true,\n    'bc7-rgba-unorm': true,\n    'bc7-rgba-unorm-srgb': true,\n\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    'etc2-rgb8unorm': true,\n    'etc2-rgb8unorm-srgb': true,\n    'etc2-rgb8a1unorm': true,\n    'etc2-rgb8a1unorm-srgb': true,\n    'etc2-rgba8unorm': true,\n    'etc2-rgba8unorm-srgb': true,\n    'eac-r11unorm': true,\n    'eac-r11snorm': true,\n    'eac-rg11unorm': true,\n    'eac-rg11snorm': true,\n\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    'astc-4x4-unorm': true,\n    'astc-4x4-unorm-srgb': true,\n    'astc-5x4-unorm': true,\n    'astc-5x4-unorm-srgb': true,\n    'astc-5x5-unorm': true,\n    'astc-5x5-unorm-srgb': true,\n    'astc-6x5-unorm': true,\n    'astc-6x5-unorm-srgb': true,\n    'astc-6x6-unorm': true,\n    'astc-6x6-unorm-srgb': true,\n    'astc-8x5-unorm': true,\n    'astc-8x5-unorm-srgb': true,\n    'astc-8x6-unorm': true,\n    'astc-8x6-unorm-srgb': true,\n    'astc-8x8-unorm': true,\n    'astc-8x8-unorm-srgb': true,\n    'astc-10x5-unorm': true,\n    'astc-10x5-unorm-srgb': true,\n    'astc-10x6-unorm': true,\n    'astc-10x6-unorm-srgb': true,\n    'astc-10x8-unorm': true,\n    'astc-10x8-unorm-srgb': true,\n    'astc-10x10-unorm': true,\n    'astc-10x10-unorm-srgb': true,\n    'astc-12x10-unorm': true,\n    'astc-12x10-unorm-srgb': true,\n    'astc-12x12-unorm': true,\n    'astc-12x12-unorm-srgb': true,\n};\n\nexport const glUploadCompressedTextureResource = {\n\n    id: 'compressed',\n\n    upload(source: CompressedSource, glTexture: GlTexture, gl: GlRenderingContext)\n    {\n        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n\n        let mipWidth = source.pixelWidth;\n        let mipHeight = source.pixelHeight;\n\n        const compressed = !!compressedFormatMap[source.format];\n\n        for (let i = 0; i < source.resource.length; i++)\n        {\n            const levelBuffer = source.resource[i];\n\n            if (compressed)\n            {\n                gl.compressedTexImage2D(\n                    gl.TEXTURE_2D, i, glTexture.internalFormat,\n                    mipWidth, mipHeight, 0,\n                    levelBuffer\n                );\n            }\n            else\n            {\n                gl.texImage2D(\n                    gl.TEXTURE_2D, i, glTexture.internalFormat,\n                    mipWidth, mipHeight, 0,\n                    glTexture.format, glTexture.type,\n                    levelBuffer);\n            }\n\n            mipWidth = Math.max(mipWidth >> 1, 1);\n            mipHeight = Math.max(mipHeight >> 1, 1);\n        }\n    }\n} as GLTextureUploader;\n\n","\"use strict\";\nconst glUploadImageResource = {\n  id: \"image\",\n  upload(source, glTexture, gl, webGLVersion) {\n    const premultipliedAlpha = source.alphaMode === \"premultiply-alpha-on-upload\";\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);\n    const glWidth = glTexture.width;\n    const glHeight = glTexture.height;\n    const textureWidth = source.pixelWidth;\n    const textureHeight = source.pixelHeight;\n    const resourceWidth = source.resourceWidth;\n    const resourceHeight = source.resourceHeight;\n    if (resourceWidth < textureWidth || resourceHeight < textureHeight) {\n      if (glWidth !== textureWidth || glHeight !== textureHeight) {\n        gl.texImage2D(\n          glTexture.target,\n          0,\n          glTexture.internalFormat,\n          textureWidth,\n          textureHeight,\n          0,\n          glTexture.format,\n          glTexture.type,\n          null\n        );\n      }\n      if (webGLVersion === 2) {\n        gl.texSubImage2D(\n          gl.TEXTURE_2D,\n          0,\n          0,\n          0,\n          resourceWidth,\n          resourceHeight,\n          glTexture.format,\n          glTexture.type,\n          source.resource\n        );\n      } else {\n        gl.texSubImage2D(\n          gl.TEXTURE_2D,\n          0,\n          0,\n          0,\n          glTexture.format,\n          glTexture.type,\n          source.resource\n        );\n      }\n    } else if (glWidth === textureWidth || glHeight === textureHeight) {\n      gl.texSubImage2D(\n        gl.TEXTURE_2D,\n        0,\n        0,\n        0,\n        glTexture.format,\n        glTexture.type,\n        source.resource\n      );\n    } else if (webGLVersion === 2) {\n      gl.texImage2D(\n        glTexture.target,\n        0,\n        glTexture.internalFormat,\n        textureWidth,\n        textureHeight,\n        0,\n        glTexture.format,\n        glTexture.type,\n        source.resource\n      );\n    } else {\n      gl.texImage2D(\n        glTexture.target,\n        0,\n        glTexture.internalFormat,\n        glTexture.format,\n        glTexture.type,\n        source.resource\n      );\n    }\n    glTexture.width = textureWidth;\n    glTexture.height = textureHeight;\n  }\n};\n\nexport { glUploadImageResource };\n//# sourceMappingURL=glUploadImageResource.mjs.map\n","import type { CanvasSource } from '../../../shared/texture/sources/CanvasSource';\nimport type { ImageSource } from '../../../shared/texture/sources/ImageSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\nexport const glUploadImageResource = {\n\n    id: 'image',\n\n    upload(source: ImageSource | CanvasSource, glTexture: GlTexture, gl: GlRenderingContext, webGLVersion: number)\n    {\n        const premultipliedAlpha = source.alphaMode === 'premultiply-alpha-on-upload';\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);\n\n        const glWidth = glTexture.width;\n        const glHeight = glTexture.height;\n\n        const textureWidth = source.pixelWidth;\n        const textureHeight = source.pixelHeight;\n\n        const resourceWidth = source.resourceWidth;\n        const resourceHeight = source.resourceHeight;\n\n        if (resourceWidth < textureWidth || resourceHeight < textureHeight)\n        {\n            if (glWidth !== textureWidth || glHeight !== textureHeight)\n            {\n                gl.texImage2D(\n                    glTexture.target,\n                    0,\n                    glTexture.internalFormat,\n                    textureWidth,\n                    textureHeight,\n                    0,\n                    glTexture.format,\n                    glTexture.type,\n                    null\n                );\n            }\n\n            if (webGLVersion === 2)\n            {\n                gl.texSubImage2D(\n                    gl.TEXTURE_2D,\n                    0,\n                    0,\n                    0,\n                    resourceWidth,\n                    resourceHeight,\n                    glTexture.format,\n                    glTexture.type,\n                    source.resource as TexImageSource\n                );\n            }\n            else\n            {\n                gl.texSubImage2D(\n                    gl.TEXTURE_2D,\n                    0,\n                    0,\n                    0,\n                    glTexture.format,\n                    glTexture.type,\n                    source.resource as TexImageSource\n                );\n            }\n        }\n        else if (glWidth === textureWidth || glHeight === textureHeight)\n        {\n            gl.texSubImage2D(\n                gl.TEXTURE_2D,\n                0,\n                0,\n                0,\n                glTexture.format,\n                glTexture.type,\n                source.resource as TexImageSource\n            );\n        }\n        else if (webGLVersion === 2)\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                textureWidth,\n                textureHeight,\n                0,\n                glTexture.format,\n                glTexture.type,\n                source.resource as TexImageSource\n            );\n        }\n        else\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                glTexture.format,\n                glTexture.type,\n                source.resource as TexImageSource\n            );\n        }\n\n        glTexture.width = textureWidth;\n        glTexture.height = textureHeight;\n    }\n} as GLTextureUploader;\n\n","import { glUploadImageResource } from './glUploadImageResource.mjs';\n\n\"use strict\";\nconst glUploadVideoResource = {\n  id: \"video\",\n  upload(source, glTexture, gl, webGLVersion) {\n    if (!source.isValid) {\n      gl.texImage2D(\n        glTexture.target,\n        0,\n        glTexture.internalFormat,\n        1,\n        1,\n        0,\n        glTexture.format,\n        glTexture.type,\n        null\n      );\n      return;\n    }\n    glUploadImageResource.upload(source, glTexture, gl, webGLVersion);\n  }\n};\n\nexport { glUploadVideoResource };\n//# sourceMappingURL=glUploadVideoResource.mjs.map\n","import { glUploadImageResource } from './glUploadImageResource';\n\nimport type { VideoSource } from '../../../shared/texture/sources/VideoSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\nexport const glUploadVideoResource = {\n\n    id: 'video',\n\n    upload(source: VideoSource, glTexture: GlTexture, gl: GlRenderingContext, webGLVersion: number)\n    {\n        if (!source.isValid)\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                1,\n                1,\n                0,\n                glTexture.format,\n                glTexture.type,\n                null\n            );\n\n            return;\n        }\n\n        glUploadImageResource.upload(source, glTexture, gl, webGLVersion);\n    }\n} as GLTextureUploader;\n\n","import { wrapModeToGlAddress, scaleModeToGlFilter, mipmapScaleModeToGlFilter, compareModeToGlCompare } from './pixiToGlMaps.mjs';\n\n\"use strict\";\nfunction applyStyleParams(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam, forceClamp, firstCreation) {\n  const castParam = firstParam;\n  if (!firstCreation || style.addressModeU !== \"repeat\" || style.addressModeV !== \"repeat\" || style.addressModeW !== \"repeat\") {\n    const wrapModeS = wrapModeToGlAddress[forceClamp ? \"clamp-to-edge\" : style.addressModeU];\n    const wrapModeT = wrapModeToGlAddress[forceClamp ? \"clamp-to-edge\" : style.addressModeV];\n    const wrapModeR = wrapModeToGlAddress[forceClamp ? \"clamp-to-edge\" : style.addressModeW];\n    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);\n    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);\n    if (gl.TEXTURE_WRAP_R)\n      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);\n  }\n  if (!firstCreation || style.magFilter !== \"linear\") {\n    gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);\n  }\n  if (mipmaps) {\n    if (!firstCreation || style.mipmapFilter !== \"linear\") {\n      const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];\n      gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);\n    }\n  } else {\n    gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);\n  }\n  if (anisotropicExt && style.maxAnisotropy > 1) {\n    const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n    gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n  }\n  if (style.compare) {\n    gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);\n  }\n}\n\nexport { applyStyleParams };\n//# sourceMappingURL=applyStyleParams.mjs.map\n","import {\n    compareModeToGlCompare,\n    mipmapScaleModeToGlFilter,\n    scaleModeToGlFilter,\n    wrapModeToGlAddress\n} from './pixiToGlMaps';\n\nimport type { TextureStyle } from '../../../shared/texture/TextureStyle';\n\nexport function applyStyleParams(\n    style: TextureStyle,\n    gl: WebGL2RenderingContext,\n    mipmaps: boolean,\n    // eslint-disable-next-line camelcase\n    anisotropicExt: EXT_texture_filter_anisotropic,\n    glFunctionName: 'samplerParameteri' | 'texParameteri',\n    firstParam: 3553 | WebGLSampler,\n    forceClamp: boolean,\n    /** if true we can skip setting certain values if the values is the same as the default gl values */\n    firstCreation: boolean\n)\n{\n    const castParam = firstParam as 3553;\n\n    if (!firstCreation\n        || style.addressModeU !== 'repeat'\n        || style.addressModeV !== 'repeat'\n        || style.addressModeW !== 'repeat'\n    )\n    {\n        // 1. set the wrapping mode\n        const wrapModeS = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeU];\n        const wrapModeT = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeV];\n        const wrapModeR = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeW];\n\n        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);\n        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);\n\n        // does not exist in webGL1\n        if (gl.TEXTURE_WRAP_R) gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);\n    }\n\n    if (!firstCreation || style.magFilter !== 'linear')\n    {\n        // 2. set the filtering mode\n        gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);\n    }\n\n    // assuming the currently bound texture is the one we want to set the filter for\n    // the only smelly part of this code, WebGPU is much better here :P\n    if (mipmaps)\n    {\n        if (!firstCreation || style.mipmapFilter !== 'linear')\n        {\n            const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];\n\n            gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);\n        }\n    }\n\n    else\n    {\n        gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);\n    }\n\n    // 3. set the anisotropy\n    if (anisotropicExt && style.maxAnisotropy > 1)\n    {\n        const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n\n        gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n    }\n\n    // 4. set the compare mode\n    if (style.compare)\n    {\n        gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);\n    }\n}\n","\"use strict\";\nconst scaleModeToGlFilter = {\n  linear: 9729,\n  nearest: 9728\n};\nconst mipmapScaleModeToGlFilter = {\n  linear: {\n    linear: 9987,\n    nearest: 9985\n  },\n  nearest: {\n    linear: 9986,\n    nearest: 9984\n  }\n};\nconst wrapModeToGlAddress = {\n  \"clamp-to-edge\": 33071,\n  repeat: 10497,\n  \"mirror-repeat\": 33648\n};\nconst compareModeToGlCompare = {\n  never: 512,\n  less: 513,\n  equal: 514,\n  \"less-equal\": 515,\n  greater: 516,\n  \"not-equal\": 517,\n  \"greater-equal\": 518,\n  always: 519\n};\n\nexport { compareModeToGlCompare, mipmapScaleModeToGlFilter, scaleModeToGlFilter, wrapModeToGlAddress };\n//# sourceMappingURL=pixiToGlMaps.mjs.map\n","export const scaleModeToGlFilter = {\n    linear: 9729,\n    nearest: 9728,\n};\n\nexport const mipmapScaleModeToGlFilter = {\n    linear: {\n        linear: 9987,\n        nearest: 9985,\n    },\n    nearest: {\n        linear: 9986,\n        nearest: 9984,\n    }\n};\n\nexport const wrapModeToGlAddress = {\n    'clamp-to-edge': 33071,\n    repeat: 10497,\n    'mirror-repeat': 33648,\n};\n\nexport const compareModeToGlCompare = {\n    never: 512,\n    less: 513,\n    equal: 514,\n    'less-equal': 515,\n    greater: 516,\n    'not-equal': 517,\n    'greater-equal': 518,\n    always: 519,\n};\n\n","\"use strict\";\nfunction mapFormatToGlFormat(gl) {\n  return {\n    // 8-bit formats\n    r8unorm: gl.RED,\n    r8snorm: gl.RED,\n    r8uint: gl.RED,\n    r8sint: gl.RED,\n    // 16-bit formats\n    r16uint: gl.RED,\n    r16sint: gl.RED,\n    r16float: gl.RED,\n    rg8unorm: gl.RG,\n    rg8snorm: gl.RG,\n    rg8uint: gl.RG,\n    rg8sint: gl.RG,\n    // 32-bit formats\n    r32uint: gl.RED,\n    r32sint: gl.RED,\n    r32float: gl.RED,\n    rg16uint: gl.RG,\n    rg16sint: gl.RG,\n    rg16float: gl.RG,\n    rgba8unorm: gl.RGBA,\n    \"rgba8unorm-srgb\": gl.RGBA,\n    // Packed 32-bit formats\n    rgba8snorm: gl.RGBA,\n    rgba8uint: gl.RGBA,\n    rgba8sint: gl.RGBA,\n    bgra8unorm: gl.RGBA,\n    \"bgra8unorm-srgb\": gl.RGBA,\n    rgb9e5ufloat: gl.RGB,\n    rgb10a2unorm: gl.RGBA,\n    rg11b10ufloat: gl.RGB,\n    // 64-bit formats\n    rg32uint: gl.RG,\n    rg32sint: gl.RG,\n    rg32float: gl.RG,\n    rgba16uint: gl.RGBA,\n    rgba16sint: gl.RGBA,\n    rgba16float: gl.RGBA,\n    // 128-bit formats\n    rgba32uint: gl.RGBA,\n    rgba32sint: gl.RGBA,\n    rgba32float: gl.RGBA,\n    // Depth/stencil formats\n    stencil8: gl.STENCIL_INDEX8,\n    depth16unorm: gl.DEPTH_COMPONENT,\n    depth24plus: gl.DEPTH_COMPONENT,\n    \"depth24plus-stencil8\": gl.DEPTH_STENCIL,\n    depth32float: gl.DEPTH_COMPONENT,\n    \"depth32float-stencil8\": gl.DEPTH_STENCIL\n  };\n}\n\nexport { mapFormatToGlFormat };\n//# sourceMappingURL=mapFormatToGlFormat.mjs.map\n","import type { GlRenderingContext } from '../../context/GlRenderingContext';\n\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param {WebGLRenderingContext} gl - The rendering context.\n * @returns Lookup table.\n */\nexport function mapFormatToGlFormat(gl: GlRenderingContext): Record<string, number>\n{\n    return {\n        // 8-bit formats\n        r8unorm: gl.RED,\n        r8snorm: gl.RED,\n        r8uint: gl.RED,\n        r8sint: gl.RED,\n\n        // 16-bit formats\n        r16uint: gl.RED,\n        r16sint:    gl.RED,\n        r16float: gl.RED,\n        rg8unorm:  gl.RG,\n        rg8snorm:   gl.RG,\n        rg8uint:  gl.RG,\n        rg8sint:  gl.RG,\n\n        // 32-bit formats\n        r32uint: gl.RED,\n        r32sint: gl.RED,\n        r32float: gl.RED,\n        rg16uint:   gl.RG,\n        rg16sint:  gl.RG,\n        rg16float:  gl.RG,\n        rgba8unorm: gl.RGBA,\n        'rgba8unorm-srgb': gl.RGBA,\n\n        // Packed 32-bit formats\n        rgba8snorm: gl.RGBA,\n        rgba8uint: gl.RGBA,\n        rgba8sint: gl.RGBA,\n        bgra8unorm: gl.RGBA,\n        'bgra8unorm-srgb': gl.RGBA,\n        rgb9e5ufloat: gl.RGB,\n        rgb10a2unorm: gl.RGBA,\n        rg11b10ufloat: gl.RGB,\n\n        // 64-bit formats\n        rg32uint: gl.RG,\n        rg32sint: gl.RG,\n        rg32float:  gl.RG,\n        rgba16uint: gl.RGBA,\n        rgba16sint: gl.RGBA,\n        rgba16float: gl.RGBA,\n\n        // 128-bit formats\n        rgba32uint: gl.RGBA,\n        rgba32sint: gl.RGBA,\n        rgba32float: gl.RGBA,\n\n        // Depth/stencil formats\n        stencil8: gl.STENCIL_INDEX8,\n        depth16unorm: gl.DEPTH_COMPONENT,\n        depth24plus: gl.DEPTH_COMPONENT,\n        'depth24plus-stencil8': gl.DEPTH_STENCIL,\n        depth32float: gl.DEPTH_COMPONENT,\n        'depth32float-stencil8': gl.DEPTH_STENCIL,\n\n    };\n}\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\n\n\"use strict\";\nfunction mapFormatToGlInternalFormat(gl, extensions) {\n  let srgb = {};\n  let bgra8unorm = gl.RGBA;\n  if (!(gl instanceof DOMAdapter.get().getWebGLRenderingContext())) {\n    srgb = {\n      \"rgba8unorm-srgb\": gl.SRGB8_ALPHA8,\n      \"bgra8unorm-srgb\": gl.SRGB8_ALPHA8\n    };\n    bgra8unorm = gl.RGBA8;\n  } else if (extensions.srgb) {\n    srgb = {\n      \"rgba8unorm-srgb\": extensions.srgb.SRGB8_ALPHA8_EXT,\n      \"bgra8unorm-srgb\": extensions.srgb.SRGB8_ALPHA8_EXT\n    };\n  }\n  return {\n    // 8-bit formats\n    r8unorm: gl.R8,\n    r8snorm: gl.R8_SNORM,\n    r8uint: gl.R8UI,\n    r8sint: gl.R8I,\n    // 16-bit formats\n    r16uint: gl.R16UI,\n    r16sint: gl.R16I,\n    r16float: gl.R16F,\n    rg8unorm: gl.RG8,\n    rg8snorm: gl.RG8_SNORM,\n    rg8uint: gl.RG8UI,\n    rg8sint: gl.RG8I,\n    // 32-bit formats\n    r32uint: gl.R32UI,\n    r32sint: gl.R32I,\n    r32float: gl.R32F,\n    rg16uint: gl.RG16UI,\n    rg16sint: gl.RG16I,\n    rg16float: gl.RG16F,\n    rgba8unorm: gl.RGBA,\n    ...srgb,\n    // Packed 32-bit formats\n    rgba8snorm: gl.RGBA8_SNORM,\n    rgba8uint: gl.RGBA8UI,\n    rgba8sint: gl.RGBA8I,\n    bgra8unorm,\n    rgb9e5ufloat: gl.RGB9_E5,\n    rgb10a2unorm: gl.RGB10_A2,\n    rg11b10ufloat: gl.R11F_G11F_B10F,\n    // 64-bit formats\n    rg32uint: gl.RG32UI,\n    rg32sint: gl.RG32I,\n    rg32float: gl.RG32F,\n    rgba16uint: gl.RGBA16UI,\n    rgba16sint: gl.RGBA16I,\n    rgba16float: gl.RGBA16F,\n    // 128-bit formats\n    rgba32uint: gl.RGBA32UI,\n    rgba32sint: gl.RGBA32I,\n    rgba32float: gl.RGBA32F,\n    // Depth/stencil formats\n    stencil8: gl.STENCIL_INDEX8,\n    depth16unorm: gl.DEPTH_COMPONENT16,\n    depth24plus: gl.DEPTH_COMPONENT24,\n    \"depth24plus-stencil8\": gl.DEPTH24_STENCIL8,\n    depth32float: gl.DEPTH_COMPONENT32F,\n    \"depth32float-stencil8\": gl.DEPTH32F_STENCIL8,\n    // Compressed formats\n    ...extensions.s3tc ? {\n      \"bc1-rgba-unorm\": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n      \"bc2-rgba-unorm\": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n      \"bc3-rgba-unorm\": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT\n    } : {},\n    ...extensions.s3tc_sRGB ? {\n      \"bc1-rgba-unorm-srgb\": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,\n      \"bc2-rgba-unorm-srgb\": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,\n      \"bc3-rgba-unorm-srgb\": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT\n    } : {},\n    ...extensions.rgtc ? {\n      \"bc4-r-unorm\": extensions.rgtc.COMPRESSED_RED_RGTC1_EXT,\n      \"bc4-r-snorm\": extensions.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,\n      \"bc5-rg-unorm\": extensions.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,\n      \"bc5-rg-snorm\": extensions.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT\n    } : {},\n    ...extensions.bptc ? {\n      \"bc6h-rgb-float\": extensions.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,\n      \"bc6h-rgb-ufloat\": extensions.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,\n      \"bc7-rgba-unorm\": extensions.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,\n      \"bc7-rgba-unorm-srgb\": extensions.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT\n    } : {},\n    ...extensions.etc ? {\n      \"etc2-rgb8unorm\": extensions.etc.COMPRESSED_RGB8_ETC2,\n      \"etc2-rgb8unorm-srgb\": extensions.etc.COMPRESSED_SRGB8_ETC2,\n      \"etc2-rgb8a1unorm\": extensions.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n      \"etc2-rgb8a1unorm-srgb\": extensions.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n      \"etc2-rgba8unorm\": extensions.etc.COMPRESSED_RGBA8_ETC2_EAC,\n      \"etc2-rgba8unorm-srgb\": extensions.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,\n      \"eac-r11unorm\": extensions.etc.COMPRESSED_R11_EAC,\n      // 'eac-r11snorm'\n      \"eac-rg11unorm\": extensions.etc.COMPRESSED_SIGNED_RG11_EAC\n      // 'eac-rg11snorm'\n    } : {},\n    ...extensions.astc ? {\n      \"astc-4x4-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,\n      \"astc-4x4-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,\n      \"astc-5x4-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,\n      \"astc-5x4-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,\n      \"astc-5x5-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,\n      \"astc-5x5-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,\n      \"astc-6x5-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,\n      \"astc-6x5-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,\n      \"astc-6x6-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,\n      \"astc-6x6-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,\n      \"astc-8x5-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,\n      \"astc-8x5-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,\n      \"astc-8x6-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,\n      \"astc-8x6-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,\n      \"astc-8x8-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,\n      \"astc-8x8-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,\n      \"astc-10x5-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,\n      \"astc-10x5-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,\n      \"astc-10x6-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,\n      \"astc-10x6-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,\n      \"astc-10x8-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,\n      \"astc-10x8-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,\n      \"astc-10x10-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,\n      \"astc-10x10-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,\n      \"astc-12x10-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,\n      \"astc-12x10-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,\n      \"astc-12x12-unorm\": extensions.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,\n      \"astc-12x12-unorm-srgb\": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR\n    } : {}\n  };\n}\n\nexport { mapFormatToGlInternalFormat };\n//# sourceMappingURL=mapFormatToGlInternalFormat.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { WebGLExtensions } from '../../context/WebGLExtensions';\n\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param gl - The rendering context.\n * @param extensions - The WebGL extensions.\n * @returns Lookup table.\n */\nexport function mapFormatToGlInternalFormat(\n    gl: GlRenderingContext,\n    extensions: WebGLExtensions,\n): Record<string, number>\n{\n    let srgb = {};\n    let bgra8unorm: number = gl.RGBA;\n\n    if (!(gl instanceof DOMAdapter.get().getWebGLRenderingContext()))\n    {\n        srgb = {\n            'rgba8unorm-srgb': gl.SRGB8_ALPHA8,\n            'bgra8unorm-srgb': gl.SRGB8_ALPHA8,\n        };\n\n        bgra8unorm = gl.RGBA8;\n    }\n    else if (extensions.srgb)\n    {\n        srgb = {\n            'rgba8unorm-srgb': extensions.srgb.SRGB8_ALPHA8_EXT,\n            'bgra8unorm-srgb': extensions.srgb.SRGB8_ALPHA8_EXT,\n        };\n    }\n\n    return {\n        // 8-bit formats\n        r8unorm: gl.R8,\n        r8snorm: gl.R8_SNORM,\n        r8uint: gl.R8UI,\n        r8sint: gl.R8I,\n\n        // 16-bit formats\n        r16uint: gl.R16UI,\n        r16sint: gl.R16I,\n        r16float: gl.R16F,\n        rg8unorm: gl.RG8,\n        rg8snorm: gl.RG8_SNORM,\n        rg8uint: gl.RG8UI,\n        rg8sint: gl.RG8I,\n\n        // 32-bit formats\n        r32uint: gl.R32UI,\n        r32sint: gl.R32I,\n        r32float: gl.R32F,\n        rg16uint: gl.RG16UI,\n        rg16sint: gl.RG16I,\n        rg16float: gl.RG16F,\n        rgba8unorm: gl.RGBA,\n\n        ...srgb,\n\n        // Packed 32-bit formats\n        rgba8snorm: gl.RGBA8_SNORM,\n        rgba8uint: gl.RGBA8UI,\n        rgba8sint: gl.RGBA8I,\n        bgra8unorm,\n        rgb9e5ufloat: gl.RGB9_E5,\n        rgb10a2unorm: gl.RGB10_A2,\n        rg11b10ufloat: gl.R11F_G11F_B10F,\n\n        // 64-bit formats\n        rg32uint: gl.RG32UI,\n        rg32sint: gl.RG32I,\n        rg32float: gl.RG32F,\n        rgba16uint: gl.RGBA16UI,\n        rgba16sint: gl.RGBA16I,\n        rgba16float: gl.RGBA16F,\n\n        // 128-bit formats\n        rgba32uint: gl.RGBA32UI,\n        rgba32sint: gl.RGBA32I,\n        rgba32float: gl.RGBA32F,\n\n        // Depth/stencil formats\n        stencil8: gl.STENCIL_INDEX8,\n        depth16unorm: gl.DEPTH_COMPONENT16,\n        depth24plus: gl.DEPTH_COMPONENT24,\n        'depth24plus-stencil8': gl.DEPTH24_STENCIL8,\n        depth32float: gl.DEPTH_COMPONENT32F,\n        'depth32float-stencil8': gl.DEPTH32F_STENCIL8,\n\n        // Compressed formats\n        ...extensions.s3tc ? {\n            'bc1-rgba-unorm': extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n            'bc2-rgba-unorm': extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n            'bc3-rgba-unorm': extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n        } : {},\n        ...extensions.s3tc_sRGB ? {\n            'bc1-rgba-unorm-srgb': extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,\n            'bc2-rgba-unorm-srgb': extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,\n            'bc3-rgba-unorm-srgb': extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,\n        } : {},\n        ...extensions.rgtc ? {\n            'bc4-r-unorm': extensions.rgtc.COMPRESSED_RED_RGTC1_EXT,\n            'bc4-r-snorm': extensions.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,\n            'bc5-rg-unorm': extensions.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,\n            'bc5-rg-snorm': extensions.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,\n        } : {},\n        ...extensions.bptc ? {\n            'bc6h-rgb-float': extensions.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,\n            'bc6h-rgb-ufloat': extensions.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,\n            'bc7-rgba-unorm': extensions.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,\n            'bc7-rgba-unorm-srgb': extensions.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT,\n        } : {},\n        ...extensions.etc ? {\n            'etc2-rgb8unorm': extensions.etc.COMPRESSED_RGB8_ETC2,\n            'etc2-rgb8unorm-srgb': extensions.etc.COMPRESSED_SRGB8_ETC2,\n            'etc2-rgb8a1unorm': extensions.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n            'etc2-rgb8a1unorm-srgb': extensions.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n            'etc2-rgba8unorm': extensions.etc.COMPRESSED_RGBA8_ETC2_EAC,\n            'etc2-rgba8unorm-srgb': extensions.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,\n            'eac-r11unorm': extensions.etc.COMPRESSED_R11_EAC,\n            // 'eac-r11snorm'\n            'eac-rg11unorm': extensions.etc.COMPRESSED_SIGNED_RG11_EAC,\n            // 'eac-rg11snorm'\n        } : {},\n        ...extensions.astc ? {\n            'astc-4x4-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,\n            'astc-4x4-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,\n            'astc-5x4-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,\n            'astc-5x4-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,\n            'astc-5x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,\n            'astc-5x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,\n            'astc-6x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,\n            'astc-6x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,\n            'astc-6x6-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,\n            'astc-6x6-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,\n            'astc-8x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,\n            'astc-8x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,\n            'astc-8x6-unorm':   extensions.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,\n            'astc-8x6-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,\n            'astc-8x8-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,\n            'astc-8x8-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,\n            'astc-10x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,\n            'astc-10x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,\n            'astc-10x6-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,\n            'astc-10x6-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,\n            'astc-10x8-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,\n            'astc-10x8-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,\n            'astc-10x10-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,\n            'astc-10x10-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,\n            'astc-12x10-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,\n            'astc-12x10-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,\n            'astc-12x12-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,\n            'astc-12x12-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,\n        } : {},\n    };\n}\n","\"use strict\";\nfunction mapFormatToGlType(gl) {\n  return {\n    // 8-bit formats\n    r8unorm: gl.UNSIGNED_BYTE,\n    r8snorm: gl.BYTE,\n    r8uint: gl.UNSIGNED_BYTE,\n    r8sint: gl.BYTE,\n    // 16-bit formats\n    r16uint: gl.UNSIGNED_SHORT,\n    r16sint: gl.SHORT,\n    r16float: gl.HALF_FLOAT,\n    rg8unorm: gl.UNSIGNED_BYTE,\n    rg8snorm: gl.BYTE,\n    rg8uint: gl.UNSIGNED_BYTE,\n    rg8sint: gl.BYTE,\n    // 32-bit formats\n    r32uint: gl.UNSIGNED_INT,\n    r32sint: gl.INT,\n    r32float: gl.FLOAT,\n    rg16uint: gl.UNSIGNED_SHORT,\n    rg16sint: gl.SHORT,\n    rg16float: gl.HALF_FLOAT,\n    rgba8unorm: gl.UNSIGNED_BYTE,\n    \"rgba8unorm-srgb\": gl.UNSIGNED_BYTE,\n    // Packed 32-bit formats\n    rgba8snorm: gl.BYTE,\n    rgba8uint: gl.UNSIGNED_BYTE,\n    rgba8sint: gl.BYTE,\n    bgra8unorm: gl.UNSIGNED_BYTE,\n    \"bgra8unorm-srgb\": gl.UNSIGNED_BYTE,\n    rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,\n    rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,\n    rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,\n    // 64-bit formats\n    rg32uint: gl.UNSIGNED_INT,\n    rg32sint: gl.INT,\n    rg32float: gl.FLOAT,\n    rgba16uint: gl.UNSIGNED_SHORT,\n    rgba16sint: gl.SHORT,\n    rgba16float: gl.HALF_FLOAT,\n    // 128-bit formats\n    rgba32uint: gl.UNSIGNED_INT,\n    rgba32sint: gl.INT,\n    rgba32float: gl.FLOAT,\n    // Depth/stencil formats\n    stencil8: gl.UNSIGNED_BYTE,\n    depth16unorm: gl.UNSIGNED_SHORT,\n    depth24plus: gl.UNSIGNED_INT,\n    \"depth24plus-stencil8\": gl.UNSIGNED_INT_24_8,\n    depth32float: gl.FLOAT,\n    \"depth32float-stencil8\": gl.FLOAT_32_UNSIGNED_INT_24_8_REV\n  };\n}\n\nexport { mapFormatToGlType };\n//# sourceMappingURL=mapFormatToGlType.mjs.map\n","import type { GlRenderingContext } from '../../context/GlRenderingContext';\n\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param {WebGLRenderingContext} gl - The rendering context.\n * @returns Lookup table.\n */\nexport function mapFormatToGlType(gl: GlRenderingContext): Record<string, number>\n{\n    return {\n        // 8-bit formats\n        r8unorm: gl.UNSIGNED_BYTE,\n        r8snorm: gl.BYTE,\n        r8uint: gl.UNSIGNED_BYTE,\n        r8sint: gl.BYTE,\n\n        // 16-bit formats\n        r16uint: gl.UNSIGNED_SHORT,\n        r16sint: gl.SHORT,\n        r16float: gl.HALF_FLOAT,\n        rg8unorm: gl.UNSIGNED_BYTE,\n        rg8snorm: gl.BYTE,\n        rg8uint: gl.UNSIGNED_BYTE,\n        rg8sint: gl.BYTE,\n\n        // 32-bit formats\n        r32uint: gl.UNSIGNED_INT,\n        r32sint: gl.INT,\n        r32float: gl.FLOAT,\n        rg16uint: gl.UNSIGNED_SHORT,\n        rg16sint: gl.SHORT,\n        rg16float: gl.HALF_FLOAT,\n        rgba8unorm: gl.UNSIGNED_BYTE,\n        'rgba8unorm-srgb': gl.UNSIGNED_BYTE,\n\n        // Packed 32-bit formats\n        rgba8snorm: gl.BYTE,\n        rgba8uint: gl.UNSIGNED_BYTE,\n        rgba8sint: gl.BYTE,\n        bgra8unorm: gl.UNSIGNED_BYTE,\n        'bgra8unorm-srgb': gl.UNSIGNED_BYTE,\n        rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,\n        rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,\n        rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,\n\n        // 64-bit formats\n        rg32uint: gl.UNSIGNED_INT,\n        rg32sint: gl.INT,\n        rg32float: gl.FLOAT,\n        rgba16uint: gl.UNSIGNED_SHORT,\n        rgba16sint: gl.SHORT,\n        rgba16float: gl.HALF_FLOAT,\n\n        // 128-bit formats\n        rgba32uint: gl.UNSIGNED_INT,\n        rgba32sint: gl.INT,\n        rgba32float: gl.FLOAT,\n\n        // Depth/stencil formats\n        stencil8: gl.UNSIGNED_BYTE,\n        depth16unorm: gl.UNSIGNED_SHORT,\n        depth24plus: gl.UNSIGNED_INT,\n        'depth24plus-stencil8': gl.UNSIGNED_INT_24_8,\n        depth32float: gl.FLOAT,\n        'depth32float-stencil8': gl.FLOAT_32_UNSIGNED_INT_24_8_REV,\n\n    };\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","$08c34e1ba95c0965$export$f6cc00ef28d7cf97","$i9BKe","$cptWh","$9S3KH","$8ml9k","$3UUq4","$4deGe","$2bK9z","$aJW6I","$8D8uA","$7aRIR","$1a3Lw","$4xaOd","$94DBT","$cozHw","$jvNyo","$fA05m","$2Z5qq","$jS5sk","$39wDe","$2WDu2","$08c34e1ba95c0965$var$DefaultWebGLSystems","SharedSystems","GlUboSystem","GlBackBufferSystem","GlContextSystem","GlBufferSystem","GlTextureSystem","GlRenderTargetSystem","GlGeometrySystem","GlUniformGroupSystem","GlShaderSystem","GlEncoderSystem","GlStateSystem","GlStencilSystem","GlColorMaskSystem","$08c34e1ba95c0965$var$DefaultWebGLPipes","SharedRenderPipes","$08c34e1ba95c0965$var$DefaultWebGLAdapters","GlBatchAdaptor","GlMeshAdaptor","GlGraphicsAdaptor","$08c34e1ba95c0965$var$systems","$08c34e1ba95c0965$var$renderPipes","$08c34e1ba95c0965$var$renderPipeAdaptors","extensions","handleByNamedList","ExtensionType","WebGLSystem","WebGLPipes","WebGLPipesAdaptor","add","AbstractRenderer","constructor","name","type","RendererType","WEBGL","systems","renderPipes","renderPipeAdaptors","$5a3cc73d4355d7e9$export$973696ef22548d24","$eY4rt","$67Wkd","$3JBHn","$cNnNT","$ikSZA","$huPGn","$kSpdC","$5FRY8","$5iDyo","$cryyq","init","uniforms","UniformGroup","uColor","value","Float32Array","uTransformMatrix","Matrix","uRound","glProgram","compileHighShaderGlProgram","bits","colorBitGl","generateTextureBatchBitGl","MAX_TEXTURES","localUniformBitGl","roundPixelsBitGl","shader","Shader","resources","localUniforms","batchSamplers","batchSamplersUniformGroup","execute","graphicsPipe","renderable","context","customShader","renderer","geometry","instructions","contextSystem","graphicsContext","getContextRenderData","groups","globalUniforms","bindGroup","bind","batches","i","instructionSize","batch","size","j","textures","length","texture","draw","start","destroy","extension","$ebe5f5894ae4e7d0$export$e08a38be63346709","$ebe5f5894ae4e7d0$var$sampleValues","Int32Array","uTextures","isStatic","$ee11e087d5a9ace8$export$9d77a952b0b834a5","$kGDJh","$bLlTJ","$hUCK4","textureBitGl","_shader","uTexture","Texture","EMPTY","source","textureUniforms","uTextureMatrix","meshPipe","mesh","warn","uSampler","style","textureMatrix","mapCoord","localUniformsBindGroup","encoder","_geometry","state","$e6d51e5fe4448b69$export$3a163a0d7700c616","$2Aebl","_didUpload","_tempState","State","for2d","batcherPipe","runners","contextChange","batchPipe","updateUniformGroup","uniformGroup","blendMode","$9d64726abaf6b9c3$export$e361bc2ee7fe27c6","$1UZ6r","$iW6sc","$j1e0r","_gpuBuffers","create","_boundBufferBases","_renderer","_gl","gl","getGlBuffer","buffer","uid","createGLBuffer","glBuffer","bindBuffer","bindBufferBase","index","UNIFORM_BUFFER","bindBufferRange","offset","updateBuffer","_updateID","updateID","data","byteLength","bufferSubData","_updateSize","BYTES_PER_ELEMENT","drawType","descriptor","usage","BufferUsage","STATIC","STATIC_DRAW","DYNAMIC_DRAW","bufferData","destroyAll","id","deleteBuffer","onBufferDestroy","contextLost","BUFFER_TYPE","ARRAY_BUFFER","INDEX","ELEMENT_ARRAY_BUFFER","UNIFORM","GlBuffer","createBuffer","on","$0197e1cb86a227e9$export$b595a7e482202b96","BUFFER_TYPE2","$ffc8977bfc141d19$export$e785124e31725f3f","$719acc43fc5eb9a0$export$6efe747e26df7565","$iCGeI","$719acc43fc5eb9a0$var$_GlContextSystem","_GlContextSystem","supports","uint32Indices","uniformBufferObject","vertexArrayObject","srgbTextures","nonPowOf2wrapping","msaa","nonPowOf2mipmaps","handleContextLost","handleContextRestored","isLost","isContextLost","options","defaultOptions","initFromContext","alpha","background","premultipliedAlpha","antialias","backBuffer","useBackBuffer","createContext","preferWebGLVersion","stencil","preserveDrawingBuffer","powerPreference","webGLVersion","DOMAdapter","getWebGLRenderingContext","getExtensions","validateContext","emit","element","view","canvas","addEventListener","getContext","Error","common","anisotropicFiltering","getExtension","floatTextureLinear","s3tc","s3tc_sRGB","etc","etc1","pvrtc","atc","astc","bptc","rgtc","loseContext","drawBuffers","depthTexture","uint32ElementIndex","floatTexture","textureHalfFloat","textureHalfFloatLinear","vertexAttribDivisorANGLE","srgb","colorBufferFloat","provokeExt","provokingVertexWEBGL","FIRST_VERTEX_CONVENTION_WEBGL","event","preventDefault","_contextLossForced","setTimeout","restoreContext","removeEventListener","useProgram","forceContextLoss","attributes","getContextAttributes","isWebGl2","$af1a69b87aab7e03$export$2ee3e1b0e7ef0cc8","$kavUV","$4EpFm","$bTJRY","$af1a69b87aab7e03$var$topologyToGlMap","_geometryVaoHash","_activeGeometry","_activeVao","hasVao","hasInstance","nativeVaoExtension","createVertexArray","createVertexArrayOES","bindVertexArray","vao","bindVertexArrayOES","deleteVertexArray","deleteVertexArrayOES","nativeInstancedExtension","drawArraysInstanced","a","b","c","d","drawArraysInstancedANGLE","drawElementsInstanced","drawElementsInstancedANGLE","vertexAttribDivisor","program","getVao","updateBuffers","reset","unbind","bufferSystem","buffers","checkCompatibility","geometryAttributes","shaderAttributes","_attributeData","getSignature","attribs","strings","push","location","join","_key","initGeometryVao","_incRefCount","_getProgramData","signature","onGeometryDestroy","vaoObjectHash","ensureAttributes","activateVao","indexBuffer","lastBuffer","attribute","programAttrib","enableVertexAttribArray","attributeInfo","getAttributeInfoFromFormat","format","getGlTypeFromFormat","substring","vertexAttribIPointer","stride","vertexAttribPointer","normalised","instance","topology","instanceCount","glTopology","byteSize","glType","UNSIGNED_SHORT","UNSIGNED_INT","drawElements","getSize","drawArrays","$a0dc6a33a2d76a7c$export$7d188452319c78cb","$9kjPM","$a0dc6a33a2d76a7c$var$infoMap","uint8x2","GL_TYPES","UNSIGNED_BYTE","uint8x4","sint8x2","BYTE","sint8x4","unorm8x2","unorm8x4","snorm8x2","snorm8x4","uint16x2","uint16x4","sint16x2","SHORT","sint16x4","unorm16x2","unorm16x4","snorm16x2","snorm16x4","float16x2","HALF_FLOAT","float16x4","float32","FLOAT","float32x2","float32x3","float32x4","uint32","uint32x2","uint32x3","uint32x4","sint32","INT","sint32x2","sint32x3","sint32x4","$0ec8dcdb21c3a0fa$export$65676f49f82312ef","$0ec8dcdb21c3a0fa$export$e58b55460af355b7","$0ec8dcdb21c3a0fa$export$4d480d1b811469a7","GL_FORMATS2","GL_TARGETS2","GL_WRAP_MODES2","GL_TYPES2","$0ec8dcdb21c3a0fa$export$78720182cc3ed053","$f4d90515a13653e7$export$b7a84fc7768ed0dc","$cOnev","$iA5fe","$fK92B","$f4d90515a13653e7$var$bigTriangleGeometry","Geometry","aPosition","$f4d90515a13653e7$var$_GlBackBufferSystem","_GlBackBufferSystem","_useBackBufferThisRender","_antialias","_state","bigTriangleProgram","GlProgram","vertex","fragment","_bigTriangleShader","WHITE","renderStart","renderTarget","getRenderTarget","target","isRoot","renderTarget2","_targetTexture","colorTexture","_getBackBufferTexture","renderEnd","_presentBackBuffer","finishRenderPass","_backBufferTexture","targetSourceTexture","TextureSource","width","height","resolution","_resolution","resize","priority","$43f8a01f682b3752$export$a3d248296e259116","_colorMaskCache","setMask","colorMask","$e8f544f1554f2871$export$9b8b7836a27ecb86","commandFinished","Promise","resolve","setGeometry","skipSync","_activeProgram","$c5b3329420d2f9d8$export$3846305e84de1078","$gmJT6","$eE5Ke","_stencilCache","enabled","stencilReference","stencilMode","STENCIL_MODES","NONE","_renderTargetStencilState","onRenderTargetChange","_comparisonFuncMapping","always","ALWAYS","never","NEVER","equal","EQUAL","NOTEQUAL","less","LESS","LEQUAL","greater","GREATER","GEQUAL","_stencilOpsMapping","keep","KEEP","zero","ZERO","replace","REPLACE","invert","INVERT","INCR","DECR","INCR_WRAP","DECR_WRAP","_activeRenderTarget","stencilState","DISABLED","setStencilMode","mode","GpuStencilModesToPixi","disable","STENCIL_TEST","enable","stencilFunc","stencilBack","compare","stencilOp","passOp","$e581277dbbeb8f40$export$ed85354ffed1ae01","$gl2WV","$3rnpU","$7FPDE","UboSystem","createUboElements","createUboElementsSTD40","generateUboSync","createUboSyncFunctionSTD40","$ccbfffaa00bcbc6d$export$44caba1858fd4b77","$ccbfffaa00bcbc6d$export$aafd0047b5156d22","f32","uniformData","uboElements","map","chunkSize","uboElement","Math","max","lineUpValue","ceil","$329ad5c91db53d1a$export$657524d36b99cfb7","$5NNJl","$1nMtt","$bhzUn","createUboSyncFunction","generateArraySyncSTD40","uboSyncFunctionsSTD40","$0b910441e6a331f2$export$9fb1ab94ee86ec60","offsetToAdd","rowSize","WGSL_TO_STD40_SIZE","elementSize","remainder","$1d7943bd5288cddc$export$50389001704f1c6a","$bFvcQ","$4SXq9","RenderTargetSystem","adaptor","GlRenderTargetAdaptor","$e6015aa5f23f298a$export$d4bf7cc1dbb946ef","$fM4Mk","$8xl7d","$hFYOq","$8ycms","_clearColorCache","_viewPortCache","Rectangle","renderTargetSystem","_renderTargetSystem","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","originDest","glRenderTarget","getGpuRenderTarget","bindFramebuffer","FRAMEBUFFER","resolveTargetFramebuffer","copyTexSubImage2D","TEXTURE_2D","x","y","startRenderPass","clear","clearColor","viewport","gpuRenderTarget","viewPortY","pixelHeight","colorTextures","forEach","framebuffer","viewPortCache","depthStencilRenderBuffer","depth","_initStencil","READ_FRAMEBUFFER","blitFramebuffer","COLOR_BUFFER_BIT","NEAREST","initGpuRenderTarget","GlRenderTarget","CanvasSource","test","resource","_initColor","_renderTarget","CLEAR","ALL","COLOR","defaultClearColor","clearColorCache","clearColorArray","resizeGpuRenderTarget","_resizeColor","_resizeStencil","createFramebuffer","pixelWidth","bindSource","glTexture","glSource","getGlSource","framebufferTexture2D","COLOR_ATTACHMENT0","viewFramebuffer","_","msaaRenderBuffer","createRenderbuffer","source2","glInternalFormat","internalFormat","bindRenderbuffer","RENDERBUFFER","renderbufferStorageMultisample","framebufferRenderbuffer","DEPTH_STENCIL_ATTACHMENT","DEPTH24_STENCIL8","renderbufferStorage","DEPTH_STENCIL","$ad6c4732043c63de$export$849d02ac5943b5e7","$f5d8d0596bd9ab8d$export$54fed9180ab691e4","$43KdE","$9sZUg","$f5d8d0596bd9ab8d$var$defaultSyncData","textureCount","blockIndex","_programDataHash","_nextIndex","_boundUniformsIdsToIndexHash","_boundIndexToUniformsHash","_shaderSyncFunctions","_maxBindings","MAX_UNIFORM_BUFFER_BINDINGS","getParameter","_setProgram","syncFunction","_generateShaderSync","bindUniformBlock","programData","isBufferResource","_bufferResource","ubo","boundIndex","nextIndex","currentBoundUniformGroup","uniformBlockIndex","_uniformBlockData","uniformBlockBindings","uniformBlockBinding","_createProgramData","key","generateProgram","keys","shaderSystem","generateShaderSyncCode","$24ae4fd4bd77e301$export$7b73f9835f0afdab","$1bR8i","funcFragments","headerFragments","addedTextreSystem","group","BufferResource","uniformName","_uniformBindMap","uniform1i","Function","$7613641dd99f08d4$export$44c84e8c8e54bce9","$8yo5i","$4bZHP","$7W2e3","$kel5F","$b6HNS","$3yIvZ","$2nhJs","glVertShader","compileShader","VERTEX_SHADER","glFragShader","FRAGMENT_SHADER","webGLProgram","createProgram","attachShader","transformFeedbackVaryings","names","bufferMode","SEPARATE_ATTRIBS","INTERLEAVED_ATTRIBS","linkProgram","getProgramParameter","LINK_STATUS","logProgramError","extractAttributesFromGlProgram","_uniformData","getUniformData","getUboData","deleteShader","getUniformLocation","defaultValue","GlProgramData","$390445385c240c74$export$ed24f21e055efd10","uniformGroups","uniformDirtyGroups","$e23060614d4157a3$export$9b5304f4eb007cf0","src","createShader","shaderSource","$bc6ac37af3d2844a$var$booleanArray","array","Array","$bc6ac37af3d2844a$export$1a01ae0705bafd37","Uint32Array","$bf8df0b792dc2986$export$8c8c8d19aa26a952","$gV2ls","sortAttributes","totalAttributes","ACTIVE_ATTRIBUTES","attribData","getActiveAttrib","startsWith","mapGlToVertexFormat","sort","bindAttribLocation","getAttribLocation","$1dddf959f73a7109$export$4de3a94418d86ca7","$1dddf959f73a7109$export$7c31aa59606c890c","$1dddf959f73a7109$var$GL_TABLE","$1dddf959f73a7109$var$GL_TO_GLSL_TYPES","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","INT_VEC2","INT_VEC3","INT_VEC4","UNSIGNED_INT_VEC2","UNSIGNED_INT_VEC3","UNSIGNED_INT_VEC4","BOOL","BOOL_VEC2","BOOL_VEC3","BOOL_VEC4","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","SAMPLER_2D","INT_SAMPLER_2D","UNSIGNED_INT_SAMPLER_2D","SAMPLER_CUBE","INT_SAMPLER_CUBE","UNSIGNED_INT_SAMPLER_CUBE","SAMPLER_2D_ARRAY","INT_SAMPLER_2D_ARRAY","UNSIGNED_INT_SAMPLER_2D_ARRAY","$1dddf959f73a7109$var$GLSL_TO_VERTEX_TYPES","float","vec2","vec3","vec4","int","ivec2","ivec3","ivec4","uint","uvec2","uvec3","uvec4","bool","bvec2","bvec3","bvec4","typeNames","tn","$e65c359389111496$export$452e938e127b3a20","ACTIVE_UNIFORM_BLOCKS","uniformBlocks","totalUniformsBlocks","getActiveUniformBlockName","getUniformBlockIndex","getActiveUniformBlockParameter","UNIFORM_BLOCK_DATA_SIZE","$e8f2b0a1c1a069e8$export$d38fd6033d9429a5","totalUniforms","ACTIVE_UNIFORMS","getActiveUniform","isArray","match","mapType","$8579711571469dc1$var$logPrettyShaderError","shaderSrc","getShaderSource","split","line","shaderLog","getShaderInfoLog","splitShader","dedupe","lineNumbers","parseFloat","filter","logArgs","number","fragmentSourceToLog","console","error","groupCollapsed","groupEnd","$8579711571469dc1$export$4b35d6c62dc992b0","vertexShader","fragmentShader","getShaderParameter","COMPILE_STATUS","getProgramInfoLog","$dd7a79aadc34ff0f$export$1dadd6b65a7ae71a","$aUpHF","_cache","_uniformGroupSyncHash","syncData","_dirtyId","syncFunc","_getUniformSyncFunction","_signature","_createUniformSyncFunction","uniformGroupSyncHash","_getSignature","_generateUniformsSync","generateUniformsSync","preFix","$dc036dc5fcdd1552$export$20c95d1c2d5a6828","$4OFSF","$ckHs5","uniform","uniformStructures","parsed","uniformParsers","parser","template","templateType","UNIFORM_TO_SINGLE_SETTERS","UNIFORM_TO_ARRAY_SETTERS","$a179197e5ce62d9d$export$2619e56ae9962898","$a179197e5ce62d9d$export$ac1fb1a14f78b100","i32","u32","$724532dc015d0d7e$export$3ece59c346e5d37","$hA4ZB","$724532dc015d0d7e$var$_GlStateSystem","_GlStateSystem","stateId","polygonOffset","_blendEq","setBlend","setOffset","setCullFace","setDepthTest","setFrontFace","setDepthMask","checks","defaultState","blendModesMap","mapWebGLBlendModesToPixi","diff","call","forceState","_updateCheck","_checkBlendMode","BLEND","_checkPolygonOffset","POLYGON_OFFSET_FILL","DEPTH_TEST","depthMask","CULL_FACE","frontFace","setBlendMode","blendFunc","blendFuncSeparate","blendEquationSeparate","FUNC_ADD","setPolygonOffset","scale","pixelStorei","UNPACK_FLIP_Y_WEBGL","func","indexOf","splice","system","$aa2ebd1b48f322b1$export$57ed86928a8d2aa1","blendMap","normal","ONE","ONE_MINUS_SRC_ALPHA","multiply","DST_COLOR","screen","ONE_MINUS_SRC_COLOR","none","SRC_ALPHA","erase","$16148d8c3c382afd$export$a4a6f67fda81946a","$8V3H6","$7HHTi","$e2J15","$4DDYK","$gHIBu","$4JQmo","$6mS9o","$l9Yyl","$lkFWs","managedTextures","_glTextures","_glSamplers","_boundTextures","_activeTextureLocation","_boundSamplers","_uploads","image","glUploadImageResource","glUploadBufferImageResource","video","glUploadVideoResource","compressed","glUploadCompressedTextureResource","_useSeparateSamplers","_mapFormatToInternalFormat","mapFormatToGlInternalFormat","_mapFormatToType","mapFormatToGlType","_mapFormatToFormat","mapFormatToGlFormat","initSource","_bindSampler","_touched","textureGC","count","_activateLocation","bindTexture","bindSampler","sampler","_getGlSampler","boundTextures","activeTexture","TEXTURE0","_initSource","GlTexture","createTexture","autoGenerateMipmaps","isPowerOfTwo","biggestDimension","mipLevelCount","floor","log2","includes","onSourceUpdate","onStyleChange","onSourceDestroy","onSourceUnload","onUpdateMipmaps","updateStyle","firstCreation","applyStyleParams","deleteTexture","uploadMethodId","upload","texImage2D","RGBA","generateMipmap","off","_initSampler","glSampler","createSampler","_resourceId","generateCanvas","pixels","getPixels","createCanvas","ctx","imageData","createImageData","putImageData","frame","round","Uint8Array","$16148d8c3c382afd$var$BYTES_PER_PIXEL","glRenterTarget","readPixels","Uint8ClampedArray","slice","$f9536c3ec3a863a1$export$77c65e0fc65f3a30","GL_TARGETS","GL_FORMATS","samplerType","$2d24f7c2359a60e1$export$aa4eec5aa64bfd28","texSubImage2D","$9ef5b33d36b4d06b$export$97d1715760cee374","$9ef5b33d36b4d06b$var$compressedFormatMap","UNPACK_ALIGNMENT","mipWidth","mipHeight","levelBuffer","compressedTexImage2D","$52029e2e17d70473$export$3cfb43b040bc4df8","alphaMode","UNPACK_PREMULTIPLY_ALPHA_WEBGL","glWidth","glHeight","textureWidth","textureHeight","resourceWidth","resourceHeight","$4ebe7112f6bf6666$export$a442959494e20fc","isValid","$94f5659bdaf1001d$export$7be2fbeda5b178b7","$2SVDG","mipmaps","anisotropicExt","glFunctionName","firstParam","forceClamp","addressModeU","addressModeV","addressModeW","wrapModeS","wrapModeToGlAddress","wrapModeT","wrapModeR","TEXTURE_WRAP_S","TEXTURE_WRAP_T","TEXTURE_WRAP_R","magFilter","TEXTURE_MAG_FILTER","scaleModeToGlFilter","mipmapFilter","glFilterMode","mipmapScaleModeToGlFilter","minFilter","TEXTURE_MIN_FILTER","maxAnisotropy","level","min","MAX_TEXTURE_MAX_ANISOTROPY_EXT","TEXTURE_MAX_ANISOTROPY_EXT","TEXTURE_COMPARE_FUNC","compareModeToGlCompare","$dacba914c81174bd$export$801e6deda261184a","$dacba914c81174bd$export$aba49ce9fa09b298","$dacba914c81174bd$export$cc1c4e2fb99490bd","$dacba914c81174bd$export$4518bf8c33a3aebc","linear","nearest","repeat","$e88cdb8c143a8533$export$42ed406df12ab342","r8unorm","RED","r8snorm","r8uint","r8sint","r16uint","r16sint","r16float","rg8unorm","RG","rg8snorm","rg8uint","rg8sint","r32uint","r32sint","r32float","rg16uint","rg16sint","rg16float","rgba8unorm","rgba8snorm","rgba8uint","rgba8sint","bgra8unorm","rgb9e5ufloat","RGB","rgb10a2unorm","rg11b10ufloat","rg32uint","rg32sint","rg32float","rgba16uint","rgba16sint","rgba16float","rgba32uint","rgba32sint","rgba32float","stencil8","STENCIL_INDEX8","depth16unorm","DEPTH_COMPONENT","depth24plus","depth32float","$0ca35fd83728246d$export$555b87969daa38c6","SRGB8_ALPHA8_EXT","SRGB8_ALPHA8","RGBA8","R8","R8_SNORM","R8UI","R8I","R16UI","R16I","R16F","RG8","RG8_SNORM","RG8UI","RG8I","R32UI","R32I","R32F","RG16UI","RG16I","RG16F","RGBA8_SNORM","RGBA8UI","RGBA8I","RGB9_E5","RGB10_A2","R11F_G11F_B10F","RG32UI","RG32I","RG32F","RGBA16UI","RGBA16I","RGBA16F","RGBA32UI","RGBA32I","RGBA32F","DEPTH_COMPONENT16","DEPTH_COMPONENT24","DEPTH_COMPONENT32F","DEPTH32F_STENCIL8","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT","COMPRESSED_RED_RGTC1_EXT","COMPRESSED_SIGNED_RED_RGTC1_EXT","COMPRESSED_RED_GREEN_RGTC2_EXT","COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT","COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT","COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT","COMPRESSED_RGBA_BPTC_UNORM_EXT","COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT","COMPRESSED_RGB8_ETC2","COMPRESSED_SRGB8_ETC2","COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2","COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2","COMPRESSED_RGBA8_ETC2_EAC","COMPRESSED_SRGB8_ALPHA8_ETC2_EAC","COMPRESSED_R11_EAC","COMPRESSED_SIGNED_RG11_EAC","COMPRESSED_RGBA_ASTC_4x4_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR","COMPRESSED_RGBA_ASTC_5x4_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR","COMPRESSED_RGBA_ASTC_5x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR","COMPRESSED_RGBA_ASTC_6x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR","COMPRESSED_RGBA_ASTC_6x6_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR","COMPRESSED_RGBA_ASTC_8x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR","COMPRESSED_RGBA_ASTC_8x6_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR","COMPRESSED_RGBA_ASTC_8x8_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR","COMPRESSED_RGBA_ASTC_10x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR","COMPRESSED_RGBA_ASTC_10x6_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR","COMPRESSED_RGBA_ASTC_10x8_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR","COMPRESSED_RGBA_ASTC_10x10_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR","COMPRESSED_RGBA_ASTC_12x10_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR","COMPRESSED_RGBA_ASTC_12x12_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR","$1afec7d3f497de00$export$21c93d3b4ec1a2c2","UNSIGNED_INT_5_9_9_9_REV","UNSIGNED_INT_2_10_10_10_REV","UNSIGNED_INT_10F_11F_11F_REV","UNSIGNED_INT_24_8","FLOAT_32_UNSIGNED_INT_24_8_REV","GL_WRAP_MODES"],"version":3,"file":"WebGLRenderer.717481ab.js.map"}